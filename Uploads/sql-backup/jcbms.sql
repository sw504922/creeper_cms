/*
 Navicat Premium Data Transfer

 Source Server         : 192.168.2.171
 Source Server Type    : MySQL
 Source Server Version : 50721
 Source Host           : 192.168.2.171:13306
 Source Schema         : jcbms

 Target Server Type    : MySQL
 Target Server Version : 50721
 File Encoding         : 65001

 Date: 27/05/2022 15:14:09
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for account_20200521
-- ----------------------------
DROP TABLE IF EXISTS `account_20200521`;
CREATE TABLE `account_20200521` (
  `account_id` varchar(16) DEFAULT NULL,
  KEY `account_id` (`account_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_balance
-- ----------------------------
DROP TABLE IF EXISTS `account_balance`;
CREATE TABLE `account_balance` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `trade_balance` decimal(30,10) DEFAULT '0.0000000000',
  `settle_balance` decimal(30,10) DEFAULT '0.0000000000',
  `balance_avail` decimal(30,10) DEFAULT '0.0000000000',
  `balance_extract` decimal(30,10) DEFAULT '0.0000000000',
  `market_value` decimal(30,10) DEFAULT '0.0000000000',
  `long_market_value` decimal(30,10) DEFAULT '0.0000000000',
  `short_market_value` decimal(30,10) DEFAULT '0.0000000000',
  `equity_balance` decimal(30,10) DEFAULT NULL,
  `equity` decimal(30,10) DEFAULT '0.0000000000',
  `frozen_amount` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_amount` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `realized_pnl` decimal(30,10) DEFAULT '0.0000000000',
  `unrealized_pnl` decimal(30,10) DEFAULT '0.0000000000',
  `margin_amt` decimal(30,10) DEFAULT '0.0000000000',
  `charges` decimal(30,10) DEFAULT '0.0000000000',
  `portfolio_fee` decimal(30,10) DEFAULT '0.0000000000',
  `interest` decimal(30,10) DEFAULT '0.0000000000',
  `accrued_interest` decimal(30,10) DEFAULT '0.0000000000',
  `accrued_interest_credit` decimal(30,10) DEFAULT '0.0000000000',
  `debit_interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `credit_interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `ipo_frozen_before_close` decimal(30,10) DEFAULT '0.0000000000',
  `ipo_frozen_before_allot` decimal(30,10) DEFAULT '0.0000000000',
  `placing_amount_before_allot` decimal(30,10) NOT NULL DEFAULT '0.0000000000',
  `unsettled_to_pay` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_to_receive` decimal(30,10) DEFAULT '0.0000000000',
  PRIMARY KEY (`id`),
  KEY `idx1` (`process_date`,`account_id`,`account_type`,`currency`),
  KEY `idx2` (`process_date`,`account_id`),
  KEY `idx3` (`process_date`,`account_id`,`currency`)
) ENGINE=InnoDB AUTO_INCREMENT=69313813 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_balance_20200409
-- ----------------------------
DROP TABLE IF EXISTS `account_balance_20200409`;
CREATE TABLE `account_balance_20200409` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `trade_balance` decimal(30,10) DEFAULT '0.0000000000',
  `settle_balance` decimal(30,10) DEFAULT '0.0000000000',
  `balance_avail` decimal(30,10) DEFAULT '0.0000000000',
  `balance_extract` decimal(30,10) DEFAULT '0.0000000000',
  `market_value` decimal(30,10) DEFAULT '0.0000000000',
  `long_market_value` decimal(30,10) DEFAULT '0.0000000000',
  `short_market_value` decimal(30,10) DEFAULT '0.0000000000',
  `equity_balance` decimal(30,10) DEFAULT NULL,
  `equity` decimal(30,10) DEFAULT '0.0000000000',
  `frozen_amount` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_amount` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `realized_pnl` decimal(30,10) DEFAULT '0.0000000000',
  `unrealized_pnl` decimal(30,10) DEFAULT '0.0000000000',
  `margin_amt` decimal(30,10) DEFAULT '0.0000000000',
  `charges` decimal(30,10) DEFAULT '0.0000000000',
  `portfolio_fee` decimal(30,10) DEFAULT '0.0000000000',
  `interest` decimal(30,10) DEFAULT '0.0000000000',
  `accrued_interest` decimal(30,10) DEFAULT '0.0000000000',
  `accrued_interest_credit` decimal(30,10) DEFAULT '0.0000000000',
  `debit_interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `credit_interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `ipo_frozen_before_close` decimal(30,10) DEFAULT '0.0000000000',
  `ipo_frozen_before_allot` decimal(30,10) DEFAULT '0.0000000000',
  `placing_amount_before_allot` decimal(30,10) NOT NULL DEFAULT '0.0000000000'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_balance_20200511
-- ----------------------------
DROP TABLE IF EXISTS `account_balance_20200511`;
CREATE TABLE `account_balance_20200511` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `trade_balance` decimal(30,10) DEFAULT '0.0000000000',
  `settle_balance` decimal(30,10) DEFAULT '0.0000000000',
  `balance_avail` decimal(30,10) DEFAULT '0.0000000000',
  `balance_extract` decimal(30,10) DEFAULT '0.0000000000',
  `market_value` decimal(30,10) DEFAULT '0.0000000000',
  `long_market_value` decimal(30,10) DEFAULT '0.0000000000',
  `short_market_value` decimal(30,10) DEFAULT '0.0000000000',
  `equity_balance` decimal(30,10) DEFAULT NULL,
  `equity` decimal(30,10) DEFAULT '0.0000000000',
  `frozen_amount` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_amount` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `realized_pnl` decimal(30,10) DEFAULT '0.0000000000',
  `unrealized_pnl` decimal(30,10) DEFAULT '0.0000000000',
  `margin_amt` decimal(30,10) DEFAULT '0.0000000000',
  `charges` decimal(30,10) DEFAULT '0.0000000000',
  `portfolio_fee` decimal(30,10) DEFAULT '0.0000000000',
  `interest` decimal(30,10) DEFAULT '0.0000000000',
  `accrued_interest` decimal(30,10) DEFAULT '0.0000000000',
  `accrued_interest_credit` decimal(30,10) DEFAULT '0.0000000000',
  `debit_interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `credit_interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `ipo_frozen_before_close` decimal(30,10) DEFAULT '0.0000000000',
  `ipo_frozen_before_allot` decimal(30,10) DEFAULT '0.0000000000',
  `placing_amount_before_allot` decimal(30,10) NOT NULL DEFAULT '0.0000000000'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_balance_bak_20200527
-- ----------------------------
DROP TABLE IF EXISTS `account_balance_bak_20200527`;
CREATE TABLE `account_balance_bak_20200527` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `trade_balance` decimal(30,10) DEFAULT '0.0000000000',
  `settle_balance` decimal(30,10) DEFAULT '0.0000000000',
  `balance_avail` decimal(30,10) DEFAULT '0.0000000000',
  `balance_extract` decimal(30,10) DEFAULT '0.0000000000',
  `market_value` decimal(30,10) DEFAULT '0.0000000000',
  `long_market_value` decimal(30,10) DEFAULT '0.0000000000',
  `short_market_value` decimal(30,10) DEFAULT '0.0000000000',
  `equity_balance` decimal(30,10) DEFAULT NULL,
  `equity` decimal(30,10) DEFAULT '0.0000000000',
  `frozen_amount` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_amount` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `realized_pnl` decimal(30,10) DEFAULT '0.0000000000',
  `unrealized_pnl` decimal(30,10) DEFAULT '0.0000000000',
  `margin_amt` decimal(30,10) DEFAULT '0.0000000000',
  `charges` decimal(30,10) DEFAULT '0.0000000000',
  `portfolio_fee` decimal(30,10) DEFAULT '0.0000000000',
  `interest` decimal(30,10) DEFAULT '0.0000000000',
  `accrued_interest` decimal(30,10) DEFAULT '0.0000000000',
  `accrued_interest_credit` decimal(30,10) DEFAULT '0.0000000000',
  `debit_interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `credit_interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `ipo_frozen_before_close` decimal(30,10) DEFAULT '0.0000000000',
  `ipo_frozen_before_allot` decimal(30,10) DEFAULT '0.0000000000',
  `placing_amount_before_allot` decimal(30,10) NOT NULL DEFAULT '0.0000000000'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_balance_bak_20200610
-- ----------------------------
DROP TABLE IF EXISTS `account_balance_bak_20200610`;
CREATE TABLE `account_balance_bak_20200610` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `trade_balance` decimal(30,10) DEFAULT '0.0000000000',
  `settle_balance` decimal(30,10) DEFAULT '0.0000000000',
  `balance_avail` decimal(30,10) DEFAULT '0.0000000000',
  `balance_extract` decimal(30,10) DEFAULT '0.0000000000',
  `market_value` decimal(30,10) DEFAULT '0.0000000000',
  `long_market_value` decimal(30,10) DEFAULT '0.0000000000',
  `short_market_value` decimal(30,10) DEFAULT '0.0000000000',
  `equity_balance` decimal(30,10) DEFAULT NULL,
  `equity` decimal(30,10) DEFAULT '0.0000000000',
  `frozen_amount` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_amount` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `realized_pnl` decimal(30,10) DEFAULT '0.0000000000',
  `unrealized_pnl` decimal(30,10) DEFAULT '0.0000000000',
  `margin_amt` decimal(30,10) DEFAULT '0.0000000000',
  `charges` decimal(30,10) DEFAULT '0.0000000000',
  `portfolio_fee` decimal(30,10) DEFAULT '0.0000000000',
  `interest` decimal(30,10) DEFAULT '0.0000000000',
  `accrued_interest` decimal(30,10) DEFAULT '0.0000000000',
  `accrued_interest_credit` decimal(30,10) DEFAULT '0.0000000000',
  `debit_interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `credit_interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `ipo_frozen_before_close` decimal(30,10) DEFAULT '0.0000000000',
  `ipo_frozen_before_allot` decimal(30,10) DEFAULT '0.0000000000',
  `placing_amount_before_allot` decimal(30,10) NOT NULL DEFAULT '0.0000000000',
  `unsettled_to_pay` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_to_receive` decimal(30,10) DEFAULT '0.0000000000'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_charge
-- ----------------------------
DROP TABLE IF EXISTS `account_charge`;
CREATE TABLE `account_charge` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '-1',
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(32) DEFAULT '',
  `currency` int(11) DEFAULT NULL,
  `external_id` varchar(32) DEFAULT '',
  `external_id2` varchar(32) DEFAULT '',
  `charge_code` varchar(36) DEFAULT NULL,
  `formula_code` varchar(32) DEFAULT NULL,
  `formula_type` varchar(8) DEFAULT NULL,
  `charges` decimal(30,10) DEFAULT '0.0000000000',
  `accrued_charges` decimal(30,10) DEFAULT '0.0000000000',
  `sum_flag` int(11) DEFAULT '0',
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`external_id`,`external_id2`,`charge_code`,`formula_type`)
) ENGINE=InnoDB AUTO_INCREMENT=34527433 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_charge_rule
-- ----------------------------
DROP TABLE IF EXISTS `account_charge_rule`;
CREATE TABLE `account_charge_rule` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `account_id` varchar(16) DEFAULT NULL,
  `charge_code` varchar(32) DEFAULT '',
  `formula_type` varchar(16) DEFAULT '',
  `formula_code` varchar(32) DEFAULT '',
  `waive` varchar(1) DEFAULT '',
  `due_date` varchar(8) DEFAULT '',
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx1` (`account_id`,`charge_code`,`formula_type`),
  KEY `idx2` (`due_date`)
) ENGINE=InnoDB AUTO_INCREMENT=7590 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_charge_rule_20191226
-- ----------------------------
DROP TABLE IF EXISTS `account_charge_rule_20191226`;
CREATE TABLE `account_charge_rule_20191226` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `account_id` varchar(16) DEFAULT NULL,
  `charge_code` varchar(32) DEFAULT '',
  `formula_type` varchar(16) DEFAULT '',
  `formula_code` varchar(32) DEFAULT '',
  `waive` varchar(1) DEFAULT '',
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_commission_rule
-- ----------------------------
DROP TABLE IF EXISTS `account_commission_rule`;
CREATE TABLE `account_commission_rule` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `account_id` char(16) DEFAULT NULL,
  `market_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT '0',
  `formula_type` char(32) DEFAULT NULL,
  `formula_code` char(32) DEFAULT NULL,
  `waive` varchar(1) DEFAULT '',
  `update_time` datetime DEFAULT NULL,
  `update_user` char(16) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx1` (`account_id`,`market_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3305 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_commission_rule_20191226
-- ----------------------------
DROP TABLE IF EXISTS `account_commission_rule_20191226`;
CREATE TABLE `account_commission_rule_20191226` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `account_id` char(16) DEFAULT NULL,
  `market_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT '0',
  `formula_type` char(32) DEFAULT NULL,
  `formula_code` char(32) DEFAULT NULL,
  `waive` varchar(1) DEFAULT '',
  `update_time` datetime DEFAULT NULL,
  `update_user` char(16) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_interest
-- ----------------------------
DROP TABLE IF EXISTS `account_interest`;
CREATE TABLE `account_interest` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `currency` int(11) DEFAULT '0',
  `Bal` decimal(21,6) DEFAULT NULL,
  `PrimeRate` decimal(21,6) DEFAULT NULL,
  `SavingRate` decimal(21,6) DEFAULT NULL,
  `debit_formula_type` char(32) DEFAULT NULL,
  `debit_formula_code` char(32) DEFAULT NULL,
  `credit_formula_type` char(32) DEFAULT NULL,
  `credit_formula_code` char(32) DEFAULT NULL,
  `debit_interest` decimal(21,6) DEFAULT NULL,
  `credit_interest` decimal(21,6) DEFAULT NULL,
  `waive` varchar(1) DEFAULT '',
  `debit_interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `credit_interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  PRIMARY KEY (`id`),
  KEY `idx1` (`process_date`,`account_id`,`account_type`,`currency`),
  KEY `idx2` (`account_id`,`account_type`,`currency`)
) ENGINE=InnoDB AUTO_INCREMENT=98506523 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_interest_adj
-- ----------------------------
DROP TABLE IF EXISTS `account_interest_adj`;
CREATE TABLE `account_interest_adj` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT '0',
  `adj_interest` decimal(30,10) DEFAULT '0.0000000000',
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`process_date`,`account_id`,`account_type`,`currency`),
  KEY `idx2` (`process_date`,`account_id`)
) ENGINE=InnoDB AUTO_INCREMENT=24725 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_interest_rule
-- ----------------------------
DROP TABLE IF EXISTS `account_interest_rule`;
CREATE TABLE `account_interest_rule` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `account_id` varchar(16) DEFAULT NULL,
  `currency` int(11) DEFAULT '0',
  `debit_formula_code` varchar(32) DEFAULT '',
  `credit_formula_code` varchar(32) DEFAULT '',
  `margin_call_formula_code` varchar(32) DEFAULT '',
  `waive` varchar(1) DEFAULT '',
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`account_id`,`currency`,`waive`)
) ENGINE=InnoDB AUTO_INCREMENT=8235 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_order_detail
-- ----------------------------
DROP TABLE IF EXISTS `account_order_detail`;
CREATE TABLE `account_order_detail` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `order_no` char(32) DEFAULT NULL,
  `order_date` date DEFAULT NULL,
  `order_time` time DEFAULT NULL,
  `business_department` char(16) DEFAULT NULL,
  `department_trading_group` char(16) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `list_market_id` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT NULL,
  `product_sub_type` char(16) DEFAULT NULL,
  `product_id` char(16) DEFAULT NULL,
  `product_description` varchar(255) DEFAULT NULL,
  `quote_currency` char(3) DEFAULT NULL,
  `clearing_currency` char(3) DEFAULT NULL,
  `exchange_rate` decimal(30,10) DEFAULT NULL,
  `buy_sell` int(11) DEFAULT NULL,
  `order_price` decimal(30,10) DEFAULT NULL,
  `order_quantity` decimal(30,10) DEFAULT NULL,
  `trade_quantity` decimal(30,10) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `open_close` int(11) DEFAULT NULL,
  `hedge_flag` int(11) DEFAULT NULL,
  `call_put` int(11) DEFAULT NULL,
  `strike_price` decimal(30,10) DEFAULT NULL,
  `contract_date` date DEFAULT NULL,
  `input_channel` int(11) DEFAULT NULL,
  `remark` text,
  `update_time` datetime DEFAULT NULL,
  `update_user` char(16) DEFAULT NULL,
  `is_odd_lot` varchar(1) DEFAULT '',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3820286 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_portfolio_fee
-- ----------------------------
DROP TABLE IF EXISTS `account_portfolio_fee`;
CREATE TABLE `account_portfolio_fee` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` datetime DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `portfolio_value` decimal(30,10) DEFAULT '0.0000000000',
  `base_portfolio_value` decimal(30,10) DEFAULT '0.0000000000',
  `formula_code` char(32) DEFAULT NULL,
  `formula_value` char(255) DEFAULT NULL,
  `charge_rate` decimal(30,10) DEFAULT '0.0000000000',
  `charge_amount` decimal(30,10) DEFAULT '0.0000000000',
  `base_charge_amount` decimal(30,10) DEFAULT '0.0000000000',
  `portfolio_value_t0` decimal(30,10) DEFAULT '0.0000000000',
  `base_portfolio_value_t0` decimal(30,10) DEFAULT '0.0000000000',
  PRIMARY KEY (`id`),
  KEY `idx1` (`process_date`,`market_id`,`currency`,`account_type`,`account_id`),
  KEY `idx2` (`process_date`,`market_id`,`account_type`,`account_id`)
) ENGINE=InnoDB AUTO_INCREMENT=181225 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_portfolio_fee_bak
-- ----------------------------
DROP TABLE IF EXISTS `account_portfolio_fee_bak`;
CREATE TABLE `account_portfolio_fee_bak` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` datetime DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `portfolio_value` decimal(30,10) DEFAULT '0.0000000000',
  `base_portfolio_value` decimal(30,10) DEFAULT '0.0000000000',
  `formula_code` char(32) DEFAULT NULL,
  `formula_value` char(255) DEFAULT NULL,
  `charge_rate` decimal(30,10) DEFAULT '0.0000000000',
  `charge_amount` decimal(30,10) DEFAULT '0.0000000000',
  `base_charge_amount` decimal(30,10) DEFAULT '0.0000000000',
  `portfolio_value_t0` decimal(30,10) DEFAULT '0.0000000000',
  `base_portfolio_value_t0` decimal(30,10) DEFAULT '0.0000000000'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_position
-- ----------------------------
DROP TABLE IF EXISTS `account_position`;
CREATE TABLE `account_position` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT '0',
  `product_id` varchar(32) DEFAULT '',
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `net_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `frozen_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price1` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price2` decimal(30,10) DEFAULT '0.0000000000',
  `pnl` decimal(30,10) DEFAULT '0.0000000000',
  `market_value` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_amount` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `settled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `settled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `last_closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `margin_amount` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT '',
  `custodian_account` varchar(16) DEFAULT '',
  `nominee_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `position_cost` decimal(30,10) DEFAULT '0.0000000000',
  PRIMARY KEY (`id`),
  KEY `idx1` (`process_date`,`market_id`,`product_type`),
  KEY `idx3` (`process_date`,`account_id`),
  KEY `idx2` (`process_date`,`market_id`,`product_id`,`account_id`,`account_type`,`custodian_code`,`custodian_account`),
  KEY `idx4` (`process_date`,`product_id`),
  KEY `idx5` (`process_date`,`account_type`),
  KEY `idx6` (`market_id`,`product_id`,`custodian_code`,`custodian_account`),
  KEY `idx7` (`product_id`,`custodian_code`,`custodian_account`),
  KEY `idx8` (`custodian_code`,`custodian_account`),
  KEY `idx9` (`process_date`,`market_id`,`account_id`,`net_quantity`,`avg_price1`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=49744639 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_position_20200220
-- ----------------------------
DROP TABLE IF EXISTS `account_position_20200220`;
CREATE TABLE `account_position_20200220` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `net_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `frozen_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price1` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price2` decimal(30,10) DEFAULT '0.0000000000',
  `pnl` decimal(30,10) DEFAULT '0.0000000000',
  `market_value` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_amount` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `settled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `settled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `last_closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `margin_amount` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT '',
  `custodian_account` varchar(16) DEFAULT '',
  `nominee_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `position_cost` decimal(30,10) DEFAULT '0.0000000000'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_position_20200409
-- ----------------------------
DROP TABLE IF EXISTS `account_position_20200409`;
CREATE TABLE `account_position_20200409` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `net_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `frozen_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price1` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price2` decimal(30,10) DEFAULT '0.0000000000',
  `pnl` decimal(30,10) DEFAULT '0.0000000000',
  `market_value` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_amount` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `settled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `settled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `last_closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `margin_amount` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT '',
  `custodian_account` varchar(16) DEFAULT '',
  `nominee_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `position_cost` decimal(30,10) DEFAULT '0.0000000000'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_position_20200511
-- ----------------------------
DROP TABLE IF EXISTS `account_position_20200511`;
CREATE TABLE `account_position_20200511` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `net_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `frozen_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price1` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price2` decimal(30,10) DEFAULT '0.0000000000',
  `pnl` decimal(30,10) DEFAULT '0.0000000000',
  `market_value` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_amount` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `settled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `settled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `last_closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `margin_amount` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT '',
  `custodian_account` varchar(16) DEFAULT '',
  `nominee_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `position_cost` decimal(30,10) DEFAULT '0.0000000000'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_position_20200512
-- ----------------------------
DROP TABLE IF EXISTS `account_position_20200512`;
CREATE TABLE `account_position_20200512` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `net_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `frozen_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price1` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price2` decimal(30,10) DEFAULT '0.0000000000',
  `pnl` decimal(30,10) DEFAULT '0.0000000000',
  `market_value` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_amount` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `settled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `settled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `last_closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `margin_amount` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT '',
  `custodian_account` varchar(16) DEFAULT '',
  `nominee_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `position_cost` decimal(30,10) DEFAULT '0.0000000000'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_position_20201104_05
-- ----------------------------
DROP TABLE IF EXISTS `account_position_20201104_05`;
CREATE TABLE `account_position_20201104_05` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `net_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `frozen_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price1` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price2` decimal(30,10) DEFAULT '0.0000000000',
  `pnl` decimal(30,10) DEFAULT '0.0000000000',
  `market_value` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_amount` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `settled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `settled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `last_closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `margin_amount` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT '',
  `custodian_account` varchar(16) DEFAULT '',
  `nominee_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `position_cost` decimal(30,10) DEFAULT '0.0000000000'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_position_bak_20200610
-- ----------------------------
DROP TABLE IF EXISTS `account_position_bak_20200610`;
CREATE TABLE `account_position_bak_20200610` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `net_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `frozen_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price1` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price2` decimal(30,10) DEFAULT '0.0000000000',
  `pnl` decimal(30,10) DEFAULT '0.0000000000',
  `market_value` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_amount` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `settled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `settled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `last_closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `margin_amount` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT '',
  `custodian_account` varchar(16) DEFAULT '',
  `nominee_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `position_cost` decimal(30,10) DEFAULT '0.0000000000'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_position_bak_20200903
-- ----------------------------
DROP TABLE IF EXISTS `account_position_bak_20200903`;
CREATE TABLE `account_position_bak_20200903` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `net_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `frozen_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price1` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price2` decimal(30,10) DEFAULT '0.0000000000',
  `pnl` decimal(30,10) DEFAULT '0.0000000000',
  `market_value` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_amount` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `settled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `settled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `last_closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `margin_amount` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT '',
  `custodian_account` varchar(16) DEFAULT '',
  `nominee_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `position_cost` decimal(30,10) DEFAULT '0.0000000000'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_position_uco
-- ----------------------------
DROP TABLE IF EXISTS `account_position_uco`;
CREATE TABLE `account_position_uco` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `net_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `frozen_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price1` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price2` decimal(30,10) DEFAULT '0.0000000000',
  `pnl` decimal(30,10) DEFAULT '0.0000000000',
  `market_value` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_amount` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `settled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `settled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `last_closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `margin_amount` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT '',
  `custodian_account` varchar(16) DEFAULT '',
  `nominee_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `position_cost` decimal(30,10) DEFAULT '0.0000000000'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_product_flow
-- ----------------------------
DROP TABLE IF EXISTS `account_product_flow`;
CREATE TABLE `account_product_flow` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `flow_id` varchar(32) DEFAULT '' COMMENT 'unique id in the system , YYYYYMMDD+incrementnumber',
  `original_flow_id` varchar(32) DEFAULT '' COMMENT 'if cancel one cash id , should be the original cashid',
  `process_date` date DEFAULT NULL COMMENT 'entry process date ',
  `trade_date` date DEFAULT NULL COMMENT 'when can use for trade balance,  we can deposit 1000 today, add to tradebalance today,but add to settle balance T+1',
  `settle_date` date DEFAULT NULL COMMENT 'when can use for settle balance',
  `market` int(11) DEFAULT '0',
  `product_id` varchar(32) DEFAULT '',
  `account_id` varchar(32) DEFAULT '',
  `account_type` varchar(1) DEFAULT '',
  `custodian_code` varchar(32) DEFAULT '' COMMENT 'related the position custodian code',
  `custodian_account` varchar(32) DEFAULT '' COMMENT 'related position custodian account',
  `balance` decimal(30,10) DEFAULT '0.0000000000' COMMENT 'balance after deposit/withdraw',
  `quantity` decimal(30,10) DEFAULT '0.0000000000' COMMENT 'quantity deposit/withdraw, + or -',
  `avg_price` decimal(30,10) DEFAULT '0.0000000000' COMMENT 'avg_price for this position',
  `type` int(11) DEFAULT '0',
  `remark` varchar(128) DEFAULT '',
  `status` int(11) DEFAULT '0' COMMENT 'see clearing.dictionary',
  `update_user` varchar(32) DEFAULT NULL,
  `updat_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx1` (`flow_id`,`original_flow_id`),
  KEY `idx2` (`status`,`process_date`,`market`,`product_id`,`account_id`,`account_type`,`custodian_code`,`custodian_account`),
  KEY `idx3` (`status`,`trade_date`,`market`,`product_id`,`account_id`,`account_type`,`custodian_code`,`custodian_account`),
  KEY `idx4` (`status`,`settle_date`,`market`,`product_id`,`account_id`,`account_type`,`custodian_code`,`custodian_account`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_profile
-- ----------------------------
DROP TABLE IF EXISTS `account_profile`;
CREATE TABLE `account_profile` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `business_department` char(16) DEFAULT NULL,
  `department_trading_group` char(16) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `first_name` varchar(64) DEFAULT NULL,
  `middle_name` varchar(64) DEFAULT NULL,
  `last_name` varchar(64) DEFAULT NULL,
  `short_name` varchar(128) DEFAULT NULL,
  `first_name_eng` varchar(64) DEFAULT '',
  `last_name_eng` varchar(64) DEFAULT '',
  `birth_day` date DEFAULT NULL,
  `gender` varchar(1) DEFAULT NULL,
  `primary_joint` int(11) DEFAULT '0',
  `phone1` varchar(32) DEFAULT NULL,
  `phone2` varchar(32) DEFAULT NULL,
  `phone3` varchar(32) DEFAULT NULL,
  `email_address` varchar(64) DEFAULT NULL,
  `mailing_address` varchar(512) DEFAULT NULL,
  `daily_statement_email_address` int(11) DEFAULT '0',
  `monthly_statement_email_address` int(11) DEFAULT '0',
  `address1` varchar(512) DEFAULT NULL,
  `address2` varchar(512) DEFAULT NULL,
  `address3` varchar(512) DEFAULT NULL,
  `address4` varchar(512) DEFAULT NULL,
  `city` varchar(32) DEFAULT NULL,
  `state` varchar(32) DEFAULT NULL,
  `zip` varchar(32) DEFAULT NULL,
  `country` varchar(8) DEFAULT '',
  `partyid_type` int(11) DEFAULT NULL,
  `partyid` varchar(32) DEFAULT NULL,
  `party_country` varchar(8) DEFAULT '',
  `party_effective_date` date DEFAULT NULL,
  `party_expiration_date` date DEFAULT NULL,
  `photoid_type` int(11) DEFAULT NULL,
  `photoid` varchar(32) DEFAULT NULL,
  `photo_country` varchar(8) DEFAULT '',
  `photo_effective_date` date DEFAULT NULL,
  `photo_expiration_date` date DEFAULT NULL,
  `bank` varchar(32) DEFAULT NULL,
  `bank_account_id` varchar(32) DEFAULT NULL,
  `bank_account_name` varchar(32) DEFAULT NULL,
  `employment` varchar(32) DEFAULT NULL,
  `employer_name` varchar(128) DEFAULT '',
  `employer_address1` varchar(512) DEFAULT NULL,
  `employer_address2` varchar(512) DEFAULT NULL,
  `employer_address3` varchar(512) DEFAULT NULL,
  `employer_address4` varchar(512) DEFAULT NULL,
  `employer_city` varchar(32) DEFAULT NULL,
  `employer_state` varchar(32) DEFAULT NULL,
  `employer_zip` varchar(32) DEFAULT NULL,
  `employer_country` varchar(8) DEFAULT '',
  `employer_phone1` varchar(32) DEFAULT NULL,
  `employer_phone2` varchar(32) DEFAULT NULL,
  `employer_phone3` varchar(32) DEFAULT NULL,
  `is_government_official` char(1) DEFAULT 'N',
  `is_terrorist` char(1) DEFAULT 'N',
  `famaliy_income` int(11) DEFAULT '0',
  `famaliy_equity` int(11) DEFAULT '0',
  `risk_tolerance` int(11) DEFAULT '0',
  `invest_target` int(11) DEFAULT '0',
  `security_experience` int(11) DEFAULT '0',
  `fund_experience` int(11) DEFAULT '0',
  `forien_exchange_experience` int(11) DEFAULT '0',
  `fixed_income_experience` int(11) DEFAULT '0',
  `others_incom_experience` int(11) DEFAULT '0',
  `bos_uuid` varchar(32) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `insert_time` datetime DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `account_class` varchar(8) DEFAULT '',
  `account_sub_class` varchar(32) DEFAULT '',
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx1` (`account_id`)
) ENGINE=InnoDB AUTO_INCREMENT=160346 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_profile_20201110
-- ----------------------------
DROP TABLE IF EXISTS `account_profile_20201110`;
CREATE TABLE `account_profile_20201110` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `business_department` char(16) DEFAULT NULL,
  `department_trading_group` char(16) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `first_name` varchar(32) DEFAULT NULL,
  `middle_name` varchar(32) DEFAULT NULL,
  `last_name` varchar(32) DEFAULT NULL,
  `short_name` varchar(128) DEFAULT NULL,
  `birth_day` date DEFAULT NULL,
  `gender` varchar(1) DEFAULT NULL,
  `primary_joint` int(11) DEFAULT '0',
  `phone1` varchar(32) DEFAULT NULL,
  `phone2` varchar(32) DEFAULT NULL,
  `phone3` varchar(32) DEFAULT NULL,
  `email_address` varchar(64) DEFAULT NULL,
  `mailing_address` varchar(512) DEFAULT NULL,
  `daily_statement_email_address` int(11) DEFAULT '0',
  `monthly_statement_email_address` int(11) DEFAULT '0',
  `address1` varchar(512) DEFAULT NULL,
  `address2` varchar(512) DEFAULT NULL,
  `address3` varchar(512) DEFAULT NULL,
  `address4` varchar(512) DEFAULT NULL,
  `city` varchar(32) DEFAULT NULL,
  `state` varchar(32) DEFAULT NULL,
  `zip` varchar(32) DEFAULT NULL,
  `country` varchar(8) DEFAULT '',
  `partyid_type` int(11) DEFAULT NULL,
  `partyid` varchar(32) DEFAULT NULL,
  `party_country` varchar(8) DEFAULT '',
  `party_effective_date` date DEFAULT NULL,
  `party_expiration_date` date DEFAULT NULL,
  `photoid_type` int(11) DEFAULT NULL,
  `photoid` varchar(32) DEFAULT NULL,
  `photo_country` varchar(8) DEFAULT '',
  `photo_effective_date` date DEFAULT NULL,
  `photo_expiration_date` date DEFAULT NULL,
  `bank` varchar(32) DEFAULT NULL,
  `bank_account_id` varchar(32) DEFAULT NULL,
  `bank_account_name` varchar(32) DEFAULT NULL,
  `employment` varchar(32) DEFAULT NULL,
  `employer_name` varchar(128) DEFAULT '',
  `employer_address1` varchar(512) DEFAULT NULL,
  `employer_address2` varchar(512) DEFAULT NULL,
  `employer_address3` varchar(512) DEFAULT NULL,
  `employer_address4` varchar(512) DEFAULT NULL,
  `employer_city` varchar(32) DEFAULT NULL,
  `employer_state` varchar(32) DEFAULT NULL,
  `employer_zip` varchar(32) DEFAULT NULL,
  `employer_country` varchar(8) DEFAULT '',
  `employer_phone1` varchar(32) DEFAULT NULL,
  `employer_phone2` varchar(32) DEFAULT NULL,
  `employer_phone3` varchar(32) DEFAULT NULL,
  `is_government_official` char(1) DEFAULT 'N',
  `is_terrorist` char(1) DEFAULT 'N',
  `famaliy_income` int(11) DEFAULT '0',
  `famaliy_equity` int(11) DEFAULT '0',
  `risk_tolerance` int(11) DEFAULT '0',
  `invest_target` int(11) DEFAULT '0',
  `security_experience` int(11) DEFAULT '0',
  `fund_experience` int(11) DEFAULT '0',
  `forien_exchange_experience` int(11) DEFAULT '0',
  `fixed_income_experience` int(11) DEFAULT '0',
  `others_incom_experience` int(11) DEFAULT '0',
  `bos_uuid` varchar(32) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `insert_time` datetime DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `account_class` varchar(8) DEFAULT ''
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_profile_bak_20200521
-- ----------------------------
DROP TABLE IF EXISTS `account_profile_bak_20200521`;
CREATE TABLE `account_profile_bak_20200521` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `business_department` char(16) DEFAULT NULL,
  `department_trading_group` char(16) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `first_name` varchar(32) DEFAULT NULL,
  `middle_name` varchar(32) DEFAULT NULL,
  `last_name` varchar(32) DEFAULT NULL,
  `short_name` varchar(128) DEFAULT NULL,
  `birth_day` date DEFAULT NULL,
  `gender` varchar(1) DEFAULT NULL,
  `primary_joint` int(11) DEFAULT '0',
  `phone1` varchar(32) DEFAULT NULL,
  `phone2` varchar(32) DEFAULT NULL,
  `phone3` varchar(32) DEFAULT NULL,
  `email_address` varchar(64) DEFAULT NULL,
  `mailing_address` varchar(512) DEFAULT NULL,
  `daily_statement_email_address` int(11) DEFAULT '0',
  `monthly_statement_email_address` int(11) DEFAULT '0',
  `address1` varchar(512) DEFAULT NULL,
  `address2` varchar(512) DEFAULT NULL,
  `address3` varchar(512) DEFAULT NULL,
  `address4` varchar(512) DEFAULT NULL,
  `city` varchar(32) DEFAULT NULL,
  `state` varchar(32) DEFAULT NULL,
  `zip` varchar(32) DEFAULT NULL,
  `country` varchar(8) DEFAULT '',
  `partyid_type` int(11) DEFAULT NULL,
  `partyid` varchar(32) DEFAULT NULL,
  `party_country` varchar(8) DEFAULT '',
  `party_effective_date` date DEFAULT NULL,
  `party_expiration_date` date DEFAULT NULL,
  `photoid_type` int(11) DEFAULT NULL,
  `photoid` varchar(32) DEFAULT NULL,
  `photo_country` varchar(8) DEFAULT '',
  `photo_effective_date` date DEFAULT NULL,
  `photo_expiration_date` date DEFAULT NULL,
  `bank` varchar(32) DEFAULT NULL,
  `bank_account_id` varchar(32) DEFAULT NULL,
  `bank_account_name` varchar(32) DEFAULT NULL,
  `employment` varchar(32) DEFAULT NULL,
  `employer_name` varchar(32) DEFAULT NULL,
  `employer_address1` varchar(512) DEFAULT NULL,
  `employer_address2` varchar(512) DEFAULT NULL,
  `employer_address3` varchar(512) DEFAULT NULL,
  `employer_address4` varchar(512) DEFAULT NULL,
  `employer_city` varchar(32) DEFAULT NULL,
  `employer_state` varchar(32) DEFAULT NULL,
  `employer_zip` varchar(32) DEFAULT NULL,
  `employer_country` varchar(8) DEFAULT '',
  `employer_phone1` varchar(32) DEFAULT NULL,
  `employer_phone2` varchar(32) DEFAULT NULL,
  `employer_phone3` varchar(32) DEFAULT NULL,
  `is_government_official` char(1) DEFAULT 'N',
  `is_terrorist` char(1) DEFAULT 'N',
  `famaliy_income` int(11) DEFAULT '0',
  `famaliy_equity` int(11) DEFAULT '0',
  `risk_tolerance` int(11) DEFAULT '0',
  `invest_target` int(11) DEFAULT '0',
  `security_experience` int(11) DEFAULT '0',
  `fund_experience` int(11) DEFAULT '0',
  `forien_exchange_experience` int(11) DEFAULT '0',
  `fixed_income_experience` int(11) DEFAULT '0',
  `others_incom_experience` int(11) DEFAULT '0',
  `bos_uuid` varchar(32) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `insert_time` datetime DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `account_class` varchar(8) DEFAULT ''
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_trade
-- ----------------------------
DROP TABLE IF EXISTS `account_trade`;
CREATE TABLE `account_trade` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `trade_id` char(32) DEFAULT NULL,
  `business_department` char(16) DEFAULT NULL,
  `department_trading_group` char(16) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `list_market_id` int(11) DEFAULT NULL,
  `product_id` varchar(32) DEFAULT '',
  `product_description` varchar(255) DEFAULT NULL,
  `product_type` int(11) DEFAULT NULL,
  `product_sub_type` char(16) DEFAULT NULL,
  `quote_currency` char(3) DEFAULT NULL,
  `clearing_currency` char(3) DEFAULT NULL,
  `exchange_rate` decimal(30,10) DEFAULT NULL,
  `buy_sell` int(11) DEFAULT NULL,
  `quantity` decimal(21,6) DEFAULT '0.000000',
  `avg_price` decimal(21,6) DEFAULT '0.000000',
  `trade_amount` decimal(30,10) DEFAULT '0.0000000000',
  `net_amount` decimal(30,10) DEFAULT '0.0000000000',
  `open_close` int(11) DEFAULT NULL,
  `hedge_flag` int(11) DEFAULT NULL,
  `call_put` int(11) DEFAULT NULL,
  `strike_price` decimal(30,10) DEFAULT NULL,
  `contract_date` date DEFAULT NULL,
  `input_channel` int(11) DEFAULT NULL,
  `remark` text,
  `num_of_trades` int(11) DEFAULT NULL,
  `order_no` char(32) DEFAULT NULL,
  `order_date` date DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` char(16) DEFAULT NULL,
  `commission` decimal(30,10) DEFAULT '0.0000000000',
  `charges` decimal(30,10) DEFAULT '0.0000000000',
  `broker` varchar(16) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `status` varchar(16) DEFAULT 'Confirmed',
  `is_odd_lot` varchar(1) DEFAULT '',
  PRIMARY KEY (`id`),
  KEY `idx2` (`process_date`,`market_id`,`product_id`,`buy_sell`,`account_id`,`account_type`),
  KEY `idx1` (`trade_id`,`trade_date`,`market_id`),
  KEY `idx3` (`process_date`,`status`,`market_id`,`product_id`,`buy_sell`,`account_id`,`account_type`),
  KEY `idx4` (`settle_date`,`account_id`,`clearing_currency`),
  KEY `idx5` (`settle_date`,`account_id`,`market_id`,`product_id`)
) ENGINE=InnoDB AUTO_INCREMENT=5020722 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_trade_20200123
-- ----------------------------
DROP TABLE IF EXISTS `account_trade_20200123`;
CREATE TABLE `account_trade_20200123` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `trade_id` char(32) DEFAULT NULL,
  `business_department` char(16) DEFAULT NULL,
  `department_trading_group` char(16) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `list_market_id` int(11) DEFAULT NULL,
  `product_id` char(16) DEFAULT NULL,
  `product_description` varchar(255) DEFAULT NULL,
  `product_type` int(11) DEFAULT NULL,
  `product_sub_type` char(16) DEFAULT NULL,
  `quote_currency` char(3) DEFAULT NULL,
  `clearing_currency` char(3) DEFAULT NULL,
  `exchange_rate` decimal(30,10) DEFAULT NULL,
  `buy_sell` int(11) DEFAULT NULL,
  `quantity` decimal(21,6) DEFAULT '0.000000',
  `avg_price` decimal(21,6) DEFAULT '0.000000',
  `trade_amount` decimal(30,10) DEFAULT '0.0000000000',
  `net_amount` decimal(30,10) DEFAULT '0.0000000000',
  `open_close` int(11) DEFAULT NULL,
  `hedge_flag` int(11) DEFAULT NULL,
  `call_put` int(11) DEFAULT NULL,
  `strike_price` decimal(30,10) DEFAULT NULL,
  `contract_date` date DEFAULT NULL,
  `input_channel` int(11) DEFAULT NULL,
  `remark` text,
  `num_of_trades` int(11) DEFAULT NULL,
  `order_no` char(32) DEFAULT NULL,
  `order_date` date DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` char(16) DEFAULT NULL,
  `commission` decimal(30,10) DEFAULT '0.0000000000',
  `charges` decimal(30,10) DEFAULT '0.0000000000',
  `broker` varchar(16) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `status` varchar(16) DEFAULT 'Confirmed'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_trade_detail
-- ----------------------------
DROP TABLE IF EXISTS `account_trade_detail`;
CREATE TABLE `account_trade_detail` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `trade_id` char(32) DEFAULT NULL,
  `trade_exec_id` varchar(32) DEFAULT '',
  `order_date` date DEFAULT NULL,
  `order_no` char(32) DEFAULT NULL,
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `exec_time` datetime(3) DEFAULT NULL,
  `exec_no` char(128) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `exchange_ref_no` char(32) DEFAULT NULL,
  `exec_broker` char(16) DEFAULT NULL,
  `contra_broker` char(16) DEFAULT NULL,
  `exec_quantity` decimal(30,10) DEFAULT NULL,
  `exec_price` decimal(30,10) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` char(16) DEFAULT NULL,
  `commission` decimal(30,10) DEFAULT '0.0000000000',
  `charges` decimal(30,10) DEFAULT '0.0000000000',
  `num_of_trades` int(11) DEFAULT '0',
  `trade_amount` decimal(30,10) DEFAULT '0.0000000000',
  `net_amount` decimal(30,10) DEFAULT '0.0000000000',
  `is_odd_lot` varchar(1) DEFAULT '',
  PRIMARY KEY (`id`),
  KEY `indx_id` (`trade_id`,`trade_exec_id`)
) ENGINE=InnoDB AUTO_INCREMENT=9655055 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_type_custodian
-- ----------------------------
DROP TABLE IF EXISTS `account_type_custodian`;
CREATE TABLE `account_type_custodian` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `market_id` int(11) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`market_id`,`account_type`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for account_type_loan_limit
-- ----------------------------
DROP TABLE IF EXISTS `account_type_loan_limit`;
CREATE TABLE `account_type_loan_limit` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `account_type` int(11) DEFAULT NULL,
  `limit_code` varchar(16) DEFAULT NULL,
  `approve_limit` decimal(30,10) DEFAULT NULL,
  `reject_limit` decimal(30,10) DEFAULT NULL,
  `alert_limit` decimal(30,10) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `account_type` (`account_type`,`limit_code`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for ae_commission_rule
-- ----------------------------
DROP TABLE IF EXISTS `ae_commission_rule`;
CREATE TABLE `ae_commission_rule` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `ae_id` int(11) DEFAULT '0',
  `market_id` int(11) DEFAULT '0',
  `currency` int(11) DEFAULT '0',
  `formula_type` char(16) DEFAULT NULL,
  `formula_code` char(16) DEFAULT NULL,
  `sum_flag` int(11) DEFAULT '0',
  `update_user` char(16) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for ae_info
-- ----------------------------
DROP TABLE IF EXISTS `ae_info`;
CREATE TABLE `ae_info` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `ae_id` varchar(32) NOT NULL,
  `name` varchar(128) DEFAULT NULL,
  `phone` varchar(32) DEFAULT NULL,
  `remark` varchar(256) DEFAULT NULL,
  `insert_time` datetime DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `ae_id` (`ae_id`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for ati_index
-- ----------------------------
DROP TABLE IF EXISTS `ati_index`;
CREATE TABLE `ati_index` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `generate_date` date DEFAULT NULL,
  `cnt` int(11) DEFAULT '0',
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`generate_date`)
) ENGINE=InnoDB AUTO_INCREMENT=367 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for audit_trail
-- ----------------------------
DROP TABLE IF EXISTS `audit_trail`;
CREATE TABLE `audit_trail` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `action` varchar(10) DEFAULT NULL,
  `control_id` varchar(40) DEFAULT NULL,
  `control_key_value` varchar(80) DEFAULT NULL,
  `table_id` varchar(40) DEFAULT NULL,
  `table_key_value` varchar(80) DEFAULT NULL,
  `column_name` varchar(40) DEFAULT NULL,
  `old_value` varchar(512) DEFAULT NULL,
  `new_value` varchar(512) DEFAULT NULL,
  `update_user` varchar(36) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `record_id` varchar(36) DEFAULT NULL,
  `status` varchar(10) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`process_date`,`action`,`control_id`,`control_key_value`,`table_id`,`table_key_value`,`column_name`)
) ENGINE=InnoDB AUTO_INCREMENT=349561 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for auto_exchange
-- ----------------------------
DROP TABLE IF EXISTS `auto_exchange`;
CREATE TABLE `auto_exchange` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `debit_balance` decimal(30,10) DEFAULT '0.0000000000',
  `currency_out` int(11) DEFAULT NULL,
  `currency_in` int(11) DEFAULT NULL,
  `exchange_rate` decimal(30,10) DEFAULT '0.0000000000',
  `amount_out` decimal(30,10) DEFAULT '0.0000000000',
  `amount_in` decimal(30,10) DEFAULT '0.0000000000',
  `update_user` varchar(36) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`process_date`)
) ENGINE=InnoDB AUTO_INCREMENT=19534 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for avg_cal
-- ----------------------------
DROP TABLE IF EXISTS `avg_cal`;
CREATE TABLE `avg_cal` (
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `avg_price` decimal(30,10) DEFAULT NULL,
  KEY `idx` (`market_id`,`product_id`,`account_id`,`account_type`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for bat_cash_flow
-- ----------------------------
DROP TABLE IF EXISTS `bat_cash_flow`;
CREATE TABLE `bat_cash_flow` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` varchar(16) DEFAULT NULL,
  `currency` int(11) DEFAULT '0',
  `amount` decimal(21,6) DEFAULT NULL,
  `way` char(32) DEFAULT NULL,
  `purpose` int(11) DEFAULT NULL,
  `remark` char(128) DEFAULT NULL,
  `remark2` varchar(128) DEFAULT NULL,
  `pay_bank_id` varchar(32) DEFAULT NULL,
  `pay_check_no` char(16) DEFAULT NULL,
  `pay_bank_account_name` char(32) DEFAULT NULL,
  `pay_bank_account_id` char(32) DEFAULT NULL,
  `rec_bank_id` varchar(32) DEFAULT NULL,
  `rec_check_no` char(16) DEFAULT NULL,
  `rec_bank_account_name` char(32) DEFAULT NULL,
  `rec_bank_account_id` char(32) DEFAULT NULL,
  `gl_mapping_item_id` varchar(64) DEFAULT NULL,
  `reference` varchar(128) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=256 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for bat_product_flow
-- ----------------------------
DROP TABLE IF EXISTS `bat_product_flow`;
CREATE TABLE `bat_product_flow` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `account_id` varchar(16) DEFAULT '',
  `account_type` varchar(16) DEFAULT NULL,
  `market_id` int(11) DEFAULT '0',
  `product_id` varchar(16) DEFAULT '',
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT '',
  `custodian_account` varchar(16) DEFAULT '',
  `nominee_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price2` decimal(30,10) DEFAULT '0.0000000000',
  `remark` varchar(128) DEFAULT '',
  `update_user` varchar(32) DEFAULT '',
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=65536 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for bcan_aufm_info
-- ----------------------------
DROP TABLE IF EXISTS `bcan_aufm_info`;
CREATE TABLE `bcan_aufm_info` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `checked` int(11) DEFAULT '1' COMMENT '要生成到BCANAUFM文件中',
  `status` varchar(8) DEFAULT '' COMMENT '最新的BCANAURP的结果',
  `ttep_firm_id` varchar(5) NOT NULL,
  `ttep_description` varchar(256) DEFAULT NULL,
  `ttep_min_bcan` varchar(10) DEFAULT NULL COMMENT 'FIMG有一些无法处理的BCAN,用于过滤它们',
  `ttep_max_bcan` varchar(10) DEFAULT NULL COMMENT 'FIMG有一些无法处理的BCAN,用于过滤它们',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for bcan_cid
-- ----------------------------
DROP TABLE IF EXISTS `bcan_cid`;
CREATE TABLE `bcan_cid` (
  `account_id` varchar(16) NOT NULL DEFAULT '',
  `firm_id` varchar(5) NOT NULL,
  `bcan` varchar(10) NOT NULL,
  `status` varchar(8) DEFAULT NULL,
  `allot_time` datetime DEFAULT NULL COMMENT '分配BCAN码的时刻',
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  UNIQUE KEY `idx2` (`firm_id`,`bcan`),
  KEY `idx1` (`account_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for bcan_config
-- ----------------------------
DROP TABLE IF EXISTS `bcan_config`;
CREATE TABLE `bcan_config` (
  `field_key` varchar(256) NOT NULL,
  `field_value` varchar(512) NOT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`field_key`),
  KEY `idx1` (`field_key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for bcan_mapp_info
-- ----------------------------
DROP TABLE IF EXISTS `bcan_mapp_info`;
CREATE TABLE `bcan_mapp_info` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `checked` int(11) DEFAULT '1' COMMENT '要生成到MAPP文件中',
  `status` varchar(8) DEFAULT '' COMMENT '最新的FIMG的结果',
  `account_id` varchar(16) DEFAULT NULL,
  `record_type` varchar(1) DEFAULT NULL,
  `record_sn` varchar(11) DEFAULT NULL COMMENT '预留字段,可能永远不会被使用',
  `client_type` varchar(2) DEFAULT NULL,
  `ec_firm_id` varchar(5) DEFAULT NULL,
  `bcan` varchar(10) DEFAULT NULL,
  `number_oah` varchar(2) DEFAULT NULL,
  `english_fnamn` varchar(40) DEFAULT NULL,
  `english_lname` varchar(40) DEFAULT NULL,
  `english_lename` varchar(100) DEFAULT NULL,
  `chinese_name` varchar(40) DEFAULT NULL,
  `chinese_lename` varchar(120) DEFAULT NULL,
  `country_oi` varchar(3) DEFAULT NULL,
  `id_type` varchar(2) DEFAULT NULL,
  `id_number` varchar(40) DEFAULT NULL,
  `insert_user` varchar(32) DEFAULT NULL,
  `insert_time` datetime DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx1` (`account_id`),
  UNIQUE KEY `idx2` (`ec_firm_id`,`bcan`)
) ENGINE=InnoDB AUTO_INCREMENT=52574 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for bcan_mapp_resp
-- ----------------------------
DROP TABLE IF EXISTS `bcan_mapp_resp`;
CREATE TABLE `bcan_mapp_resp` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `account_id` varchar(16) DEFAULT NULL,
  `ec_firm_id` varchar(5) DEFAULT NULL,
  `bcan` varchar(10) DEFAULT NULL,
  `head_ssn` int(11) DEFAULT NULL,
  `record_sn` varchar(11) DEFAULT NULL,
  `mapp_time` datetime DEFAULT NULL,
  `resp_orsn` varchar(11) DEFAULT NULL,
  `resp_rcode` varchar(5) DEFAULT NULL,
  `resp_rtext` varchar(200) DEFAULT NULL,
  `resp_rfn` varchar(2) DEFAULT NULL,
  `resp_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx1` (`account_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for bcan_rslt_fimg
-- ----------------------------
DROP TABLE IF EXISTS `bcan_rslt_fimg`;
CREATE TABLE `bcan_rslt_fimg` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `account_id` varchar(16) DEFAULT NULL,
  `ec_firm_id` varchar(5) DEFAULT NULL,
  `bcan` varchar(10) DEFAULT NULL,
  `rslt_bcan` varchar(10) DEFAULT NULL,
  `rslt_ac` varchar(1) DEFAULT NULL,
  `rslt_rc` varchar(4) DEFAULT NULL,
  `rslt_rsnart` varchar(120) DEFAULT NULL,
  `rslt_time` datetime DEFAULT NULL,
  `fimg_rs` varchar(1) DEFAULT NULL,
  `fimg_bcan` varchar(10) DEFAULT NULL,
  `fimg_sfirm` varchar(5) DEFAULT NULL,
  `fimg_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx1` (`account_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for borrow_fee_flow
-- ----------------------------
DROP TABLE IF EXISTS `borrow_fee_flow`;
CREATE TABLE `borrow_fee_flow` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `process_date` date NOT NULL,
  `account_id` varchar(32) NOT NULL,
  `account_type` int(11) NOT NULL,
  `market_id` int(11) NOT NULL,
  `product_id` varchar(32) NOT NULL,
  `custodian_code` varchar(16) DEFAULT '',
  `custodian_account` varchar(16) DEFAULT '',
  `currency` int(11) NOT NULL,
  `quantity` decimal(20,10) NOT NULL,
  `borrow_fee_rate` decimal(20,10) NOT NULL,
  `borrow_fee` decimal(20,10) NOT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx1` (`process_date`,`account_id`,`account_type`,`market_id`,`product_id`,`currency`),
  KEY `idx2` (`process_date`,`market_id`,`product_id`,`account_id`,`account_type`,`custodian_code`,`custodian_account`)
) ENGINE=InnoDB AUTO_INCREMENT=2459 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for borrow_list
-- ----------------------------
DROP TABLE IF EXISTS `borrow_list`;
CREATE TABLE `borrow_list` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `process_date` date NOT NULL,
  `trade_date` date NOT NULL,
  `market_id` int(11) NOT NULL,
  `product_id` varchar(32) NOT NULL,
  `locate_fee` decimal(20,10) DEFAULT '0.0000000000' COMMENT '借券费用',
  `min_locate_fee` decimal(20,10) DEFAULT '0.0000000000' COMMENT '最低借券费用',
  `borrow_fee` decimal(20,10) DEFAULT '0.0000000000' COMMENT '融券利息',
  `update_user` varchar(256) DEFAULT NULL,
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx1` (`process_date`,`market_id`,`product_id`)
) ENGINE=InnoDB AUTO_INCREMENT=272254 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for borrow_request
-- ----------------------------
DROP TABLE IF EXISTS `borrow_request`;
CREATE TABLE `borrow_request` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `process_date` date NOT NULL,
  `trade_date` date NOT NULL,
  `account_id` varchar(32) NOT NULL,
  `market_id` int(11) NOT NULL,
  `product_id` varchar(32) NOT NULL,
  `apply_qty` decimal(20,10) DEFAULT '0.0000000000' COMMENT '借券申请数量',
  `approved_qty` decimal(20,10) DEFAULT '0.0000000000' COMMENT '借券批准数量',
  `apply_time` datetime DEFAULT NULL,
  `client_order_id` varchar(64) DEFAULT NULL COMMENT '外部系统的id',
  `locate_fee` decimal(20,10) DEFAULT '0.0000000000' COMMENT '借券费用',
  `update_user` varchar(256) DEFAULT NULL,
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx1` (`process_date`,`account_id`,`market_id`,`product_id`)
) ENGINE=InnoDB AUTO_INCREMENT=16314 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for broker
-- ----------------------------
DROP TABLE IF EXISTS `broker`;
CREATE TABLE `broker` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `broker` varchar(16) DEFAULT NULL COMMENT '券商ID',
  `broker_desc` varchar(64) DEFAULT NULL COMMENT '券商介绍',
  `contact_person` varchar(32) DEFAULT NULL COMMENT '联系人',
  `phone` varchar(32) DEFAULT NULL COMMENT '联系电话',
  `address` varchar(64) DEFAULT NULL COMMENT '联系地址',
  `email` varchar(64) DEFAULT NULL COMMENT '电子邮件地址',
  `fax` varchar(64) DEFAULT NULL COMMENT '传真',
  `remark` varchar(64) DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx1` (`broker`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for broker_market
-- ----------------------------
DROP TABLE IF EXISTS `broker_market`;
CREATE TABLE `broker_market` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `broker` varchar(16) DEFAULT NULL COMMENT '券商ID',
  `market_id` int(11) DEFAULT NULL COMMENT '支持的市场',
  `commission_formula_code` varchar(16) DEFAULT NULL COMMENT '上手佣金公式',
  `member_id` varchar(32) DEFAULT NULL COMMENT '会员号',
  `member_desc` varchar(64) DEFAULT NULL COMMENT '会员描述',
  `custodian_code` varchar(16) DEFAULT NULL COMMENT '默认托管商',
  `custodian_account` varchar(16) DEFAULT NULL COMMENT '默认托管商仓库',
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx1` (`broker`,`market_id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for buss_department
-- ----------------------------
DROP TABLE IF EXISTS `buss_department`;
CREATE TABLE `buss_department` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `buss_department_id` int(11) DEFAULT '0',
  `description` char(32) DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for cal3
-- ----------------------------
DROP TABLE IF EXISTS `cal3`;
CREATE TABLE `cal3` (
  `id` bigint(20) DEFAULT NULL,
  `charge` decimal(30,10) DEFAULT '0.0000000000',
  `CCY` int(11) DEFAULT '0',
  `QTY` decimal(21,6) DEFAULT NULL,
  `AMT` decimal(21,6) DEFAULT NULL,
  `AVGPRC` decimal(21,6) DEFAULT NULL,
  `BS` int(11) DEFAULT '0',
  `OP` int(11) DEFAULT '0',
  `InputWay` int(11) DEFAULT '0',
  `SettleFee` char(1) DEFAULT NULL,
  `StampFee` char(1) DEFAULT NULL,
  `LotSize` decimal(21,6) DEFAULT NULL,
  `Lot` decimal(21,6) DEFAULT NULL,
  `PT` char(16) DEFAULT NULL,
  `PST` char(16) DEFAULT NULL,
  `PriceFactor` decimal(21,6) DEFAULT NULL,
  `ContractSize` decimal(21,6) DEFAULT NULL,
  `ACCType` int(11) DEFAULT '0',
  `EXRate` decimal(21,6) DEFAULT NULL,
  `ProductClass` char(32) DEFAULT NULL,
  `TradeCnt` int(11) DEFAULT NULL,
  KEY `pk` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for calendar
-- ----------------------------
DROP TABLE IF EXISTS `calendar`;
CREATE TABLE `calendar` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `market_id` int(11) DEFAULT NULL,
  `calendar_day` date DEFAULT NULL,
  `holiday` varchar(1) DEFAULT NULL,
  `description` varchar(64) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` char(16) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`market_id`,`calendar_day`,`holiday`)
) ENGINE=InnoDB AUTO_INCREMENT=12100 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for cancel_cash_flow
-- ----------------------------
DROP TABLE IF EXISTS `cancel_cash_flow`;
CREATE TABLE `cancel_cash_flow` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` datetime DEFAULT NULL,
  `settle_date` datetime DEFAULT NULL,
  `trade_id` varchar(32) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `trade_amount` decimal(30,10) DEFAULT '0.0000000000',
  `settle_amount` decimal(30,10) DEFAULT '0.0000000000',
  `interest` decimal(30,10) DEFAULT '0.0000000000',
  `remark` varchar(128) DEFAULT NULL,
  `dividend_market_id` int(11) DEFAULT NULL,
  `dividend_product_id` varchar(16) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`process_date`,`settle_date`,`trade_id`,`account_id`,`account_type`,`currency`)
) ENGINE=InnoDB AUTO_INCREMENT=948 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for cancel_product_flow
-- ----------------------------
DROP TABLE IF EXISTS `cancel_product_flow`;
CREATE TABLE `cancel_product_flow` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` datetime DEFAULT NULL,
  `settle_date` datetime DEFAULT NULL,
  `trade_id` varchar(32) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `product_type` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `net_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `portfolio_fee` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `remark` varchar(128) DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`process_date`,`settle_date`,`trade_id`,`market_id`,`product_id`,`account_id`,`account_type`,`custodian_code`,`custodian_account`)
) ENGINE=InnoDB AUTO_INCREMENT=230 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for capital_account
-- ----------------------------
DROP TABLE IF EXISTS `capital_account`;
CREATE TABLE `capital_account` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `account_id` varchar(16) DEFAULT NULL,
  `password` varchar(32) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `auth_markets` varchar(16) DEFAULT NULL,
  `auth_currencies` varchar(16) DEFAULT NULL,
  `loan_limit` decimal(30,10) DEFAULT NULL,
  `client_group_code` varchar(8) DEFAULT NULL,
  `app_usable` decimal(30,10) DEFAULT NULL,
  `ae_id` varchar(32) DEFAULT NULL,
  `account_tag` varchar(16) DEFAULT NULL,
  `insert_time` datetime DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `us_jcfee_waive` char(1) DEFAULT 'N',
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx1` (`account_id`)
) ENGINE=InnoDB AUTO_INCREMENT=160310 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for capital_account20190920
-- ----------------------------
DROP TABLE IF EXISTS `capital_account20190920`;
CREATE TABLE `capital_account20190920` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `account_id` varchar(16) DEFAULT NULL,
  `password` varchar(32) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `auth_markets` varchar(16) DEFAULT NULL,
  `auth_currencies` varchar(16) DEFAULT NULL,
  `loan_limit` decimal(30,10) DEFAULT NULL,
  `client_group_code` varchar(8) DEFAULT NULL,
  `app_usable` decimal(30,10) DEFAULT NULL,
  `ae_id` varchar(32) DEFAULT NULL,
  `account_tag` varchar(16) DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx1` (`account_id`)
) ENGINE=InnoDB AUTO_INCREMENT=70198 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for capital_account_20200327
-- ----------------------------
DROP TABLE IF EXISTS `capital_account_20200327`;
CREATE TABLE `capital_account_20200327` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `account_id` varchar(16) DEFAULT NULL,
  `password` varchar(32) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `auth_markets` varchar(16) DEFAULT NULL,
  `auth_currencies` varchar(16) DEFAULT NULL,
  `loan_limit` decimal(30,10) DEFAULT NULL,
  `client_group_code` varchar(8) DEFAULT NULL,
  `app_usable` decimal(30,10) DEFAULT NULL,
  `ae_id` varchar(32) DEFAULT NULL,
  `account_tag` varchar(16) DEFAULT NULL,
  `insert_time` datetime DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `us_jcfee_waive` char(1) DEFAULT 'N'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for capital_account_20200521
-- ----------------------------
DROP TABLE IF EXISTS `capital_account_20200521`;
CREATE TABLE `capital_account_20200521` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `account_id` varchar(16) DEFAULT NULL,
  `password` varchar(32) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `auth_markets` varchar(16) DEFAULT NULL,
  `auth_currencies` varchar(16) DEFAULT NULL,
  `loan_limit` decimal(30,10) DEFAULT NULL,
  `client_group_code` varchar(8) DEFAULT NULL,
  `app_usable` decimal(30,10) DEFAULT NULL,
  `ae_id` varchar(32) DEFAULT NULL,
  `account_tag` varchar(16) DEFAULT NULL,
  `insert_time` datetime DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `us_jcfee_waive` char(1) DEFAULT 'N'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for cash_flow
-- ----------------------------
DROP TABLE IF EXISTS `cash_flow`;
CREATE TABLE `cash_flow` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `currency` int(11) DEFAULT '0',
  `balance` decimal(21,6) DEFAULT NULL,
  `amount` decimal(21,6) DEFAULT NULL,
  `way` int(11) DEFAULT '0',
  `purpose` int(11) DEFAULT NULL,
  `remark` char(128) DEFAULT NULL,
  `remark2` varchar(128) DEFAULT NULL,
  `pay_bank_id` varchar(32) DEFAULT NULL,
  `pay_check_no` char(16) DEFAULT NULL,
  `pay_bank_account_name` char(32) DEFAULT NULL,
  `pay_bank_account_id` char(32) DEFAULT NULL,
  `rec_bank_id` varchar(32) DEFAULT NULL,
  `rec_check_no` char(16) DEFAULT NULL,
  `rec_bank_account_name` char(32) DEFAULT NULL,
  `rec_bank_account_id` char(32) DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `dividend_market_id` int(11) DEFAULT NULL,
  `dividend_product_id` varchar(32) DEFAULT '',
  `gl_mapping_item_id` varchar(64) DEFAULT NULL,
  `reference` varchar(128) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `status` varchar(16) DEFAULT 'Confirmed',
  PRIMARY KEY (`id`),
  KEY `idx1` (`process_date`,`account_id`,`account_type`,`currency`,`remark`),
  KEY `idx2` (`process_date`,`status`,`account_id`,`account_type`,`currency`,`remark`),
  KEY `idx3` (`process_date`,`status`,`account_id`,`account_type`,`currency`,`remark`,`custodian_code`,`custodian_account`),
  KEY `idx_ssacp` (`settle_date`,`status`,`account_id`,`currency`,`process_date`)
) ENGINE=InnoDB AUTO_INCREMENT=8300644 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for cash_flow_20200506
-- ----------------------------
DROP TABLE IF EXISTS `cash_flow_20200506`;
CREATE TABLE `cash_flow_20200506` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `currency` int(11) DEFAULT '0',
  `balance` decimal(21,6) DEFAULT NULL,
  `amount` decimal(21,6) DEFAULT NULL,
  `way` int(11) DEFAULT '0',
  `purpose` int(11) DEFAULT NULL,
  `remark` char(128) DEFAULT NULL,
  `remark2` varchar(128) DEFAULT NULL,
  `pay_bank_id` varchar(32) DEFAULT NULL,
  `pay_check_no` char(16) DEFAULT NULL,
  `pay_bank_account_name` char(32) DEFAULT NULL,
  `pay_bank_account_id` char(32) DEFAULT NULL,
  `rec_bank_id` varchar(32) DEFAULT NULL,
  `rec_check_no` char(16) DEFAULT NULL,
  `rec_bank_account_name` char(32) DEFAULT NULL,
  `rec_bank_account_id` char(32) DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `dividend_market_id` int(11) DEFAULT NULL,
  `dividend_product_id` varchar(16) DEFAULT NULL,
  `gl_mapping_item_id` varchar(64) DEFAULT NULL,
  `reference` varchar(128) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `status` varchar(16) DEFAULT 'Confirmed'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for cash_flow_20200601
-- ----------------------------
DROP TABLE IF EXISTS `cash_flow_20200601`;
CREATE TABLE `cash_flow_20200601` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `currency` int(11) DEFAULT '0',
  `balance` decimal(21,6) DEFAULT NULL,
  `amount` decimal(21,6) DEFAULT NULL,
  `way` int(11) DEFAULT '0',
  `purpose` int(11) DEFAULT NULL,
  `remark` char(128) DEFAULT NULL,
  `remark2` varchar(128) DEFAULT NULL,
  `pay_bank_id` varchar(32) DEFAULT NULL,
  `pay_check_no` char(16) DEFAULT NULL,
  `pay_bank_account_name` char(32) DEFAULT NULL,
  `pay_bank_account_id` char(32) DEFAULT NULL,
  `rec_bank_id` varchar(32) DEFAULT NULL,
  `rec_check_no` char(16) DEFAULT NULL,
  `rec_bank_account_name` char(32) DEFAULT NULL,
  `rec_bank_account_id` char(32) DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `dividend_market_id` int(11) DEFAULT NULL,
  `dividend_product_id` varchar(16) DEFAULT NULL,
  `gl_mapping_item_id` varchar(64) DEFAULT NULL,
  `reference` varchar(128) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `status` varchar(16) DEFAULT 'Confirmed'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for cash_flow_bak_20191106
-- ----------------------------
DROP TABLE IF EXISTS `cash_flow_bak_20191106`;
CREATE TABLE `cash_flow_bak_20191106` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `currency` int(11) DEFAULT '0',
  `balance` decimal(21,6) DEFAULT NULL,
  `amount` decimal(21,6) DEFAULT NULL,
  `way` int(11) DEFAULT '0',
  `purpose` int(11) DEFAULT NULL,
  `remark` char(128) DEFAULT NULL,
  `remark2` varchar(128) DEFAULT NULL,
  `pay_bank_id` varchar(32) DEFAULT NULL,
  `pay_check_no` char(16) DEFAULT NULL,
  `pay_bank_account_name` char(32) DEFAULT NULL,
  `pay_bank_account_id` char(32) DEFAULT NULL,
  `rec_bank_id` varchar(32) DEFAULT NULL,
  `rec_check_no` char(16) DEFAULT NULL,
  `rec_bank_account_name` char(32) DEFAULT NULL,
  `rec_bank_account_id` char(32) DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `dividend_market_id` int(11) DEFAULT NULL,
  `dividend_product_id` varchar(16) DEFAULT NULL,
  `gl_mapping_item_id` varchar(64) DEFAULT NULL,
  `reference` varchar(128) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `status` varchar(16) DEFAULT 'Confirmed'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for cash_flow_bak_20200610
-- ----------------------------
DROP TABLE IF EXISTS `cash_flow_bak_20200610`;
CREATE TABLE `cash_flow_bak_20200610` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `currency` int(11) DEFAULT '0',
  `balance` decimal(21,6) DEFAULT NULL,
  `amount` decimal(21,6) DEFAULT NULL,
  `way` int(11) DEFAULT '0',
  `purpose` int(11) DEFAULT NULL,
  `remark` char(128) DEFAULT NULL,
  `remark2` varchar(128) DEFAULT NULL,
  `pay_bank_id` varchar(32) DEFAULT NULL,
  `pay_check_no` char(16) DEFAULT NULL,
  `pay_bank_account_name` char(32) DEFAULT NULL,
  `pay_bank_account_id` char(32) DEFAULT NULL,
  `rec_bank_id` varchar(32) DEFAULT NULL,
  `rec_check_no` char(16) DEFAULT NULL,
  `rec_bank_account_name` char(32) DEFAULT NULL,
  `rec_bank_account_id` char(32) DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `dividend_market_id` int(11) DEFAULT NULL,
  `dividend_product_id` varchar(16) DEFAULT NULL,
  `gl_mapping_item_id` varchar(64) DEFAULT NULL,
  `reference` varchar(128) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `status` varchar(16) DEFAULT 'Confirmed'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for cash_flow_cit
-- ----------------------------
DROP TABLE IF EXISTS `cash_flow_cit`;
CREATE TABLE `cash_flow_cit` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `currency` int(11) DEFAULT '0',
  `balance` decimal(21,6) DEFAULT NULL,
  `amount` decimal(21,6) DEFAULT NULL,
  `way` int(11) DEFAULT '0',
  `purpose` int(11) DEFAULT NULL,
  `remark` char(128) DEFAULT NULL,
  `remark2` varchar(128) DEFAULT NULL,
  `pay_bank_id` varchar(32) DEFAULT NULL,
  `pay_check_no` char(16) DEFAULT NULL,
  `pay_bank_account_name` char(32) DEFAULT NULL,
  `pay_bank_account_id` char(32) DEFAULT NULL,
  `rec_bank_id` varchar(32) DEFAULT NULL,
  `rec_check_no` char(16) DEFAULT NULL,
  `rec_bank_account_name` char(32) DEFAULT NULL,
  `rec_bank_account_id` char(32) DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `dividend_market_id` int(11) DEFAULT NULL,
  `dividend_product_id` varchar(32) DEFAULT '',
  `gl_mapping_item_id` varchar(64) DEFAULT NULL,
  `reference` varchar(128) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`process_date`,`account_id`,`account_type`,`currency`,`remark`)
) ENGINE=InnoDB AUTO_INCREMENT=5679 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for checkwarnings
-- ----------------------------
DROP TABLE IF EXISTS `checkwarnings`;
CREATE TABLE `checkwarnings` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `warn_type` int(11) DEFAULT '0',
  `file_name` char(32) DEFAULT NULL,
  `list_market_id` int(11) DEFAULT NULL,
  `product_id` char(32) DEFAULT NULL,
  `account_id` char(32) DEFAULT NULL,
  `remark` char(255) DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for corp_action
-- ----------------------------
DROP TABLE IF EXISTS `corp_action`;
CREATE TABLE `corp_action` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `event_id` varchar(128) DEFAULT NULL,
  `event_type` varchar(32) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `to_market_id` varchar(2) DEFAULT NULL,
  `product_id` varchar(32) DEFAULT '',
  `external_product_id` varchar(32) DEFAULT NULL,
  `description` varchar(256) DEFAULT NULL,
  `ex_date` date DEFAULT NULL,
  `register_date` date DEFAULT NULL,
  `bc_date_from` date DEFAULT NULL,
  `bc_date_to` date DEFAULT NULL,
  `pay_date` date DEFAULT NULL,
  `scrip_fee` varchar(1) DEFAULT NULL,
  `nominee` varchar(1) DEFAULT NULL,
  `announce_ccy` int(11) DEFAULT NULL,
  `dividend_ccy` int(11) DEFAULT NULL,
  `dividend_rate` decimal(30,10) DEFAULT NULL,
  `tax_rate` decimal(30,10) DEFAULT NULL,
  `net_dividend_rate` decimal(30,10) DEFAULT NULL,
  `base_ccy` int(11) DEFAULT NULL,
  `convert_ccy` int(11) DEFAULT NULL,
  `exchange_rate` decimal(30,10) DEFAULT NULL,
  `scrip_price` decimal(30,10) DEFAULT NULL,
  `to_product_id` varchar(32) DEFAULT '',
  `to_external_product_id` varchar(32) DEFAULT NULL,
  `ratio_from` decimal(30,10) DEFAULT NULL,
  `ratio_to` decimal(30,10) DEFAULT NULL,
  `optional` varchar(1) DEFAULT NULL,
  `m_default` varchar(1) DEFAULT NULL,
  `book_closed_date` datetime DEFAULT NULL,
  `book_closed` varchar(1) DEFAULT NULL,
  `posted_date` datetime DEFAULT NULL,
  `posted` varchar(1) DEFAULT NULL,
  `charge_id1` varchar(32) DEFAULT NULL,
  `charge_id2` varchar(32) DEFAULT NULL,
  `charge_id3` varchar(32) DEFAULT NULL,
  `charge_id4` varchar(32) DEFAULT NULL,
  `charge_id5` varchar(32) DEFAULT NULL,
  `subscribe_charge_id1` varchar(32) DEFAULT NULL,
  `subscribe_charge_id2` varchar(32) DEFAULT NULL,
  `elect_time_from` datetime DEFAULT NULL,
  `elect_time_to` datetime DEFAULT NULL,
  `on_subscription` varchar(1) DEFAULT NULL,
  `sub_time_from` datetime DEFAULT NULL,
  `sub_time_to` datetime DEFAULT NULL,
  `sub_ccy` int(11) DEFAULT NULL,
  `sub_price` decimal(30,10) DEFAULT NULL,
  `trade_time_from` datetime DEFAULT NULL,
  `trade_time_to` datetime DEFAULT NULL,
  `remark` varchar(64) DEFAULT NULL,
  `subscribe_charge_id3` varchar(32) DEFAULT NULL,
  `subscribe_charge_id4` varchar(32) DEFAULT NULL,
  `record_count` int(11) DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx1` (`event_id`)
) ENGINE=InnoDB AUTO_INCREMENT=34118 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for corp_action_detail
-- ----------------------------
DROP TABLE IF EXISTS `corp_action_detail`;
CREATE TABLE `corp_action_detail` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `event_id` varchar(128) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `product_id` varchar(32) DEFAULT '',
  `to_product_id` varchar(32) DEFAULT '',
  `bc_quantity` decimal(30,10) DEFAULT NULL,
  `non_nominee_quantity` decimal(30,10) DEFAULT NULL,
  `apply_quantity` decimal(30,10) DEFAULT NULL,
  `dividend_currency` int(11) DEFAULT NULL,
  `dividend_amount` decimal(30,10) DEFAULT NULL,
  `dividend_quantity` decimal(30,10) DEFAULT NULL,
  `charge1` decimal(30,10) DEFAULT NULL,
  `charge2` decimal(30,10) DEFAULT NULL,
  `charge3` decimal(30,10) DEFAULT NULL,
  `charge4` decimal(30,10) DEFAULT NULL,
  `charge5` decimal(30,10) DEFAULT NULL,
  `subscribe_charge1` decimal(30,10) DEFAULT NULL,
  `subscribe_charge2` decimal(30,10) DEFAULT NULL,
  `subscribe_charge3` decimal(30,10) DEFAULT NULL,
  `subscribe_charge4` decimal(30,10) DEFAULT NULL,
  `excercise_quantity` decimal(30,10) DEFAULT NULL,
  `excess_quantity` decimal(30,10) DEFAULT NULL,
  `alloted_excercise_quanitty` decimal(30,10) DEFAULT NULL,
  `alloted_excess_quantity` decimal(30,10) DEFAULT NULL,
  `refund_amount` decimal(30,10) DEFAULT NULL,
  `refund_excess_amount` decimal(30,10) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=251820 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for country
-- ----------------------------
DROP TABLE IF EXISTS `country`;
CREATE TABLE `country` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `country_id` varchar(8) DEFAULT '',
  `description` varchar(64) DEFAULT '',
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=250 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for csc_loan_rate
-- ----------------------------
DROP TABLE IF EXISTS `csc_loan_rate`;
CREATE TABLE `csc_loan_rate` (
  `product_id` varchar(16) DEFAULT NULL,
  `loan_rate` decimal(30,10) DEFAULT NULL,
  KEY `idx` (`product_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for csc_rate
-- ----------------------------
DROP TABLE IF EXISTS `csc_rate`;
CREATE TABLE `csc_rate` (
  `product_id` varchar(16) DEFAULT NULL,
  `rate` decimal(30,10) DEFAULT NULL,
  KEY `idx` (`product_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for currency
-- ----------------------------
DROP TABLE IF EXISTS `currency`;
CREATE TABLE `currency` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `currency` int(11) DEFAULT NULL,
  `currency_desc` varchar(32) DEFAULT NULL,
  `prime_rate` decimal(30,10) DEFAULT '0.0000000000',
  `saving_rate` decimal(30,10) DEFAULT '0.0000000000',
  `debit_formula_type` char(32) DEFAULT NULL,
  `debit_formula_code` char(50) DEFAULT NULL,
  `credit_formula_type` char(32) DEFAULT NULL,
  `credit_formula_code` char(50) DEFAULT NULL,
  `base` varchar(1) DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `exchange_rate` decimal(30,10) DEFAULT NULL,
  `exchange_from_priority` int(11) DEFAULT NULL,
  `exchange_to_priority` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`currency`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for currency_history
-- ----------------------------
DROP TABLE IF EXISTS `currency_history`;
CREATE TABLE `currency_history` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` datetime DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `currency_desc` varchar(32) DEFAULT NULL,
  `prime_rate` decimal(30,10) DEFAULT '0.0000000000',
  `saving_rate` decimal(30,10) DEFAULT '0.0000000000',
  `debit_formula_type` char(32) DEFAULT NULL,
  `debit_formula_code` char(50) DEFAULT NULL,
  `credit_formula_type` char(32) DEFAULT NULL,
  `credit_formula_code` char(50) DEFAULT NULL,
  `base` varchar(1) DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `exchange_rate` decimal(30,10) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`process_date`,`currency`)
) ENGINE=InnoDB AUTO_INCREMENT=2443 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for currency_ratio
-- ----------------------------
DROP TABLE IF EXISTS `currency_ratio`;
CREATE TABLE `currency_ratio` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `currency_from` int(11) DEFAULT '0',
  `currency_to` int(11) DEFAULT '0',
  `rate_molecular` decimal(30,10) DEFAULT '0.0000000000',
  `rate_denominator` decimal(30,10) DEFAULT '0.0000000000',
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`currency_from`,`currency_to`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for currency_ratio_history
-- ----------------------------
DROP TABLE IF EXISTS `currency_ratio_history`;
CREATE TABLE `currency_ratio_history` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` datetime DEFAULT NULL,
  `currency_from` int(11) DEFAULT '0',
  `currency_to` int(11) DEFAULT '0',
  `rate_molecular` decimal(30,10) DEFAULT '0.0000000000',
  `rate_denominator` decimal(30,10) DEFAULT '0.0000000000',
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`process_date`,`currency_from`,`currency_to`)
) ENGINE=InnoDB AUTO_INCREMENT=5965 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for custodian
-- ----------------------------
DROP TABLE IF EXISTS `custodian`;
CREATE TABLE `custodian` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_desc` varchar(32) DEFAULT NULL,
  `contact_person` varchar(32) DEFAULT NULL,
  `contact_phone` varchar(32) DEFAULT NULL,
  `contact_address` varchar(64) DEFAULT NULL,
  `remark` varchar(64) DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`custodian_code`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for custodian_account
-- ----------------------------
DROP TABLE IF EXISTS `custodian_account`;
CREATE TABLE `custodian_account` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `account_desc` varchar(32) DEFAULT NULL,
  `remark` varchar(64) DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`custodian_code`,`custodian_account`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for custodian_account_position
-- ----------------------------
DROP TABLE IF EXISTS `custodian_account_position`;
CREATE TABLE `custodian_account_position` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `market_value` decimal(30,10) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`market_id`,`product_id`,`custodian_code`,`custodian_account`),
  KEY `idx2` (`process_date`,`market_id`,`product_id`)
) ENGINE=InnoDB AUTO_INCREMENT=1307763 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for custodian_fee
-- ----------------------------
DROP TABLE IF EXISTS `custodian_fee`;
CREATE TABLE `custodian_fee` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `QTY` decimal(30,10) DEFAULT '0.0000000000',
  `LotSize` decimal(30,10) DEFAULT '0.0000000000',
  `formula_id` varchar(32) DEFAULT NULL,
  `charge` decimal(30,10) DEFAULT '0.0000000000',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for custodian_fee_rule
-- ----------------------------
DROP TABLE IF EXISTS `custodian_fee_rule`;
CREATE TABLE `custodian_fee_rule` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `market_id` int(11) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `formula_id` varchar(32) DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `updat_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `indx1` (`market_id`,`custodian_code`,`custodian_account`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for custodian_position_compare
-- ----------------------------
DROP TABLE IF EXISTS `custodian_position_compare`;
CREATE TABLE `custodian_position_compare` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `process_date` date NOT NULL DEFAULT '1900-01-01',
  `market_id` int(11) NOT NULL DEFAULT '0',
  `product_id` varchar(16) NOT NULL DEFAULT '',
  `description` char(32) DEFAULT NULL,
  `qty_ap` decimal(30,10) DEFAULT NULL,
  `qty_cap` decimal(30,10) DEFAULT NULL,
  `qty_delta` decimal(30,10) DEFAULT NULL,
  PRIMARY KEY (`process_date`,`market_id`,`product_id`),
  KEY `id` (`id`),
  KEY `idx1` (`process_date`),
  KEY `idx2` (`process_date`,`market_id`,`product_id`)
) ENGINE=InnoDB AUTO_INCREMENT=4611 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for daily_day_trade_counts
-- ----------------------------
DROP TABLE IF EXISTS `daily_day_trade_counts`;
CREATE TABLE `daily_day_trade_counts` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `market_id` int(11) DEFAULT NULL,
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `day_trade_count` int(11) DEFAULT '0',
  `update_time` datetime DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`market_id`,`trade_date`,`account_id`),
  KEY `idx2` (`market_id`,`process_date`,`account_id`)
) ENGINE=InnoDB AUTO_INCREMENT=23817 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for day_end_process
-- ----------------------------
DROP TABLE IF EXISTS `day_end_process`;
CREATE TABLE `day_end_process` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `operation` varchar(64) DEFAULT NULL,
  `skip` varchar(1) DEFAULT 'N',
  `is_show` varchar(1) DEFAULT 'Y',
  `status` varchar(16) DEFAULT 'ToDo',
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for day_trade_counts_summary
-- ----------------------------
DROP TABLE IF EXISTS `day_trade_counts_summary`;
CREATE TABLE `day_trade_counts_summary` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `t0` int(11) DEFAULT '0',
  `t1` int(11) DEFAULT '0',
  `t2` int(11) DEFAULT '0',
  `t3` int(11) DEFAULT '0',
  `t4` int(11) DEFAULT '0',
  `update_time` datetime DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`market_id`,`process_date`,`account_id`)
) ENGINE=InnoDB AUTO_INCREMENT=37108469 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for default_report_sub_item
-- ----------------------------
DROP TABLE IF EXISTS `default_report_sub_item`;
CREATE TABLE `default_report_sub_item` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `class` varchar(32) NOT NULL DEFAULT '',
  `item` varchar(32) NOT NULL DEFAULT '',
  `sub_item` varchar(32) NOT NULL DEFAULT '',
  PRIMARY KEY (`id`),
  UNIQUE KEY `class` (`class`,`item`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for dict
-- ----------------------------
DROP TABLE IF EXISTS `dict`;
CREATE TABLE `dict` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `class` varchar(32) DEFAULT NULL,
  `sub_class` varchar(32) DEFAULT NULL,
  `item` varchar(16) DEFAULT NULL,
  `value` varchar(64) DEFAULT NULL,
  `description` varchar(128) DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`class`,`sub_class`,`item`)
) ENGINE=InnoDB AUTO_INCREMENT=129 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for error_code_info
-- ----------------------------
DROP TABLE IF EXISTS `error_code_info`;
CREATE TABLE `error_code_info` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `error_code` int(11) NOT NULL,
  `error_enum` varchar(128) NOT NULL,
  `error_text` varchar(256) NOT NULL,
  `remark` varchar(256) NOT NULL,
  `op_user` varchar(32) DEFAULT NULL,
  `insert_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `error_code` (`error_code`),
  UNIQUE KEY `error_enum` (`error_enum`),
  KEY `error_code_2` (`error_code`,`error_enum`,`error_text`,`remark`)
) ENGINE=InnoDB AUTO_INCREMENT=19 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for exchange_trade
-- ----------------------------
DROP TABLE IF EXISTS `exchange_trade`;
CREATE TABLE `exchange_trade` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `trade_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `buy_sell` int(11) DEFAULT NULL,
  `exec_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `exec_price` decimal(30,10) DEFAULT '0.0000000000',
  `exec_broker` char(16) DEFAULT NULL,
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `product_desc` char(16) DEFAULT NULL,
  `exec_time` datetime(3) DEFAULT NULL,
  `contra_broker` char(16) DEFAULT NULL,
  `trade_type` char(1) DEFAULT NULL,
  `remark` char(128) DEFAULT NULL,
  `exchange_reference_no` char(18) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` char(16) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`trade_date`,`market_id`,`buy_sell`,`exchange_reference_no`)
) ENGINE=InnoDB AUTO_INCREMENT=2155179 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for export_file
-- ----------------------------
DROP TABLE IF EXISTS `export_file`;
CREATE TABLE `export_file` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `file_id` varchar(64) DEFAULT NULL,
  `file_description` varchar(64) DEFAULT NULL,
  `client_dest_path` varchar(64) DEFAULT NULL,
  `last_handle_time` datetime DEFAULT NULL,
  `path_setting` varchar(1) DEFAULT NULL,
  `is_show` varchar(1) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`file_id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for export_file_cnt
-- ----------------------------
DROP TABLE IF EXISTS `export_file_cnt`;
CREATE TABLE `export_file_cnt` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `gen_key` varchar(32) DEFAULT NULL,
  `cnt` int(11) DEFAULT '0',
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`process_date`,`gen_key`)
) ENGINE=InnoDB AUTO_INCREMENT=132 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for export_stamp_file
-- ----------------------------
DROP TABLE IF EXISTS `export_stamp_file`;
CREATE TABLE `export_stamp_file` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(256) DEFAULT NULL,
  `space1` varchar(16) DEFAULT NULL,
  `space2` varchar(16) DEFAULT NULL,
  `quantity` varchar(64) DEFAULT NULL,
  `space3` varchar(16) DEFAULT NULL,
  `space4` varchar(16) DEFAULT NULL,
  `table_list` varchar(16) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `id` (`id`,`table_list`)
) ENGINE=InnoDB AUTO_INCREMENT=80 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for formula
-- ----------------------------
DROP TABLE IF EXISTS `formula`;
CREATE TABLE `formula` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `formula_code` char(32) DEFAULT NULL,
  `formula_type` char(8) DEFAULT NULL,
  `formula_value` char(255) DEFAULT NULL,
  `description` char(128) DEFAULT NULL,
  `update_user` char(50) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`formula_type`,`formula_code`)
) ENGINE=InnoDB AUTO_INCREMENT=139 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for formula_param
-- ----------------------------
DROP TABLE IF EXISTS `formula_param`;
CREATE TABLE `formula_param` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `formula_type` char(32) DEFAULT NULL,
  `varaible` varchar(32) DEFAULT NULL,
  `variable_type` varchar(32) DEFAULT NULL,
  `description` char(32) DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for fund_purchase_redemption
-- ----------------------------
DROP TABLE IF EXISTS `fund_purchase_redemption`;
CREATE TABLE `fund_purchase_redemption` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` varchar(16) NOT NULL,
  `account_type` varchar(16) NOT NULL,
  `product_id` varchar(31) NOT NULL,
  `order_type` int(11) NOT NULL,
  `apply_qty` decimal(30,10) NOT NULL,
  `qty` decimal(30,10) NOT NULL,
  `price` decimal(30,10) NOT NULL,
  `amount` decimal(30,10) NOT NULL,
  `fee` decimal(30,10) NOT NULL DEFAULT '0.0000000000',
  `update_date` datetime DEFAULT NULL,
  `status` varchar(16) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=13300 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for fund_result
-- ----------------------------
DROP TABLE IF EXISTS `fund_result`;
CREATE TABLE `fund_result` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `product_id` varchar(31) NOT NULL,
  `order_type` int(11) NOT NULL,
  `qty` decimal(30,10) NOT NULL,
  `price` decimal(18,5) NOT NULL,
  `amount` decimal(18,5) NOT NULL,
  `fee` decimal(18,5) NOT NULL DEFAULT '0.00000',
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for future_close_position
-- ----------------------------
DROP TABLE IF EXISTS `future_close_position`;
CREATE TABLE `future_close_position` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `position_id` bigint(20) DEFAULT NULL,
  `trade_id` char(32) DEFAULT NULL,
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `order_no` char(128) DEFAULT NULL,
  `contra_order_no` char(128) DEFAULT NULL,
  `exec_no` char(128) DEFAULT NULL,
  `contra_exec_no` char(128) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `market_id` int(11) DEFAULT '0',
  `product_class` char(50) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `buy_sell` int(11) DEFAULT NULL,
  `currency` int(11) NOT NULL,
  `price` decimal(30,10) DEFAULT '0.0000000000',
  `open_price` decimal(30,10) DEFAULT '0.0000000000',
  `closed_qty` decimal(30,10) DEFAULT '0.0000000000',
  `profit_loss` decimal(30,10) DEFAULT '0.0000000000',
  `update_time` datetime DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`process_date`,`market_id`,`product_id`,`buy_sell`,`account_id`,`account_type`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for future_open_position
-- ----------------------------
DROP TABLE IF EXISTS `future_open_position`;
CREATE TABLE `future_open_position` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `trade_id` varchar(32) DEFAULT NULL,
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `order_no` char(50) DEFAULT NULL,
  `exec_no` char(64) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `market_id` int(11) DEFAULT '0',
  `product_class` char(50) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `buy_sell` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `price` decimal(30,10) DEFAULT '0.0000000000',
  `settle_price` decimal(30,10) DEFAULT '0.0000000000',
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `unclosed_qty` decimal(30,10) DEFAULT '0.0000000000',
  `profit_loss` decimal(30,10) DEFAULT '0.0000000000',
  `margin_amt` decimal(30,10) DEFAULT '0.0000000000',
  `closed` char(1) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`market_id`,`product_id`,`buy_sell`,`account_id`,`account_type`,`closed`),
  KEY `idx2` (`closed`,`market_id`,`process_date`)
) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for generate_cash_id
-- ----------------------------
DROP TABLE IF EXISTS `generate_cash_id`;
CREATE TABLE `generate_cash_id` (
  `process_date` date DEFAULT NULL,
  `generate_id` bigint(20) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for generate_exec_id
-- ----------------------------
DROP TABLE IF EXISTS `generate_exec_id`;
CREATE TABLE `generate_exec_id` (
  `trade_id` varchar(32) DEFAULT NULL,
  `id` int(11) DEFAULT NULL,
  KEY `idx1` (`trade_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for generate_id
-- ----------------------------
DROP TABLE IF EXISTS `generate_id`;
CREATE TABLE `generate_id` (
  `process_date` date DEFAULT NULL,
  `generate_id` bigint(20) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for groups
-- ----------------------------
DROP TABLE IF EXISTS `groups`;
CREATE TABLE `groups` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `buss_department_id` int(11) DEFAULT '0',
  `group_id` int(11) DEFAULT '0',
  `description` char(32) DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for hk_loan_rate
-- ----------------------------
DROP TABLE IF EXISTS `hk_loan_rate`;
CREATE TABLE `hk_loan_rate` (
  `product_id` varchar(16) DEFAULT NULL,
  `loan_rate` decimal(30,10) DEFAULT NULL,
  KEY `idx` (`product_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for hk_rate
-- ----------------------------
DROP TABLE IF EXISTS `hk_rate`;
CREATE TABLE `hk_rate` (
  `product_id` varchar(16) DEFAULT NULL,
  `rate` decimal(30,10) DEFAULT NULL,
  KEY `idx` (`product_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for import_account_trade_detail
-- ----------------------------
DROP TABLE IF EXISTS `import_account_trade_detail`;
CREATE TABLE `import_account_trade_detail` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `trade_id` char(32) DEFAULT NULL,
  `trade_exec_id` char(32) DEFAULT NULL,
  `process_date` date DEFAULT NULL,
  `order_no` char(32) DEFAULT NULL,
  `order_date` date DEFAULT NULL,
  `order_time` datetime(3) DEFAULT NULL,
  `business_department` char(16) DEFAULT NULL,
  `department_trading_group` char(16) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT '0',
  `list_market_id` int(11) DEFAULT '0',
  `product_type` int(11) DEFAULT '0',
  `product_sub_type` varchar(16) DEFAULT NULL,
  `product_id` char(16) DEFAULT NULL,
  `product_description` varchar(255) DEFAULT NULL,
  `quote_currency` char(3) DEFAULT NULL,
  `clearing_currency` char(3) DEFAULT NULL,
  `exchange_rate` decimal(30,10) DEFAULT NULL,
  `buy_sell` int(11) DEFAULT NULL,
  `order_price` decimal(30,10) DEFAULT NULL,
  `order_quantity` decimal(30,10) DEFAULT NULL,
  `trade_quantity` decimal(30,10) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `open_close` int(11) DEFAULT NULL,
  `hedge_flag` int(11) DEFAULT NULL,
  `call_put` int(11) DEFAULT NULL,
  `strike_price` decimal(30,10) DEFAULT NULL,
  `contract_date` date DEFAULT NULL,
  `input_channel` int(11) DEFAULT NULL,
  `remark` text,
  `exec_time` datetime(3) DEFAULT NULL,
  `exec_no` char(128) DEFAULT NULL,
  `exchange_ref_no` char(32) DEFAULT NULL,
  `exec_broker` char(16) DEFAULT NULL,
  `contra_broker` char(16) DEFAULT NULL,
  `exec_quantity` decimal(30,10) DEFAULT NULL,
  `exec_price` decimal(30,10) DEFAULT NULL,
  `code` int(11) DEFAULT '0',
  `mark` char(16) DEFAULT NULL,
  `num_of_trades` int(11) DEFAULT '0',
  `trade_amount` decimal(30,10) DEFAULT '0.0000000000',
  `net_amount` decimal(30,10) DEFAULT '0.0000000000',
  `update_time` varchar(30) DEFAULT NULL,
  `update_user` char(16) DEFAULT NULL,
  `ConfirmStatus` char(16) DEFAULT NULL,
  `broker` varchar(16) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `is_odd_lot` varchar(1) DEFAULT 'N',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for import_account_trade_detail_bak_20191202
-- ----------------------------
DROP TABLE IF EXISTS `import_account_trade_detail_bak_20191202`;
CREATE TABLE `import_account_trade_detail_bak_20191202` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `trade_id` char(32) DEFAULT NULL,
  `trade_exec_id` char(32) DEFAULT NULL,
  `process_date` date DEFAULT NULL,
  `order_no` char(32) DEFAULT NULL,
  `order_date` date DEFAULT NULL,
  `order_time` datetime(3) DEFAULT NULL,
  `business_department` char(16) DEFAULT NULL,
  `department_trading_group` char(16) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT '0',
  `list_market_id` int(11) DEFAULT '0',
  `product_type` int(11) DEFAULT '0',
  `product_sub_type` varchar(16) DEFAULT NULL,
  `product_id` char(16) DEFAULT NULL,
  `product_description` varchar(255) DEFAULT NULL,
  `quote_currency` char(3) DEFAULT NULL,
  `clearing_currency` char(3) DEFAULT NULL,
  `exchange_rate` decimal(30,10) DEFAULT NULL,
  `buy_sell` int(11) DEFAULT NULL,
  `order_price` decimal(30,10) DEFAULT NULL,
  `order_quantity` decimal(30,10) DEFAULT NULL,
  `trade_quantity` decimal(30,10) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `open_close` int(11) DEFAULT NULL,
  `hedge_flag` int(11) DEFAULT NULL,
  `call_put` int(11) DEFAULT NULL,
  `strike_price` decimal(30,10) DEFAULT NULL,
  `contract_date` date DEFAULT NULL,
  `input_channel` int(11) DEFAULT NULL,
  `remark` text,
  `exec_time` datetime(3) DEFAULT NULL,
  `exec_no` char(128) DEFAULT NULL,
  `exchange_ref_no` char(32) DEFAULT NULL,
  `exec_broker` char(16) DEFAULT NULL,
  `contra_broker` char(16) DEFAULT NULL,
  `exec_quantity` decimal(30,10) DEFAULT NULL,
  `exec_price` decimal(30,10) DEFAULT NULL,
  `code` int(11) DEFAULT '0',
  `mark` char(16) DEFAULT NULL,
  `num_of_trades` int(11) DEFAULT '0',
  `trade_amount` decimal(30,10) DEFAULT '0.0000000000',
  `net_amount` decimal(30,10) DEFAULT '0.0000000000',
  `update_time` varchar(30) DEFAULT NULL,
  `update_user` char(16) DEFAULT NULL,
  `ConfirmStatus` char(16) DEFAULT NULL,
  `broker` varchar(16) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for import_account_trade_detail_bak_20200811
-- ----------------------------
DROP TABLE IF EXISTS `import_account_trade_detail_bak_20200811`;
CREATE TABLE `import_account_trade_detail_bak_20200811` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `trade_id` char(32) DEFAULT NULL,
  `trade_exec_id` char(32) DEFAULT NULL,
  `process_date` date DEFAULT NULL,
  `order_no` char(32) DEFAULT NULL,
  `order_date` date DEFAULT NULL,
  `order_time` datetime(3) DEFAULT NULL,
  `business_department` char(16) DEFAULT NULL,
  `department_trading_group` char(16) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT '0',
  `list_market_id` int(11) DEFAULT '0',
  `product_type` int(11) DEFAULT '0',
  `product_sub_type` varchar(16) DEFAULT NULL,
  `product_id` char(16) DEFAULT NULL,
  `product_description` varchar(255) DEFAULT NULL,
  `quote_currency` char(3) DEFAULT NULL,
  `clearing_currency` char(3) DEFAULT NULL,
  `exchange_rate` decimal(30,10) DEFAULT NULL,
  `buy_sell` int(11) DEFAULT NULL,
  `order_price` decimal(30,10) DEFAULT NULL,
  `order_quantity` decimal(30,10) DEFAULT NULL,
  `trade_quantity` decimal(30,10) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `open_close` int(11) DEFAULT NULL,
  `hedge_flag` int(11) DEFAULT NULL,
  `call_put` int(11) DEFAULT NULL,
  `strike_price` decimal(30,10) DEFAULT NULL,
  `contract_date` date DEFAULT NULL,
  `input_channel` int(11) DEFAULT NULL,
  `remark` text,
  `exec_time` datetime(3) DEFAULT NULL,
  `exec_no` char(128) DEFAULT NULL,
  `exchange_ref_no` char(32) DEFAULT NULL,
  `exec_broker` char(16) DEFAULT NULL,
  `contra_broker` char(16) DEFAULT NULL,
  `exec_quantity` decimal(30,10) DEFAULT NULL,
  `exec_price` decimal(30,10) DEFAULT NULL,
  `code` int(11) DEFAULT '0',
  `mark` char(16) DEFAULT NULL,
  `num_of_trades` int(11) DEFAULT '0',
  `trade_amount` decimal(30,10) DEFAULT '0.0000000000',
  `net_amount` decimal(30,10) DEFAULT '0.0000000000',
  `update_time` varchar(30) DEFAULT NULL,
  `update_user` char(16) DEFAULT NULL,
  `ConfirmStatus` char(16) DEFAULT NULL,
  `broker` varchar(16) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `is_odd_lot` varchar(1) DEFAULT 'N'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for import_exchange_trade
-- ----------------------------
DROP TABLE IF EXISTS `import_exchange_trade`;
CREATE TABLE `import_exchange_trade` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `trade_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `buy_sell` int(11) DEFAULT NULL,
  `exec_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `exec_price` decimal(30,10) DEFAULT '0.0000000000',
  `exec_broker` char(16) DEFAULT NULL,
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `product_desc` char(16) DEFAULT NULL,
  `exec_time` datetime(3) DEFAULT NULL,
  `contra_broker` char(16) DEFAULT NULL,
  `trade_type` char(1) DEFAULT NULL,
  `remark` char(128) DEFAULT NULL,
  `exchange_reference_no` char(18) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` char(16) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`trade_date`,`market_id`,`buy_sell`,`exchange_reference_no`)
) ENGINE=InnoDB AUTO_INCREMENT=4096 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for market
-- ----------------------------
DROP TABLE IF EXISTS `market`;
CREATE TABLE `market` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `market_id` int(11) DEFAULT NULL,
  `market_desc` varchar(64) DEFAULT NULL,
  `market_settle_days` int(11) DEFAULT NULL,
  `market_settle_type` int(11) DEFAULT NULL,
  `loan_ratio` decimal(30,10) DEFAULT NULL,
  `loan_limit` decimal(30,10) DEFAULT NULL,
  `total_loan_limit` decimal(30,10) DEFAULT NULL,
  `quote_currency` int(11) DEFAULT NULL,
  `clearing_currency` int(11) DEFAULT NULL,
  `1t` date DEFAULT NULL,
  `t0` date DEFAULT NULL,
  `t1` date DEFAULT NULL,
  `t2` date DEFAULT NULL,
  `time_zone` int(11) DEFAULT NULL,
  `group_by_order` varchar(1) DEFAULT 'N',
  `group_by_price` varchar(1) DEFAULT 'N',
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `member_id` varchar(16) DEFAULT NULL,
  `broker_seat_number` varchar(16) DEFAULT NULL,
  `broker` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`market_id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for market_account_charge_rule
-- ----------------------------
DROP TABLE IF EXISTS `market_account_charge_rule`;
CREATE TABLE `market_account_charge_rule` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `market_id` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT '0',
  `charge_code` char(52) DEFAULT NULL,
  `waive` char(1) DEFAULT '1',
  `formula_code` varchar(32) DEFAULT NULL,
  `formula_type` varchar(32) DEFAULT NULL,
  `description` char(128) DEFAULT NULL,
  `sum_flag` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4103 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for market_charge_rule
-- ----------------------------
DROP TABLE IF EXISTS `market_charge_rule`;
CREATE TABLE `market_charge_rule` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `market_id` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT '0',
  `charge_code` varchar(52) DEFAULT NULL,
  `waive` char(1) DEFAULT '1',
  `formula_code` varchar(32) NOT NULL DEFAULT '',
  `formula_type` varchar(16) DEFAULT NULL,
  `description` char(128) DEFAULT NULL,
  `sum_flag` int(11) DEFAULT NULL,
  `posted_method` int(11) DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`market_id`,`formula_type`,`sum_flag`),
  KEY `idx2` (`market_id`,`charge_code`)
) ENGINE=InnoDB AUTO_INCREMENT=91 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for market_commission_rule
-- ----------------------------
DROP TABLE IF EXISTS `market_commission_rule`;
CREATE TABLE `market_commission_rule` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `market_id` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT '0',
  `formula_type` char(16) DEFAULT NULL,
  `formula_code` char(16) DEFAULT NULL,
  `sum_flag` int(11) DEFAULT '0',
  `update_user` char(16) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for market_corp_action
-- ----------------------------
DROP TABLE IF EXISTS `market_corp_action`;
CREATE TABLE `market_corp_action` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `market` int(11) DEFAULT NULL,
  `event_type` varchar(32) DEFAULT NULL,
  `charge_id1` varchar(32) DEFAULT NULL,
  `charge_id2` varchar(32) DEFAULT NULL,
  `charge_id3` varchar(32) DEFAULT NULL,
  `charge_id4` varchar(32) DEFAULT NULL,
  `charge_id5` varchar(32) DEFAULT NULL,
  `waive_id1` varchar(1) DEFAULT NULL,
  `waive_id2` varchar(1) DEFAULT NULL,
  `waive_id3` varchar(1) DEFAULT NULL,
  `waive_id4` varchar(1) DEFAULT NULL,
  `waive_id5` varchar(1) DEFAULT NULL,
  `remove_original_quantity` varchar(1) DEFAULT NULL,
  `convert_bal` varchar(1) DEFAULT NULL,
  `subscribe_charge_id1` varchar(32) DEFAULT NULL,
  `subscribe_charge_id2` varchar(32) DEFAULT NULL,
  `subscribe_charge_id3` varchar(32) DEFAULT NULL,
  `subscribe_charge_id4` varchar(32) DEFAULT NULL,
  `refund_charge_id1` varchar(32) DEFAULT NULL,
  `refund_charge_id2` varchar(32) DEFAULT NULL,
  `refund_charge_id3` varchar(32) DEFAULT NULL,
  `refund_charge_id4` varchar(32) DEFAULT NULL,
  `status` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=49 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for market_corpaction
-- ----------------------------
DROP TABLE IF EXISTS `market_corpaction`;
CREATE TABLE `market_corpaction` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `corpaction_id` varchar(64) DEFAULT NULL,
  `external_id` varchar(64) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `product_desc` varchar(32) DEFAULT NULL,
  `X_date` datetime DEFAULT NULL,
  `BC_date` datetime DEFAULT NULL,
  `pay_date` datetime DEFAULT NULL,
  `scrip_fee` char(1) DEFAULT NULL,
  `closed` char(1) DEFAULT NULL,
  `from_elect_date` datetime DEFAULT NULL,
  `to_elect_date` datetime DEFAULT NULL,
  `deadline_date` datetime DEFAULT NULL,
  `optional` char(1) DEFAULT NULL,
  `default_option` char(1) DEFAULT NULL,
  `event_type` varchar(40) DEFAULT NULL,
  `dividend_ccy` char(3) DEFAULT NULL,
  `dividend_rate` decimal(30,10) DEFAULT NULL,
  `net_dividend_rate` decimal(30,10) DEFAULT NULL,
  `from_product_id` varchar(16) DEFAULT NULL,
  `conv_product_id` varchar(16) DEFAULT NULL,
  `from_ratio` decimal(30,10) DEFAULT NULL,
  `to_ratio` decimal(30,10) DEFAULT NULL,
  `remark` varchar(255) DEFAULT NULL,
  `reinvest_price` decimal(30,10) DEFAULT NULL,
  `reinvest_ccy` char(5) DEFAULT NULL,
  `exchange_rate` decimal(30,10) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` char(64) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for market_corpaction_charge_rule
-- ----------------------------
DROP TABLE IF EXISTS `market_corpaction_charge_rule`;
CREATE TABLE `market_corpaction_charge_rule` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `market_id` int(11) DEFAULT NULL,
  `event_type` varchar(32) DEFAULT NULL,
  `charge_id` varchar(16) DEFAULT NULL,
  `waive` varchar(1) DEFAULT NULL,
  `charge_desc` varchar(64) DEFAULT NULL,
  `update_user` varchar(16) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for market_corpaction_type
-- ----------------------------
DROP TABLE IF EXISTS `market_corpaction_type`;
CREATE TABLE `market_corpaction_type` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `market_id` int(11) DEFAULT NULL,
  `event_type` varchar(32) DEFAULT NULL,
  `evnet_desc` varchar(64) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_userc` char(32) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for market_corpaction_type_charge
-- ----------------------------
DROP TABLE IF EXISTS `market_corpaction_type_charge`;
CREATE TABLE `market_corpaction_type_charge` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `market_id` int(11) DEFAULT NULL,
  `event_type` varchar(32) DEFAULT NULL,
  `charge_code` varchar(16) DEFAULT NULL,
  `waive` char(1) DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for market_product_charge_rule
-- ----------------------------
DROP TABLE IF EXISTS `market_product_charge_rule`;
CREATE TABLE `market_product_charge_rule` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `charge_code` char(32) DEFAULT NULL,
  `market_id` char(8) DEFAULT NULL,
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT '0',
  `waive` char(1) DEFAULT '1',
  `formula_type` char(32) DEFAULT NULL,
  `formula_code` char(32) DEFAULT NULL,
  `description` char(128) DEFAULT NULL,
  `sum_flag` int(11) DEFAULT '0',
  `posted_method` int(11) DEFAULT '0',
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for market_product_mapping
-- ----------------------------
DROP TABLE IF EXISTS `market_product_mapping`;
CREATE TABLE `market_product_mapping` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `mapping_code` varchar(16) DEFAULT NULL,
  `market_id` varchar(32) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `to_product_id` varchar(16) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`mapping_code`,`market_id`,`product_id`),
  KEY `idx2` (`mapping_code`,`market_id`,`to_product_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2316 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for menus
-- ----------------------------
DROP TABLE IF EXISTS `menus`;
CREATE TABLE `menus` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(32) DEFAULT NULL,
  `level` int(11) DEFAULT NULL,
  `final` varchar(1) DEFAULT NULL,
  `module_path` varchar(128) DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `parent` int(11) DEFAULT NULL,
  `order_no` int(11) DEFAULT NULL,
  `split` varchar(1) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=410001 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for official_product_closeprice
-- ----------------------------
DROP TABLE IF EXISTS `official_product_closeprice`;
CREATE TABLE `official_product_closeprice` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `trade_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `closing_price` decimal(30,10) DEFAULT NULL,
  `status` varchar(1) DEFAULT NULL,
  `update_user` varchar(16) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`trade_date`,`market_id`,`product_id`),
  KEY `idx2` (`market_id`,`product_id`)
) ENGINE=InnoDB AUTO_INCREMENT=8429752 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for operation_record
-- ----------------------------
DROP TABLE IF EXISTS `operation_record`;
CREATE TABLE `operation_record` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `user_id` varchar(32) DEFAULT NULL,
  `ip` varchar(64) DEFAULT NULL,
  `action` varchar(32) DEFAULT NULL,
  `detail` text,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for org_ipo_app
-- ----------------------------
DROP TABLE IF EXISTS `org_ipo_app`;
CREATE TABLE `org_ipo_app` (
  `account_id` varchar(16) DEFAULT NULL,
  `quantity` int(11) DEFAULT NULL,
  `phoneid` varchar(32) DEFAULT NULL,
  KEY `idx1` (`account_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for procedure_version
-- ----------------------------
DROP TABLE IF EXISTS `procedure_version`;
CREATE TABLE `procedure_version` (
  `name` varchar(64) DEFAULT NULL,
  `version` varchar(32) DEFAULT NULL,
  `creat_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for product
-- ----------------------------
DROP TABLE IF EXISTS `product`;
CREATE TABLE `product` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `list_market_id` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT NULL,
  `product_sub_type` varchar(16) DEFAULT NULL,
  `external_code` varchar(32) DEFAULT NULL,
  `product_class` char(16) DEFAULT NULL,
  `product_id` varchar(32) DEFAULT NULL,
  `product_description` varchar(255) DEFAULT NULL,
  `lot_size` decimal(21,6) DEFAULT '0.000000',
  `status` int(11) DEFAULT NULL,
  `contract_size` decimal(21,6) DEFAULT '0.000000',
  `quote_currency` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `price_factor` decimal(21,6) DEFAULT '0.000000',
  `par_value` decimal(21,6) DEFAULT '0.000000',
  `coupon` decimal(21,6) DEFAULT '0.000000',
  `listing_date` date DEFAULT NULL,
  `last_trading_date` date DEFAULT NULL,
  `exercise_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `underlying_list_market` char(16) DEFAULT NULL,
  `underlying_product_id` varchar(32) DEFAULT '',
  `strike_price` decimal(21,6) DEFAULT '0.000000',
  `call_put` char(1) DEFAULT NULL,
  `entitlement_ratio` decimal(21,6) DEFAULT '0.000000',
  `call_price` decimal(21,6) DEFAULT '0.000000',
  `settle_days` int(11) DEFAULT NULL,
  `settle_type` int(11) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` varchar(64) DEFAULT NULL,
  `key1` varchar(32) DEFAULT NULL,
  `value1` varchar(64) DEFAULT NULL,
  `key2` varchar(32) DEFAULT NULL,
  `value2` varchar(64) DEFAULT NULL,
  `key3` varchar(32) DEFAULT NULL,
  `value3` varchar(64) DEFAULT NULL,
  `key4` varchar(32) DEFAULT NULL,
  `value4` varchar(64) DEFAULT NULL,
  `key5` varchar(32) DEFAULT NULL,
  `value5` varchar(64) DEFAULT NULL,
  `loan_ratio` decimal(30,10) DEFAULT NULL,
  `last_active_date` date DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`list_market_id`,`product_id`,`product_type`),
  KEY `idx2` (`list_market_id`,`product_id`)
) ENGINE=InnoDB AUTO_INCREMENT=1802768 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for product_bak
-- ----------------------------
DROP TABLE IF EXISTS `product_bak`;
CREATE TABLE `product_bak` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `list_market_id` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT NULL,
  `product_sub_type` varchar(16) DEFAULT NULL,
  `external_code` varchar(32) DEFAULT NULL,
  `product_class` char(16) DEFAULT NULL,
  `product_id` char(16) DEFAULT NULL,
  `product_description` varchar(255) DEFAULT NULL,
  `lot_size` decimal(21,6) DEFAULT '0.000000',
  `status` int(11) DEFAULT NULL,
  `contract_size` decimal(21,6) DEFAULT '0.000000',
  `quote_currency` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `price_factor` decimal(21,6) DEFAULT '0.000000',
  `par_value` decimal(21,6) DEFAULT '0.000000',
  `coupon` decimal(21,6) DEFAULT '0.000000',
  `listing_date` date DEFAULT NULL,
  `last_trading_date` date DEFAULT NULL,
  `exercise_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `underlying_list_market` char(16) DEFAULT NULL,
  `underlying_product_id` char(16) DEFAULT NULL,
  `strike_price` decimal(21,6) DEFAULT '0.000000',
  `call_put` char(1) DEFAULT NULL,
  `entitlement_ratio` decimal(21,6) DEFAULT '0.000000',
  `call_price` decimal(21,6) DEFAULT '0.000000',
  `settle_days` int(11) DEFAULT NULL,
  `settle_type` int(11) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` varchar(64) DEFAULT NULL,
  `key1` varchar(32) DEFAULT NULL,
  `value1` varchar(64) DEFAULT NULL,
  `key2` varchar(32) DEFAULT NULL,
  `value2` varchar(64) DEFAULT NULL,
  `key3` varchar(32) DEFAULT NULL,
  `value3` varchar(64) DEFAULT NULL,
  `key4` varchar(32) DEFAULT NULL,
  `value4` varchar(64) DEFAULT NULL,
  `key5` varchar(32) DEFAULT NULL,
  `value5` varchar(64) DEFAULT NULL,
  `loan_ratio` decimal(30,10) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`list_market_id`,`product_id`,`product_type`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for product_class_future_margin
-- ----------------------------
DROP TABLE IF EXISTS `product_class_future_margin`;
CREATE TABLE `product_class_future_margin` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `trade_date` date DEFAULT NULL,
  `product_class` char(16) DEFAULT NULL,
  `market_id` int(11) DEFAULT '0',
  `exchange_initial_margin` decimal(30,10) DEFAULT '0.0000000000',
  `exchange_maint_margin` decimal(30,10) DEFAULT '0.0000000000',
  `exchange_initial_rate` decimal(30,10) DEFAULT '0.0000000000',
  `exchange_maint_rate` decimal(30,10) DEFAULT '0.0000000000',
  `company_initial_margin` decimal(30,10) DEFAULT '0.0000000000',
  `company_maint_margin` decimal(30,10) DEFAULT '0.0000000000',
  `company_initial_rate` decimal(30,10) DEFAULT '0.0000000000',
  `company_maint_rate` decimal(30,10) DEFAULT '0.0000000000',
  `floating_model` int(11) DEFAULT '0',
  `update_time` datetime DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`product_class`),
  KEY `idx2` (`trade_date`,`market_id`,`product_class`)
) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for product_flow
-- ----------------------------
DROP TABLE IF EXISTS `product_flow`;
CREATE TABLE `product_flow` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(32) DEFAULT '',
  `balance` decimal(30,10) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `nominee_quantity` decimal(30,10) DEFAULT NULL,
  `avg_price` decimal(30,10) DEFAULT NULL,
  `avg_price2` decimal(30,10) DEFAULT NULL,
  `purpose` int(11) DEFAULT NULL,
  `remark` varchar(128) DEFAULT NULL,
  `update_user` varchar(16) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `status` varchar(16) DEFAULT 'Confirmed',
  PRIMARY KEY (`id`),
  KEY `idx1` (`account_id`,`account_type`,`market_id`,`product_id`),
  KEY `idx3` (`settle_date`,`status`,`purpose`,`market_id`,`product_id`,`account_id`,`account_type`,`custodian_code`,`custodian_account`),
  KEY `idx4` (`process_date`,`status`,`account_id`,`product_id`),
  KEY `idx2` (`settle_date`,`process_date`,`market_id`,`product_id`,`account_id`,`account_type`,`custodian_code`,`custodian_account`)
) ENGINE=InnoDB AUTO_INCREMENT=3974198 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for product_flow_20200601
-- ----------------------------
DROP TABLE IF EXISTS `product_flow_20200601`;
CREATE TABLE `product_flow_20200601` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `balance` decimal(30,10) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `nominee_quantity` decimal(30,10) DEFAULT NULL,
  `avg_price` decimal(30,10) DEFAULT NULL,
  `avg_price2` decimal(30,10) DEFAULT NULL,
  `purpose` int(11) DEFAULT NULL,
  `remark` varchar(128) DEFAULT NULL,
  `update_user` varchar(16) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `status` varchar(16) DEFAULT 'Confirmed'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for product_flow_20200903
-- ----------------------------
DROP TABLE IF EXISTS `product_flow_20200903`;
CREATE TABLE `product_flow_20200903` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `balance` decimal(30,10) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `nominee_quantity` decimal(30,10) DEFAULT NULL,
  `avg_price` decimal(30,10) DEFAULT NULL,
  `avg_price2` decimal(30,10) DEFAULT NULL,
  `purpose` int(11) DEFAULT NULL,
  `remark` varchar(128) DEFAULT NULL,
  `update_user` varchar(16) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `status` varchar(16) DEFAULT 'Confirmed'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for product_flow_bak_20191202
-- ----------------------------
DROP TABLE IF EXISTS `product_flow_bak_20191202`;
CREATE TABLE `product_flow_bak_20191202` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `balance` decimal(30,10) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `nominee_quantity` decimal(30,10) DEFAULT NULL,
  `avg_price` decimal(30,10) DEFAULT NULL,
  `avg_price2` decimal(30,10) DEFAULT NULL,
  `purpose` int(11) DEFAULT NULL,
  `remark` varchar(128) DEFAULT NULL,
  `update_user` varchar(16) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `status` varchar(16) DEFAULT 'Confirmed'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for product_flow_bak_20200610
-- ----------------------------
DROP TABLE IF EXISTS `product_flow_bak_20200610`;
CREATE TABLE `product_flow_bak_20200610` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `balance` decimal(30,10) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `nominee_quantity` decimal(30,10) DEFAULT NULL,
  `avg_price` decimal(30,10) DEFAULT NULL,
  `avg_price2` decimal(30,10) DEFAULT NULL,
  `purpose` int(11) DEFAULT NULL,
  `remark` varchar(128) DEFAULT NULL,
  `update_user` varchar(16) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `status` varchar(16) DEFAULT 'Confirmed'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for product_flow_uco
-- ----------------------------
DROP TABLE IF EXISTS `product_flow_uco`;
CREATE TABLE `product_flow_uco` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `balance` decimal(30,10) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `nominee_quantity` decimal(30,10) DEFAULT NULL,
  `avg_price` decimal(30,10) DEFAULT NULL,
  `avg_price2` decimal(30,10) DEFAULT NULL,
  `purpose` int(11) DEFAULT NULL,
  `remark` varchar(128) DEFAULT NULL,
  `update_user` varchar(16) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `status` varchar(16) DEFAULT 'Confirmed'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for product_future_margin
-- ----------------------------
DROP TABLE IF EXISTS `product_future_margin`;
CREATE TABLE `product_future_margin` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `trade_date` date DEFAULT NULL,
  `product_class` char(16) DEFAULT NULL,
  `market_id` int(11) DEFAULT '0',
  `product_id` char(32) DEFAULT NULL,
  `exchange_initial_margin` decimal(30,10) DEFAULT NULL,
  `exchange_maint_margin` decimal(30,10) DEFAULT NULL,
  `exchange_initial_rate` decimal(30,10) DEFAULT '0.0000000000',
  `exchange_maint_rate` decimal(30,10) DEFAULT '0.0000000000',
  `company_initial_margin` decimal(30,10) DEFAULT NULL,
  `company_maint_margin` decimal(30,10) DEFAULT NULL,
  `company_initial_rate` decimal(30,10) DEFAULT '0.0000000000',
  `company_maint_rate` decimal(30,10) DEFAULT '0.0000000000',
  `floating_model` int(11) DEFAULT '0',
  `update_time` datetime DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`trade_date`,`market_id`,`product_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for product_ipo_announcement
-- ----------------------------
DROP TABLE IF EXISTS `product_ipo_announcement`;
CREATE TABLE `product_ipo_announcement` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `ipo_id` char(64) DEFAULT NULL,
  `list_market_id` int(11) DEFAULT '0',
  `product_id` varchar(32) DEFAULT '',
  `product_name` char(255) DEFAULT NULL,
  `currency` int(11) DEFAULT '0',
  `start_time` datetime DEFAULT NULL,
  `close_time` datetime DEFAULT NULL,
  `margin_start_time` datetime DEFAULT NULL,
  `margin_close_time` datetime DEFAULT NULL,
  `balance_frozen_start_time` datetime DEFAULT NULL,
  `balance_frozen_close_time` datetime DEFAULT NULL,
  `max_loan_ratio` decimal(30,10) DEFAULT '0.0000000000',
  `max_loan_amount` decimal(30,10) DEFAULT '0.0000000000',
  `interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `interest_day` int(11) DEFAULT NULL,
  `min_apply_amount` decimal(30,10) DEFAULT '0.0000000000',
  `max_apply_amount` decimal(30,10) DEFAULT '0.0000000000',
  `charge_rate` decimal(30,10) DEFAULT '0.0000000000',
  `charge` decimal(30,10) DEFAULT '0.0000000000',
  `loan_charge_rate` decimal(30,10) DEFAULT '0.0000000000',
  `loan_charge` decimal(30,10) DEFAULT '0.0000000000',
  `official_close_time` datetime DEFAULT NULL,
  `allot_date` date DEFAULT NULL,
  `listing_date` date DEFAULT NULL,
  `issue_price` decimal(30,10) DEFAULT '0.0000000000',
  `min_issue_price` decimal(30,10) DEFAULT '0.0000000000',
  `max_issue_price` decimal(30,10) DEFAULT '0.0000000000',
  `issue_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `url1` char(128) DEFAULT NULL,
  `url2` char(128) DEFAULT NULL,
  `url3` char(128) DEFAULT NULL,
  `url4` char(128) DEFAULT NULL,
  `allow_web_e_ipo` varchar(1) DEFAULT 'Y',
  `allow_web_cancel` varchar(1) DEFAULT 'N',
  `remark` text,
  `app_posted` varchar(1) DEFAULT NULL,
  `app_posted_time` datetime DEFAULT NULL,
  `result_posted` varchar(1) DEFAULT NULL,
  `result_posted_time` datetime DEFAULT NULL,
  `refund_posted` varchar(1) DEFAULT NULL,
  `refund_posted_time` datetime DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` varchar(32) DEFAULT NULL,
  `apply_quantity` int(11) DEFAULT '0',
  `trading_fee_rate` decimal(30,10) DEFAULT '0.0000000000',
  `trading_fee_standard` decimal(30,10) DEFAULT '0.0000000000',
  `pla_loan_ratio` decimal(30,10) DEFAULT '0.0000000000',
  `is_cross_trade` varchar(1) DEFAULT 'N',
  `settle_date` date DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`ipo_id`,`list_market_id`,`product_id`)
) ENGINE=InnoDB AUTO_INCREMENT=443 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for product_ipo_app
-- ----------------------------
DROP TABLE IF EXISTS `product_ipo_app`;
CREATE TABLE `product_ipo_app` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `ipo_id` char(64) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `list_market_id` int(11) DEFAULT '0',
  `product_id` varchar(32) DEFAULT '',
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `amount` decimal(30,10) DEFAULT '0.0000000000',
  `currency` int(11) DEFAULT '0',
  `loan_ratio` decimal(30,10) DEFAULT '0.0000000000',
  `loan_amount` decimal(30,10) DEFAULT '0.0000000000',
  `interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `interest` decimal(30,10) DEFAULT '0.0000000000',
  `charge` decimal(30,10) DEFAULT '0.0000000000',
  `loan_charge` decimal(30,10) DEFAULT '0.0000000000',
  `allot_qty` decimal(31,10) DEFAULT '0.0000000000',
  `allot_price` decimal(31,10) DEFAULT '0.0000000000',
  `refund_amount` decimal(31,10) DEFAULT '0.0000000000',
  `remark` char(255) DEFAULT NULL,
  `created_time` datetime(3) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `app_posted` varchar(1) DEFAULT 'N',
  `app_posted_time` datetime DEFAULT NULL,
  `result_posted` varchar(1) DEFAULT 'N',
  `result_posted_time` datetime DEFAULT NULL,
  `refund_posted` varchar(1) DEFAULT 'N',
  `refund_posted_time` datetime DEFAULT NULL,
  `sub_status` int(1) DEFAULT '1',
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx2` (`ipo_id`,`account_id`),
  KEY `idx1` (`ipo_id`,`account_id`,`account_type`,`list_market_id`,`product_id`)
) ENGINE=InnoDB AUTO_INCREMENT=13367349 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for product_ipo_app_20191211
-- ----------------------------
DROP TABLE IF EXISTS `product_ipo_app_20191211`;
CREATE TABLE `product_ipo_app_20191211` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `ipo_id` char(64) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `list_market_id` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `amount` decimal(30,10) DEFAULT '0.0000000000',
  `currency` int(11) DEFAULT '0',
  `loan_ratio` decimal(30,10) DEFAULT '0.0000000000',
  `loan_amount` decimal(30,10) DEFAULT '0.0000000000',
  `interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `interest` decimal(30,10) DEFAULT '0.0000000000',
  `charge` decimal(30,10) DEFAULT '0.0000000000',
  `loan_charge` decimal(30,10) DEFAULT '0.0000000000',
  `allot_qty` decimal(31,10) DEFAULT '0.0000000000',
  `allot_price` decimal(31,10) DEFAULT '0.0000000000',
  `refund_amount` decimal(31,10) DEFAULT '0.0000000000',
  `remark` char(255) DEFAULT NULL,
  `created_time` datetime(3) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `app_posted` varchar(1) DEFAULT 'N',
  `app_posted_time` datetime DEFAULT NULL,
  `result_posted` varchar(1) DEFAULT 'N',
  `result_posted_time` datetime DEFAULT NULL,
  `refund_posted` varchar(1) DEFAULT 'N',
  `refund_posted_time` datetime DEFAULT NULL,
  `sub_status` int(1) DEFAULT '1'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for product_ipo_app_bak_20191204
-- ----------------------------
DROP TABLE IF EXISTS `product_ipo_app_bak_20191204`;
CREATE TABLE `product_ipo_app_bak_20191204` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `ipo_id` char(64) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `list_market_id` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `amount` decimal(30,10) DEFAULT '0.0000000000',
  `currency` int(11) DEFAULT '0',
  `loan_ratio` decimal(30,10) DEFAULT '0.0000000000',
  `loan_amount` decimal(30,10) DEFAULT '0.0000000000',
  `interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `interest` decimal(30,10) DEFAULT '0.0000000000',
  `charge` decimal(30,10) DEFAULT '0.0000000000',
  `loan_charge` decimal(30,10) DEFAULT '0.0000000000',
  `allot_qty` decimal(31,10) DEFAULT '0.0000000000',
  `allot_price` decimal(31,10) DEFAULT '0.0000000000',
  `refund_amount` decimal(31,10) DEFAULT '0.0000000000',
  `remark` char(255) DEFAULT NULL,
  `created_time` datetime(3) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for product_ipo_qty
-- ----------------------------
DROP TABLE IF EXISTS `product_ipo_qty`;
CREATE TABLE `product_ipo_qty` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `ipo_id` char(64) DEFAULT NULL,
  `qty` decimal(30,10) DEFAULT NULL,
  `currency` int(11) DEFAULT '0',
  `amount` decimal(30,10) DEFAULT '0.0000000000',
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`ipo_id`)
) ENGINE=InnoDB AUTO_INCREMENT=54635275 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for product_market_data
-- ----------------------------
DROP TABLE IF EXISTS `product_market_data`;
CREATE TABLE `product_market_data` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `trade_date` date DEFAULT NULL,
  `list_market_id` int(11) DEFAULT NULL,
  `product_class` varchar(16) DEFAULT NULL,
  `product_type` int(11) DEFAULT NULL,
  `product_id` varchar(32) DEFAULT NULL,
  `product_description` varchar(255) DEFAULT NULL,
  `closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `last_closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `settle_price` decimal(30,10) DEFAULT '0.0000000000',
  `last_settle_price` decimal(30,10) DEFAULT '0.0000000000',
  `openning_price` decimal(30,10) DEFAULT '0.0000000000',
  `latest_price` decimal(30,10) DEFAULT '0.0000000000',
  `status` int(11) DEFAULT '0',
  `update_user` varchar(64) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `process_date` date DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `index2` (`trade_date`,`list_market_id`,`product_id`),
  KEY `idx3` (`process_date`,`list_market_id`,`product_id`)
) ENGINE=InnoDB AUTO_INCREMENT=331156765 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for produmarket_product_mappingct_flow
-- ----------------------------
DROP TABLE IF EXISTS `produmarket_product_mappingct_flow`;
CREATE TABLE `produmarket_product_mappingct_flow` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `mapping_code` varchar(32) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `to_market_id` int(11) DEFAULT NULL,
  `to_product_id` varchar(16) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for report_config
-- ----------------------------
DROP TABLE IF EXISTS `report_config`;
CREATE TABLE `report_config` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `report_id` varchar(64) NOT NULL,
  `report_description` varchar(64) DEFAULT NULL,
  `export_it` varchar(1) DEFAULT 'Y',
  `client_dest_path` varchar(255) DEFAULT NULL,
  `detail_params` varchar(255) DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `report_id` (`report_id`)
) ENGINE=InnoDB AUTO_INCREMENT=44 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for report_sub_item
-- ----------------------------
DROP TABLE IF EXISTS `report_sub_item`;
CREATE TABLE `report_sub_item` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `report_id` varchar(64) DEFAULT '',
  `class` varchar(32) NOT NULL DEFAULT '',
  `item` varchar(32) NOT NULL DEFAULT '',
  `sub_item` varchar(32) NOT NULL DEFAULT '',
  PRIMARY KEY (`id`),
  UNIQUE KEY `class` (`class`,`item`,`sub_item`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for scm_margin_balance_all
-- ----------------------------
DROP TABLE IF EXISTS `scm_margin_balance_all`;
CREATE TABLE `scm_margin_balance_all` (
  `MARGIN_BALANCE_ALL_ID` int(11) NOT NULL AUTO_INCREMENT,
  `FILENAME` varchar(50) DEFAULT NULL,
  `CALCULATION_DATE` date DEFAULT NULL,
  `ACCOUNT_ID` varchar(20) NOT NULL,
  `OFFICE` varchar(2) NOT NULL,
  `ACCOUNT_REG_CLASS_ID` varchar(50) NOT NULL,
  `BALANCE_TYPE` varchar(10) NOT NULL,
  `NATIVE_CURRENCY_ID` varchar(60) NOT NULL,
  `LOCAL_CURRENCY_ID` varchar(60) NOT NULL,
  `EQUITY` decimal(20,10) DEFAULT '0.0000000000',
  `LONG_MARKET` decimal(20,10) DEFAULT '0.0000000000',
  `SHORT_MARKET` decimal(20,10) DEFAULT '0.0000000000',
  `OPTION_LONG_MARKET` decimal(20,10) DEFAULT '0.0000000000',
  `OPTION_SHORT_MARKET` decimal(20,10) DEFAULT '0.0000000000',
  `DEBIT` decimal(20,10) DEFAULT '0.0000000000',
  `CREDIT` decimal(20,10) DEFAULT '0.0000000000',
  `LIQUIDATION_VALUE` decimal(20,10) DEFAULT '0.0000000000',
  `BUYING_POWER` decimal(20,10) DEFAULT '0.0000000000',
  `SMA` decimal(20,10) DEFAULT '0.0000000000',
  `SMA_ADJUST` decimal(20,10) DEFAULT '0.0000000000',
  `INITIAL_REQUIREMENT` decimal(20,10) DEFAULT '0.0000000000',
  `INITIAL_CALL` decimal(20,10) DEFAULT '0.0000000000',
  `INITIAL_EXCESS` decimal(20,10) DEFAULT '0.0000000000',
  `INITIAL_CALL_OPEN` decimal(20,10) DEFAULT '0.0000000000',
  `INITIAL_CALL_ABATED` decimal(20,10) DEFAULT '0.0000000000',
  `INITIAL_CALL_ADJUST` decimal(20,10) DEFAULT '0.0000000000',
  `MAINTENANCE_REQUIREMENT` decimal(20,10) DEFAULT '0.0000000000',
  `MAINTENANCE_CALL` decimal(20,10) DEFAULT '0.0000000000',
  `MAINTENANCE_EXCESS` decimal(20,10) DEFAULT '0.0000000000',
  `MAINTENANCE_CALL_OPEN` decimal(20,10) DEFAULT '0.0000000000',
  `MAINTENANCE_CALL_ABATED` decimal(20,10) DEFAULT '0.0000000000',
  `MAINTENANCE_CALL_ADJUST` decimal(20,10) DEFAULT '0.0000000000',
  `HOUSE_REQUIREMENT` decimal(20,10) DEFAULT '0.0000000000',
  `HOUSE_CALL` decimal(20,10) DEFAULT '0.0000000000',
  `HOUSE_EXCESS` decimal(20,10) DEFAULT '0.0000000000',
  `HOUSE_CALL_OPEN` decimal(20,10) DEFAULT '0.0000000000',
  `HOUSE_CALL_ABATED` decimal(20,10) DEFAULT '0.0000000000',
  `HOUSE_CALL_ADJUST` decimal(20,10) DEFAULT '0.0000000000',
  `PERCENT_EQUITY` decimal(20,10) DEFAULT '0.0000000000',
  `DAY_TRADE_COUNT` decimal(20,10) DEFAULT '0.0000000000',
  `EXCHANGE_RATE` decimal(20,10) DEFAULT '0.0000000000',
  `CASH_CALL` decimal(20,10) DEFAULT '0.0000000000',
  `SETTLED_CREDIT` decimal(20,10) DEFAULT '0.0000000000',
  `SETTLED_DEBIT` decimal(20,10) DEFAULT '0.0000000000',
  `SMA_OPEN` decimal(20,10) DEFAULT '0.0000000000',
  `SMA_RELEASE` decimal(20,10) DEFAULT '0.0000000000',
  `SMA_REQUIRE` decimal(20,10) DEFAULT '0.0000000000',
  `DAYTRADE_REQUIREMENT` decimal(20,10) DEFAULT '0.0000000000',
  `DAYTRADE_CALL` decimal(20,10) DEFAULT '0.0000000000',
  `DAYTRADE_EXCESS` decimal(20,10) DEFAULT '0.0000000000',
  `DAYTRADE_CALL_OPEN` decimal(20,10) DEFAULT '0.0000000000',
  `DAYTRADE_CALL_ABATED` decimal(20,10) DEFAULT '0.0000000000',
  `DAYTRADE_CALL_ADJUST` decimal(20,10) DEFAULT '0.0000000000',
  `SMA_CASH_APPLIED` decimal(20,10) DEFAULT '0.0000000000',
  `GUARANTEE_USED` decimal(20,10) DEFAULT '0.0000000000',
  `GUARANTEE_GIVEN` decimal(20,10) DEFAULT '0.0000000000',
  `DAYTRADE_PROFIT_LOSS` decimal(20,10) DEFAULT '0.0000000000',
  `OVERNIGHT_BUYING_POWER` decimal(20,10) DEFAULT '0.0000000000',
  `CASH_AVAILABLE` decimal(20,10) DEFAULT '0.0000000000',
  `OPTION_REQUIREMENT` decimal(20,10) DEFAULT '0.0000000000',
  `CASH_LIKE_VALUE` decimal(20,10) DEFAULT '0.0000000000',
  `TOTAL_MONEY_MARKET` decimal(20,10) DEFAULT '0.0000000000',
  `PENDING_DISBURSEMENT` decimal(20,10) DEFAULT '0.0000000000',
  `TOMORROWS_OPENING_USABLE_SD_BL` decimal(20,10) DEFAULT '0.0000000000',
  KEY `MARGIN_BALANCE_ALL_ID` (`MARGIN_BALANCE_ALL_ID`),
  KEY `idx1` (`CALCULATION_DATE`,`ACCOUNT_ID`,`LOCAL_CURRENCY_ID`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for server_file
-- ----------------------------
DROP TABLE IF EXISTS `server_file`;
CREATE TABLE `server_file` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `market_id` int(11) DEFAULT '-1',
  `file_id` char(88) DEFAULT NULL,
  `server_path` char(88) DEFAULT NULL,
  `file_name` char(88) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for settled_position
-- ----------------------------
DROP TABLE IF EXISTS `settled_position`;
CREATE TABLE `settled_position` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `market_id` int(11) DEFAULT '0',
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT '0',
  `quantity` decimal(30,10) DEFAULT NULL,
  `amount` decimal(30,10) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx` (`process_date`,`market_id`,`product_type`),
  KEY `idx1` (`settle_date`,`account_id`,`market_id`,`product_id`)
) ENGINE=InnoDB AUTO_INCREMENT=1392899 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for settled_position_20200511
-- ----------------------------
DROP TABLE IF EXISTS `settled_position_20200511`;
CREATE TABLE `settled_position_20200511` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `market_id` int(11) DEFAULT '0',
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT '0',
  `quantity` decimal(30,10) DEFAULT NULL,
  `amount` decimal(30,10) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for settled_position_bak
-- ----------------------------
DROP TABLE IF EXISTS `settled_position_bak`;
CREATE TABLE `settled_position_bak` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `market_id` int(11) DEFAULT '0',
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT '0',
  `quantity` decimal(30,10) DEFAULT NULL,
  `amount` decimal(30,10) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for sys_info
-- ----------------------------
DROP TABLE IF EXISTS `sys_info`;
CREATE TABLE `sys_info` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `last_buss_date` date DEFAULT NULL,
  `buss_date` date DEFAULT NULL,
  `sys_status` int(11) DEFAULT NULL,
  `time_zone` int(11) DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `backup_path` varchar(256) DEFAULT NULL,
  `day_end_performed` varchar(1) DEFAULT 'N',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for system_control
-- ----------------------------
DROP TABLE IF EXISTS `system_control`;
CREATE TABLE `system_control` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `c_key` varchar(32) DEFAULT NULL,
  `c_value` varchar(32) DEFAULT NULL,
  `c_param1` varchar(32) DEFAULT NULL,
  `c_param2` varchar(32) DEFAULT NULL,
  `c_param3` varchar(320) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for t_acc
-- ----------------------------
DROP TABLE IF EXISTS `t_acc`;
CREATE TABLE `t_acc` (
  `account_id` varchar(16) DEFAULT NULL,
  `password` varchar(32) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tc
-- ----------------------------
DROP TABLE IF EXISTS `tc`;
CREATE TABLE `tc` (
  `product_id` varchar(32) DEFAULT NULL,
  `side` varchar(1) DEFAULT NULL,
  `trade_quantity` decimal(30,10) DEFAULT NULL,
  `yesterday_ib_position` decimal(30,10) DEFAULT NULL,
  `yesterday_velox_position` decimal(30,10) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for td
-- ----------------------------
DROP TABLE IF EXISTS `td`;
CREATE TABLE `td` (
  `account_id` varchar(16) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `buy_sell` int(11) DEFAULT NULL,
  `exec_quantity` decimal(30,10) DEFAULT NULL,
  `exec_price` decimal(30,10) DEFAULT NULL,
  KEY `account_id` (`account_id`,`product_id`,`buy_sell`,`exec_quantity`,`exec_price`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for td2
-- ----------------------------
DROP TABLE IF EXISTS `td2`;
CREATE TABLE `td2` (
  `account_id` varchar(16) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `buy_sell` int(11) DEFAULT NULL,
  `exec_quantity` decimal(30,10) DEFAULT NULL,
  `exec_price` decimal(30,10) DEFAULT NULL,
  `cnt` int(11) DEFAULT NULL,
  KEY `account_id` (`account_id`,`product_id`,`buy_sell`,`exec_quantity`,`exec_price`,`cnt`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for td3
-- ----------------------------
DROP TABLE IF EXISTS `td3`;
CREATE TABLE `td3` (
  `account_id` varchar(16) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `buy_sell` int(11) DEFAULT NULL,
  `exec_quantity` decimal(30,10) DEFAULT NULL,
  `exec_price` decimal(30,10) DEFAULT NULL,
  `cnt` int(11) DEFAULT NULL,
  KEY `account_id` (`account_id`,`product_id`,`buy_sell`,`exec_quantity`,`exec_price`,`cnt`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for test2
-- ----------------------------
DROP TABLE IF EXISTS `test2`;
CREATE TABLE `test2` (
  `a` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for test_chris
-- ----------------------------
DROP TABLE IF EXISTS `test_chris`;
CREATE TABLE `test_chris` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `key_t` int(11) DEFAULT NULL,
  `value` char(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1580 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp
-- ----------------------------
DROP TABLE IF EXISTS `tmp`;
CREATE TABLE `tmp` (
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `amount` decimal(30,10) DEFAULT NULL,
  KEY `idx` (`account_id`,`currency`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp1
-- ----------------------------
DROP TABLE IF EXISTS `tmp1`;
CREATE TABLE `tmp1` (
  `a` int(11) DEFAULT NULL,
  `b` int(11) DEFAULT NULL,
  KEY `a` (`a`,`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp2
-- ----------------------------
DROP TABLE IF EXISTS `tmp2`;
CREATE TABLE `tmp2` (
  `a` int(11) DEFAULT NULL,
  `b` int(11) DEFAULT NULL,
  KEY `a` (`a`,`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_acc
-- ----------------------------
DROP TABLE IF EXISTS `tmp_acc`;
CREATE TABLE `tmp_acc` (
  `account_id` varchar(31) DEFAULT NULL,
  `password` varchar(30) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_account
-- ----------------------------
DROP TABLE IF EXISTS `tmp_account`;
CREATE TABLE `tmp_account` (
  `account_id` varchar(16) DEFAULT NULL,
  KEY `idx` (`account_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_account_balance
-- ----------------------------
DROP TABLE IF EXISTS `tmp_account_balance`;
CREATE TABLE `tmp_account_balance` (
  `account_id` varchar(16) DEFAULT NULL,
  `pre_balance` decimal(30,10) DEFAULT NULL,
  `flow` decimal(30,10) DEFAULT NULL,
  `trade` decimal(30,10) DEFAULT NULL,
  `balance` decimal(30,10) DEFAULT NULL,
  KEY `account_id` (`account_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_account_balance_bak_for_interst
-- ----------------------------
DROP TABLE IF EXISTS `tmp_account_balance_bak_for_interst`;
CREATE TABLE `tmp_account_balance_bak_for_interst` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `trade_balance` decimal(30,10) DEFAULT '0.0000000000',
  `settle_balance` decimal(30,10) DEFAULT '0.0000000000',
  `balance_avail` decimal(30,10) DEFAULT '0.0000000000',
  `balance_extract` decimal(30,10) DEFAULT '0.0000000000',
  `market_value` decimal(30,10) DEFAULT '0.0000000000',
  `long_market_value` decimal(30,10) DEFAULT '0.0000000000',
  `short_market_value` decimal(30,10) DEFAULT '0.0000000000',
  `equity_balance` decimal(30,10) DEFAULT NULL,
  `equity` decimal(30,10) DEFAULT '0.0000000000',
  `frozen_amount` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_amount` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `realized_pnl` decimal(30,10) DEFAULT '0.0000000000',
  `unrealized_pnl` decimal(30,10) DEFAULT '0.0000000000',
  `margin_amt` decimal(30,10) DEFAULT '0.0000000000',
  `charges` decimal(30,10) DEFAULT '0.0000000000',
  `portfolio_fee` decimal(30,10) DEFAULT '0.0000000000',
  `interest` decimal(30,10) DEFAULT '0.0000000000',
  `accrued_interest` decimal(30,10) DEFAULT '0.0000000000',
  `accrued_interest_credit` decimal(30,10) DEFAULT '0.0000000000',
  `debit_interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `credit_interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `ipo_frozen_before_close` decimal(30,10) DEFAULT '0.0000000000',
  `ipo_frozen_before_allot` decimal(30,10) DEFAULT '0.0000000000'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_account_interest_bak_for_interst
-- ----------------------------
DROP TABLE IF EXISTS `tmp_account_interest_bak_for_interst`;
CREATE TABLE `tmp_account_interest_bak_for_interst` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `currency` int(11) DEFAULT '0',
  `Bal` decimal(21,6) DEFAULT NULL,
  `PrimeRate` decimal(21,6) DEFAULT NULL,
  `SavingRate` decimal(21,6) DEFAULT NULL,
  `debit_formula_type` char(32) DEFAULT NULL,
  `debit_formula_code` char(32) DEFAULT NULL,
  `credit_formula_type` char(32) DEFAULT NULL,
  `credit_formula_code` char(32) DEFAULT NULL,
  `debit_interest` decimal(21,6) DEFAULT NULL,
  `credit_interest` decimal(21,6) DEFAULT NULL,
  `waive` varchar(1) DEFAULT '',
  `debit_interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `credit_interest_rate` decimal(30,10) DEFAULT '0.0000000000'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_account_order_detail
-- ----------------------------
DROP TABLE IF EXISTS `tmp_account_order_detail`;
CREATE TABLE `tmp_account_order_detail` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `order_no` char(32) DEFAULT NULL,
  `order_date` date DEFAULT NULL,
  `order_time` time DEFAULT NULL,
  `business_department` char(16) DEFAULT NULL,
  `department_trading_group` char(16) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `list_market_id` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT NULL,
  `product_sub_type` char(16) DEFAULT NULL,
  `product_id` char(16) DEFAULT NULL,
  `product_description` varchar(255) DEFAULT NULL,
  `quote_currency` char(3) DEFAULT NULL,
  `clearing_currency` char(3) DEFAULT NULL,
  `exchange_rate` decimal(30,10) DEFAULT NULL,
  `buy_sell` int(11) DEFAULT NULL,
  `order_price` decimal(30,10) DEFAULT NULL,
  `order_quantity` decimal(30,10) DEFAULT NULL,
  `trade_quantity` decimal(30,10) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `open_close` int(11) DEFAULT NULL,
  `hedge_flag` int(11) DEFAULT NULL,
  `call_put` int(11) DEFAULT NULL,
  `strike_price` decimal(30,10) DEFAULT NULL,
  `contract_date` date DEFAULT NULL,
  `input_channel` int(11) DEFAULT NULL,
  `remark` text,
  `update_time` datetime DEFAULT NULL,
  `update_user` char(16) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_account_position_ib
-- ----------------------------
DROP TABLE IF EXISTS `tmp_account_position_ib`;
CREATE TABLE `tmp_account_position_ib` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `net_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `frozen_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price1` decimal(30,10) DEFAULT '0.0000000000',
  `avg_price2` decimal(30,10) DEFAULT '0.0000000000',
  `pnl` decimal(30,10) DEFAULT '0.0000000000',
  `market_value` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `uncleared_amount` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `unsettled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `settled_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `settled_amount` decimal(30,10) DEFAULT '0.0000000000',
  `closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `last_closing_price` decimal(30,10) DEFAULT '0.0000000000',
  `margin_amount` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT '',
  `custodian_account` varchar(16) DEFAULT '',
  `nominee_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `position_cost` decimal(30,10) DEFAULT '0.0000000000'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_account_trade_detail_log
-- ----------------------------
DROP TABLE IF EXISTS `tmp_account_trade_detail_log`;
CREATE TABLE `tmp_account_trade_detail_log` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `trade_id` char(32) DEFAULT NULL,
  `trade_exec_id` char(32) DEFAULT NULL,
  `process_date` date DEFAULT NULL,
  `order_no` char(32) DEFAULT NULL,
  `order_date` date DEFAULT NULL,
  `order_time` time DEFAULT NULL,
  `business_department` char(16) DEFAULT NULL,
  `department_trading_group` char(16) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT '0',
  `list_market_id` int(11) DEFAULT '0',
  `product_type` int(11) DEFAULT '0',
  `product_sub_type` varchar(16) DEFAULT NULL,
  `product_id` char(16) DEFAULT NULL,
  `product_description` varchar(255) DEFAULT NULL,
  `quote_currency` char(3) DEFAULT NULL,
  `clearing_currency` char(3) DEFAULT NULL,
  `exchange_rate` decimal(30,10) DEFAULT NULL,
  `buy_sell` int(11) DEFAULT NULL,
  `order_price` decimal(30,10) DEFAULT NULL,
  `order_quantity` decimal(30,10) DEFAULT NULL,
  `trade_quantity` decimal(30,10) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `open_close` int(11) DEFAULT NULL,
  `hedge_flag` int(11) DEFAULT NULL,
  `call_put` int(11) DEFAULT NULL,
  `strike_price` decimal(30,10) DEFAULT NULL,
  `contract_date` date DEFAULT NULL,
  `input_channel` int(11) DEFAULT NULL,
  `remark` text,
  `exec_time` time DEFAULT NULL,
  `exec_no` char(128) DEFAULT NULL,
  `exchange_ref_no` char(32) DEFAULT NULL,
  `exec_broker` char(16) DEFAULT NULL,
  `contra_broker` char(16) DEFAULT NULL,
  `exec_quantity` decimal(30,10) DEFAULT NULL,
  `exec_price` decimal(30,10) DEFAULT NULL,
  `code` int(11) DEFAULT '0',
  `mark` char(16) DEFAULT NULL,
  `num_of_trades` int(11) DEFAULT '0',
  `trade_amount` decimal(30,10) DEFAULT '0.0000000000',
  `net_amount` decimal(30,10) DEFAULT '0.0000000000',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1645 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_accounts
-- ----------------------------
DROP TABLE IF EXISTS `tmp_accounts`;
CREATE TABLE `tmp_accounts` (
  `account_id` varchar(32) DEFAULT NULL,
  KEY `account_id` (`account_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_avg_price
-- ----------------------------
DROP TABLE IF EXISTS `tmp_avg_price`;
CREATE TABLE `tmp_avg_price` (
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `avg_price` decimal(30,10) DEFAULT NULL,
  KEY `idx` (`market_id`,`product_id`,`account_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_borrow_fee_accounts
-- ----------------------------
DROP TABLE IF EXISTS `tmp_borrow_fee_accounts`;
CREATE TABLE `tmp_borrow_fee_accounts` (
  `account_id` varchar(32) DEFAULT NULL,
  KEY `account_id` (`account_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_calendar
-- ----------------------------
DROP TABLE IF EXISTS `tmp_calendar`;
CREATE TABLE `tmp_calendar` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `market_id` int(11) DEFAULT NULL,
  `calendar_day` date DEFAULT NULL,
  `holiday` varchar(1) DEFAULT NULL,
  `description` varchar(64) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` char(16) DEFAULT NULL,
  KEY `idx1` (`calendar_day`,`holiday`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_cash_flow
-- ----------------------------
DROP TABLE IF EXISTS `tmp_cash_flow`;
CREATE TABLE `tmp_cash_flow` (
  `id` bigint(20) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `currency` int(11) DEFAULT '0',
  `sum(case when a.purpose = 1 then 1 else -1 end * a.amount)` decimal(44,6) DEFAULT NULL,
  `way` int(11) DEFAULT '0',
  `purpose` int(11) DEFAULT NULL,
  `remark` char(128) DEFAULT NULL,
  `remark2` varchar(128) DEFAULT NULL,
  `pay_bank_id` varchar(32) DEFAULT NULL,
  `pay_check_no` char(16) DEFAULT NULL,
  `pay_bank_account_name` char(32) DEFAULT NULL,
  `pay_bank_account_id` char(32) DEFAULT NULL,
  `rec_bank_id` varchar(32) DEFAULT NULL,
  `rec_check_no` char(16) DEFAULT NULL,
  `rec_bank_account_name` char(32) DEFAULT NULL,
  `rec_bank_account_id` char(32) DEFAULT NULL,
  `dividend_market_id` int(11) DEFAULT NULL,
  `dividend_product_id` varchar(16) DEFAULT NULL,
  `gl_mapping_item_id` varchar(64) DEFAULT NULL,
  `reference` varchar(128) DEFAULT NULL,
  `ifnull(c.custodian_code,a.custodian_code)` varchar(16) DEFAULT NULL,
  `ifnull(c.custodian_account,a.custodian_account)` varchar(16) DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  KEY `idx1` (`account_id`,`currency`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_cash_in_out
-- ----------------------------
DROP TABLE IF EXISTS `tmp_cash_in_out`;
CREATE TABLE `tmp_cash_in_out` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `cash_id` char(32) DEFAULT NULL,
  `process_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `currency` int(11) DEFAULT '0',
  `amount` decimal(21,6) DEFAULT NULL,
  `way` char(20) DEFAULT NULL,
  `purpose` char(32) DEFAULT NULL,
  `remark` char(128) DEFAULT NULL,
  `pay_check_no` char(16) DEFAULT NULL,
  `pay_bank_account_name` char(32) DEFAULT NULL,
  `pay_bank_account_id` char(32) DEFAULT NULL,
  `rec_check_no` char(16) DEFAULT NULL,
  `rec_bank_account_name` char(32) DEFAULT NULL,
  `rec_bank_account_id` char(32) DEFAULT NULL,
  `processed` char(50) NOT NULL DEFAULT 'N',
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `type` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_corp_action
-- ----------------------------
DROP TABLE IF EXISTS `tmp_corp_action`;
CREATE TABLE `tmp_corp_action` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `event_id` varchar(128) DEFAULT NULL,
  `event_type` varchar(32) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `external_product_id` varchar(32) DEFAULT NULL,
  `description` varchar(256) DEFAULT NULL,
  `ex_date` date DEFAULT NULL,
  `register_date` date DEFAULT NULL,
  `bc_date_from` date DEFAULT NULL,
  `bc_date_to` date DEFAULT NULL,
  `pay_date` date DEFAULT NULL,
  `scrip_fee` varchar(1) DEFAULT NULL,
  `nominee` varchar(1) DEFAULT NULL,
  `announce_ccy` int(11) DEFAULT NULL,
  `dividend_ccy` int(11) DEFAULT NULL,
  `dividend_rate` decimal(30,10) DEFAULT NULL,
  `tax_rate` decimal(30,10) DEFAULT NULL,
  `net_dividend_rate` decimal(30,10) DEFAULT NULL,
  `base_ccy` int(11) DEFAULT NULL,
  `convert_ccy` int(11) DEFAULT NULL,
  `exchange_rate` decimal(30,10) DEFAULT NULL,
  `scrip_price` decimal(30,10) DEFAULT NULL,
  `to_product_id` varchar(16) DEFAULT NULL,
  `to_external_product_id` varchar(32) DEFAULT NULL,
  `ratio_from` decimal(30,10) DEFAULT NULL,
  `ratio_to` decimal(30,10) DEFAULT NULL,
  `optional` varchar(1) DEFAULT NULL,
  `m_default` varchar(1) DEFAULT NULL,
  `book_closed_date` datetime DEFAULT NULL,
  `book_closed` varchar(1) DEFAULT NULL,
  `posted_date` datetime DEFAULT NULL,
  `posted` varchar(1) DEFAULT NULL,
  `charge_id1` varchar(32) DEFAULT NULL,
  `charge_id2` varchar(32) DEFAULT NULL,
  `charge_id3` varchar(32) DEFAULT NULL,
  `charge_id4` varchar(32) DEFAULT NULL,
  `charge_id5` varchar(32) DEFAULT NULL,
  `subscribe_charge_id1` varchar(32) DEFAULT NULL,
  `subscribe_charge_id2` varchar(32) DEFAULT NULL,
  `elect_time_from` datetime DEFAULT NULL,
  `elect_time_to` datetime DEFAULT NULL,
  `on_subscription` varchar(1) DEFAULT NULL,
  `sub_time_from` datetime DEFAULT NULL,
  `sub_time_to` datetime DEFAULT NULL,
  `sub_ccy` int(11) DEFAULT NULL,
  `sub_price` decimal(30,10) DEFAULT NULL,
  `trade_time_from` datetime DEFAULT NULL,
  `trade_time_to` datetime DEFAULT NULL,
  `remark` varchar(64) DEFAULT NULL,
  `subscribe_charge_id3` varchar(32) DEFAULT NULL,
  `subscribe_charge_id4` varchar(32) DEFAULT NULL,
  `record_count` int(11) DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx1` (`event_id`)
) ENGINE=InnoDB AUTO_INCREMENT=512 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_custodian_account_position
-- ----------------------------
DROP TABLE IF EXISTS `tmp_custodian_account_position`;
CREATE TABLE `tmp_custodian_account_position` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `market_value` decimal(30,10) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`market_id`,`product_id`,`custodian_code`,`custodian_account`)
) ENGINE=InnoDB AUTO_INCREMENT=4096 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_flow
-- ----------------------------
DROP TABLE IF EXISTS `tmp_flow`;
CREATE TABLE `tmp_flow` (
  `account_id` varchar(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `amount` decimal(30,10) DEFAULT NULL,
  KEY `account_id` (`account_id`,`currency`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_flow_hk
-- ----------------------------
DROP TABLE IF EXISTS `tmp_flow_hk`;
CREATE TABLE `tmp_flow_hk` (
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT NULL,
  KEY `market_id` (`market_id`,`product_id`,`account_id`,`custodian_code`,`custodian_account`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_flow_us
-- ----------------------------
DROP TABLE IF EXISTS `tmp_flow_us`;
CREATE TABLE `tmp_flow_us` (
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT NULL,
  KEY `market_id` (`market_id`,`product_id`,`account_id`,`custodian_code`,`custodian_account`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_fund_purchase_redemption
-- ----------------------------
DROP TABLE IF EXISTS `tmp_fund_purchase_redemption`;
CREATE TABLE `tmp_fund_purchase_redemption` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` varchar(16) NOT NULL,
  `account_type` varchar(16) NOT NULL,
  `product_id` varchar(31) NOT NULL,
  `order_type` int(11) NOT NULL,
  `apply_qty` decimal(30,10) NOT NULL,
  `qty` decimal(30,10) NOT NULL,
  `price` decimal(30,10) NOT NULL,
  `amount` decimal(30,10) NOT NULL,
  `fee` decimal(30,10) NOT NULL DEFAULT '0.0000000000',
  `update_date` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_import_account_trade_detail
-- ----------------------------
DROP TABLE IF EXISTS `tmp_import_account_trade_detail`;
CREATE TABLE `tmp_import_account_trade_detail` (
  `trade_id` char(32) DEFAULT NULL,
  `trade_exec_id` char(32) DEFAULT NULL,
  `process_date` date DEFAULT NULL,
  `order_no` char(32) DEFAULT NULL,
  `order_date` date DEFAULT NULL,
  `order_time` datetime(3) DEFAULT '0000-00-00 00:00:00.000',
  `business_department` char(16) DEFAULT NULL,
  `department_trading_group` char(16) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT '0000-00-00',
  `market_id` int(11) DEFAULT '0',
  `list_market_id` int(11) DEFAULT '0',
  `product_type` int(11) DEFAULT '0',
  `product_sub_type` varchar(16) DEFAULT NULL,
  `product_id` char(16) DEFAULT NULL,
  `product_description` varchar(255) DEFAULT NULL,
  `quote_currency` char(3) DEFAULT NULL,
  `clearing_currency` char(3) DEFAULT NULL,
  `exchange_rate` decimal(30,10) DEFAULT NULL,
  `buy_sell` int(11) DEFAULT NULL,
  `order_price` decimal(30,10) DEFAULT NULL,
  `order_quantity` decimal(30,10) DEFAULT NULL,
  `trade_quantity` decimal(30,10) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `open_close` int(11) DEFAULT NULL,
  `hedge_flag` int(11) DEFAULT '0',
  `call_put` int(11) DEFAULT '0',
  `strike_price` decimal(30,10) DEFAULT '0.0000000000',
  `contract_date` date DEFAULT '0000-00-00',
  `input_channel` int(11) DEFAULT NULL,
  `remark` text,
  `exec_time` datetime(3) DEFAULT NULL,
  `exec_no` char(128) DEFAULT NULL,
  `exchange_ref_no` char(32) DEFAULT NULL,
  `exec_broker` char(16) DEFAULT NULL,
  `contra_broker` char(16) DEFAULT NULL,
  `exec_quantity` decimal(30,10) DEFAULT NULL,
  `exec_price` decimal(30,10) DEFAULT NULL,
  `code` int(11) DEFAULT '0',
  `mark` char(16) DEFAULT NULL,
  `num_of_trades` int(11) DEFAULT '1',
  `trade_amount` decimal(30,10) DEFAULT '0.0000000000',
  `net_amount` decimal(30,10) DEFAULT '0.0000000000',
  `update_time` varchar(30) DEFAULT NULL,
  `update_user` char(16) DEFAULT NULL,
  `ConfirmStatus` char(16) DEFAULT NULL,
  `broker` varchar(16) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `is_odd_lot` varchar(1) DEFAULT 'N'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_import_product_info
-- ----------------------------
DROP TABLE IF EXISTS `tmp_import_product_info`;
CREATE TABLE `tmp_import_product_info` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `trade_date` date DEFAULT NULL,
  `list_market_id` int(11) DEFAULT NULL,
  `product_id` varchar(32) DEFAULT NULL,
  `product_description` varchar(255) DEFAULT NULL,
  `product_class` varchar(32) DEFAULT NULL,
  `product_type` int(11) DEFAULT NULL,
  `settle_day` date DEFAULT NULL,
  `listing_date` date DEFAULT NULL,
  `last_trading_date` date DEFAULT NULL,
  `price_factor` decimal(30,10) DEFAULT NULL,
  `contract_size` decimal(30,10) DEFAULT NULL,
  `quote_currency` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `settle_price` decimal(30,10) DEFAULT NULL,
  `closing_price` decimal(30,10) DEFAULT NULL,
  `update_user` varchar(64) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`trade_date`,`list_market_id`,`product_id`),
  KEY `indx2` (`list_market_id`,`product_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_ipo
-- ----------------------------
DROP TABLE IF EXISTS `tmp_ipo`;
CREATE TABLE `tmp_ipo` (
  `account_id` varchar(32) DEFAULT NULL,
  `refund_amount` decimal(30,10) DEFAULT NULL,
  KEY `account_id` (`account_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_load_result_file
-- ----------------------------
DROP TABLE IF EXISTS `tmp_load_result_file`;
CREATE TABLE `tmp_load_result_file` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `ipo_id` varchar(64) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `amount` decimal(30,10) DEFAULT '0.0000000000',
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `price` decimal(30,10) DEFAULT '0.0000000000',
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `ipo_id` (`ipo_id`,`account_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_market_product_mapping
-- ----------------------------
DROP TABLE IF EXISTS `tmp_market_product_mapping`;
CREATE TABLE `tmp_market_product_mapping` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `mapping_code` varchar(16) DEFAULT NULL,
  `market_id` varchar(32) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `to_product_id` varchar(16) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`mapping_code`,`market_id`,`product_id`),
  KEY `idx2` (`mapping_code`,`market_id`,`to_product_id`)
) ENGINE=InnoDB AUTO_INCREMENT=4096 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_max
-- ----------------------------
DROP TABLE IF EXISTS `tmp_max`;
CREATE TABLE `tmp_max` (
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT NULL,
  KEY `market_id` (`market_id`,`product_id`,`account_id`,`custodian_code`,`custodian_account`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_official_product_closeprice
-- ----------------------------
DROP TABLE IF EXISTS `tmp_official_product_closeprice`;
CREATE TABLE `tmp_official_product_closeprice` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `trade_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `closing_price` decimal(30,10) DEFAULT NULL,
  `status` varchar(1) DEFAULT NULL,
  `update_user` varchar(16) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`trade_date`,`market_id`,`product_id`),
  KEY `idx2` (`market_id`,`product_id`)
) ENGINE=InnoDB AUTO_INCREMENT=1024 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_position
-- ----------------------------
DROP TABLE IF EXISTS `tmp_position`;
CREATE TABLE `tmp_position` (
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT NULL,
  KEY `market_id` (`market_id`,`product_id`,`account_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_product
-- ----------------------------
DROP TABLE IF EXISTS `tmp_product`;
CREATE TABLE `tmp_product` (
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(32) DEFAULT NULL,
  `loan_rate` decimal(30,10) DEFAULT NULL,
  KEY `market_id` (`market_id`,`product_id`),
  KEY `idx1` (`product_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_product_flow
-- ----------------------------
DROP TABLE IF EXISTS `tmp_product_flow`;
CREATE TABLE `tmp_product_flow` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `account_id` varchar(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT NULL,
  `ifnull(c.custodian_code,a.custodian_code)` varchar(16) DEFAULT NULL,
  `ifnull(c.custodian_account,a.custodian_account)` varchar(16) DEFAULT NULL,
  `nominee_quantity` decimal(30,10) DEFAULT NULL,
  `avg_price` decimal(30,10) DEFAULT NULL,
  `avg_price2` decimal(30,10) DEFAULT NULL,
  `remark` varchar(128) DEFAULT NULL,
  `update_user` varchar(16) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_product_ipo_allotation
-- ----------------------------
DROP TABLE IF EXISTS `tmp_product_ipo_allotation`;
CREATE TABLE `tmp_product_ipo_allotation` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `ipo_id` char(64) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `list_market_id` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT '0',
  `allot_qty` decimal(31,10) DEFAULT '0.0000000000',
  `allot_price` decimal(31,10) DEFAULT '0.0000000000',
  `refund_amount` decimal(31,10) DEFAULT '0.0000000000',
  `remark` char(255) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`ipo_id`,`account_id`,`account_type`,`list_market_id`,`product_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2048 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_product_ipo_announcement
-- ----------------------------
DROP TABLE IF EXISTS `tmp_product_ipo_announcement`;
CREATE TABLE `tmp_product_ipo_announcement` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `ipo_id` char(64) DEFAULT NULL,
  `list_market_id` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `product_name` char(255) DEFAULT NULL,
  `currency` int(11) DEFAULT '0',
  `start_time` datetime DEFAULT NULL,
  `close_time` datetime DEFAULT NULL,
  `margin_start_time` datetime DEFAULT NULL,
  `margin_close_time` datetime DEFAULT NULL,
  `balance_frozen_start_time` datetime DEFAULT NULL,
  `balance_frozen_close_time` datetime DEFAULT NULL,
  `max_loan_ratio` decimal(30,10) DEFAULT '0.0000000000',
  `max_loan_amount` decimal(30,10) DEFAULT '0.0000000000',
  `interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `interest_day` int(11) DEFAULT NULL,
  `min_apply_amount` decimal(30,10) DEFAULT '0.0000000000',
  `max_apply_amount` decimal(30,10) DEFAULT '0.0000000000',
  `charge_rate` decimal(30,10) DEFAULT '0.0000000000',
  `charge` decimal(30,10) DEFAULT '0.0000000000',
  `loan_charge_rate` decimal(30,10) DEFAULT '0.0000000000',
  `loan_charge` decimal(30,10) DEFAULT '0.0000000000',
  `official_close_time` datetime DEFAULT NULL,
  `allot_date` date DEFAULT NULL,
  `listing_date` date DEFAULT NULL,
  `issue_price` decimal(30,10) DEFAULT '0.0000000000',
  `min_issue_price` decimal(30,10) DEFAULT '0.0000000000',
  `max_issue_price` decimal(30,10) DEFAULT '0.0000000000',
  `issue_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `url1` char(128) DEFAULT NULL,
  `url2` char(128) DEFAULT NULL,
  `url3` char(128) DEFAULT NULL,
  `url4` char(128) DEFAULT NULL,
  `allow_web_e_ipo` varchar(1) DEFAULT 'Y',
  `allow_web_cancel` varchar(1) DEFAULT 'N',
  `remark` text,
  `app_posted` varchar(1) DEFAULT NULL,
  `app_posted_time` datetime DEFAULT NULL,
  `result_posted` varchar(1) DEFAULT NULL,
  `result_posted_time` datetime DEFAULT NULL,
  `refund_posted` varchar(1) DEFAULT NULL,
  `refund_posted_time` datetime DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` varchar(32) DEFAULT NULL,
  `apply_quantity` int(11) DEFAULT '0',
  `trading_fee_rate` decimal(30,10) DEFAULT '0.0000000000',
  `trading_fee_standard` decimal(30,10) DEFAULT '0.0000000000',
  `pla_loan_ratio` decimal(30,10) DEFAULT '0.0000000000',
  `is_cross_trade` varchar(1) DEFAULT 'N',
  `settle_date` date DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`ipo_id`,`list_market_id`,`product_id`)
) ENGINE=InnoDB AUTO_INCREMENT=287 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_product_ipo_announcement_20191209
-- ----------------------------
DROP TABLE IF EXISTS `tmp_product_ipo_announcement_20191209`;
CREATE TABLE `tmp_product_ipo_announcement_20191209` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `ipo_id` char(64) DEFAULT NULL,
  `list_market_id` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `product_name` char(255) DEFAULT NULL,
  `currency` int(11) DEFAULT '0',
  `start_time` datetime DEFAULT NULL,
  `close_time` datetime DEFAULT NULL,
  `margin_start_time` datetime DEFAULT NULL,
  `margin_close_time` datetime DEFAULT NULL,
  `balance_frozen_start_time` datetime DEFAULT NULL,
  `balance_frozen_close_time` datetime DEFAULT NULL,
  `max_loan_ratio` decimal(30,10) DEFAULT '0.0000000000',
  `max_loan_amount` decimal(30,10) DEFAULT '0.0000000000',
  `interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `interest_day` int(11) DEFAULT NULL,
  `min_apply_amount` decimal(30,10) DEFAULT '0.0000000000',
  `max_apply_amount` decimal(30,10) DEFAULT '0.0000000000',
  `charge_rate` decimal(30,10) DEFAULT '0.0000000000',
  `charge` decimal(30,10) DEFAULT '0.0000000000',
  `loan_charge_rate` decimal(30,10) DEFAULT '0.0000000000',
  `loan_charge` decimal(30,10) DEFAULT '0.0000000000',
  `official_close_time` datetime DEFAULT NULL,
  `allot_date` date DEFAULT NULL,
  `listing_date` date DEFAULT NULL,
  `issue_price` decimal(30,10) DEFAULT '0.0000000000',
  `min_issue_price` decimal(30,10) DEFAULT '0.0000000000',
  `max_issue_price` decimal(30,10) DEFAULT '0.0000000000',
  `issue_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `url1` char(128) DEFAULT NULL,
  `url2` char(128) DEFAULT NULL,
  `url3` char(128) DEFAULT NULL,
  `url4` char(128) DEFAULT NULL,
  `allow_web_e_ipo` varchar(1) DEFAULT 'Y',
  `allow_web_cancel` varchar(1) DEFAULT 'N',
  `remark` text,
  `app_posted` varchar(1) DEFAULT NULL,
  `app_posted_time` datetime DEFAULT NULL,
  `result_posted` varchar(1) DEFAULT NULL,
  `result_posted_time` datetime DEFAULT NULL,
  `refund_posted` varchar(1) DEFAULT NULL,
  `refund_posted_time` datetime DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  `update_time` varchar(32) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_product_ipo_app
-- ----------------------------
DROP TABLE IF EXISTS `tmp_product_ipo_app`;
CREATE TABLE `tmp_product_ipo_app` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `ipo_id` char(64) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `list_market_id` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `amount` decimal(30,10) DEFAULT '0.0000000000',
  `currency` int(11) DEFAULT '0',
  `loan_ratio` decimal(30,10) DEFAULT '0.0000000000',
  `loan_amount` decimal(30,10) DEFAULT '0.0000000000',
  `interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `interest` decimal(30,10) DEFAULT '0.0000000000',
  `charge` decimal(30,10) DEFAULT '0.0000000000',
  `loan_charge` decimal(30,10) DEFAULT '0.0000000000',
  `allot_qty` decimal(31,10) DEFAULT '0.0000000000',
  `allot_price` decimal(31,10) DEFAULT '0.0000000000',
  `refund_amount` decimal(31,10) DEFAULT '0.0000000000',
  `remark` char(255) DEFAULT NULL,
  `created_time` datetime(3) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL,
  `app_posted` varchar(1) DEFAULT 'N',
  `app_posted_time` datetime DEFAULT NULL,
  `result_posted` varchar(1) DEFAULT 'N',
  `result_posted_time` datetime DEFAULT NULL,
  `refund_posted` varchar(1) DEFAULT 'N',
  `refund_posted_time` datetime DEFAULT NULL,
  `sub_status` int(1) DEFAULT '1',
  PRIMARY KEY (`id`),
  KEY `idx1` (`ipo_id`,`account_id`,`account_type`,`list_market_id`,`product_id`)
) ENGINE=InnoDB AUTO_INCREMENT=10073 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_product_ipo_app_20191209
-- ----------------------------
DROP TABLE IF EXISTS `tmp_product_ipo_app_20191209`;
CREATE TABLE `tmp_product_ipo_app_20191209` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `ipo_id` char(64) DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `list_market_id` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `amount` decimal(30,10) DEFAULT '0.0000000000',
  `currency` int(11) DEFAULT '0',
  `loan_ratio` decimal(30,10) DEFAULT '0.0000000000',
  `loan_amount` decimal(30,10) DEFAULT '0.0000000000',
  `interest_rate` decimal(30,10) DEFAULT '0.0000000000',
  `interest` decimal(30,10) DEFAULT '0.0000000000',
  `charge` decimal(30,10) DEFAULT '0.0000000000',
  `loan_charge` decimal(30,10) DEFAULT '0.0000000000',
  `allot_qty` decimal(31,10) DEFAULT '0.0000000000',
  `allot_price` decimal(31,10) DEFAULT '0.0000000000',
  `refund_amount` decimal(31,10) DEFAULT '0.0000000000',
  `remark` char(255) DEFAULT NULL,
  `created_time` datetime(3) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `update_user` char(32) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_product_ipo_qty
-- ----------------------------
DROP TABLE IF EXISTS `tmp_product_ipo_qty`;
CREATE TABLE `tmp_product_ipo_qty` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `ipo_id` char(64) DEFAULT NULL,
  `qty` decimal(30,10) DEFAULT NULL,
  `currency` int(11) DEFAULT '0',
  `amount` decimal(30,10) DEFAULT '0.0000000000',
  `update_user` char(32) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx1` (`ipo_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_rpt_accounts
-- ----------------------------
DROP TABLE IF EXISTS `tmp_rpt_accounts`;
CREATE TABLE `tmp_rpt_accounts` (
  `account_currency_group_id` bigint(20) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  KEY `idx` (`account_id`,`currency`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_rpt_cash_io
-- ----------------------------
DROP TABLE IF EXISTS `tmp_rpt_cash_io`;
CREATE TABLE `tmp_rpt_cash_io` (
  `account_type` int(11) DEFAULT NULL,
  `io_count` int(11) DEFAULT NULL,
  KEY `idx` (`account_type`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_rpt_detail_id
-- ----------------------------
DROP TABLE IF EXISTS `tmp_rpt_detail_id`;
CREATE TABLE `tmp_rpt_detail_id` (
  `group_id` int(11) DEFAULT NULL,
  `trade_id` varchar(64) DEFAULT NULL,
  `show_order_id` bigint(20) DEFAULT NULL,
  KEY `idx1` (`trade_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_rpt_product_io
-- ----------------------------
DROP TABLE IF EXISTS `tmp_rpt_product_io`;
CREATE TABLE `tmp_rpt_product_io` (
  `account_type` int(11) DEFAULT NULL,
  `io_count` int(11) DEFAULT NULL,
  KEY `idx` (`account_type`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_settle
-- ----------------------------
DROP TABLE IF EXISTS `tmp_settle`;
CREATE TABLE `tmp_settle` (
  `account_id` varchar(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `amount` decimal(30,10) DEFAULT NULL,
  KEY `account_id` (`account_id`,`currency`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_settle_hk
-- ----------------------------
DROP TABLE IF EXISTS `tmp_settle_hk`;
CREATE TABLE `tmp_settle_hk` (
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT NULL,
  KEY `market_id` (`market_id`,`product_id`,`account_id`,`custodian_code`,`custodian_account`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_settle_us
-- ----------------------------
DROP TABLE IF EXISTS `tmp_settle_us`;
CREATE TABLE `tmp_settle_us` (
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT NULL,
  KEY `market_id` (`market_id`,`product_id`,`account_id`,`custodian_code`,`custodian_account`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_settled_20200103
-- ----------------------------
DROP TABLE IF EXISTS `tmp_settled_20200103`;
CREATE TABLE `tmp_settled_20200103` (
  `account_id` char(16) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_id` char(16) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  KEY `idx1` (`account_id`,`market_id`,`product_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_trade
-- ----------------------------
DROP TABLE IF EXISTS `tmp_trade`;
CREATE TABLE `tmp_trade` (
  `account_id` varchar(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `amount` decimal(30,10) DEFAULT NULL,
  KEY `account_id` (`account_id`,`currency`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_trade_compare
-- ----------------------------
DROP TABLE IF EXISTS `tmp_trade_compare`;
CREATE TABLE `tmp_trade_compare` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `exchange_trade_date` date DEFAULT NULL,
  `exchange_exec_broker` char(16) DEFAULT NULL,
  `exchange_market_id` int(11) DEFAULT NULL,
  `exchange_product_id` char(16) DEFAULT NULL,
  `exchange_buy_sell` int(11) DEFAULT NULL,
  `exchange_exec_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `exchange_exec_price` decimal(30,10) DEFAULT '0.0000000000',
  `exchange_times` int(11) DEFAULT '0',
  `comp_times` int(11) DEFAULT '0',
  `trade_date` date DEFAULT NULL,
  `exec_broker` char(16) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_id` char(16) DEFAULT NULL,
  `buy_sell` int(11) DEFAULT NULL,
  `exec_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `exec_price` decimal(30,10) DEFAULT '0.0000000000',
  `times` int(11) DEFAULT '0'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_trade_id
-- ----------------------------
DROP TABLE IF EXISTS `tmp_trade_id`;
CREATE TABLE `tmp_trade_id` (
  `trade_id` bigint(20) DEFAULT NULL,
  KEY `trade_id` (`trade_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_trade_summary
-- ----------------------------
DROP TABLE IF EXISTS `tmp_trade_summary`;
CREATE TABLE `tmp_trade_summary` (
  `account_id` varchar(32) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `amount` decimal(30,10) DEFAULT NULL,
  `charges` decimal(30,10) DEFAULT NULL,
  `commission` decimal(30,10) DEFAULT NULL,
  KEY `account_id` (`account_id`,`account_type`,`currency`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_txt
-- ----------------------------
DROP TABLE IF EXISTS `tmp_txt`;
CREATE TABLE `tmp_txt` (
  `process_date` date DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `market_value` decimal(30,10) DEFAULT NULL,
  KEY `idx1` (`process_date`,`account_id`,`currency`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_us_16_price
-- ----------------------------
DROP TABLE IF EXISTS `tmp_us_16_price`;
CREATE TABLE `tmp_us_16_price` (
  `trade_date` date DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(16) DEFAULT NULL,
  `closing_price` decimal(30,10) DEFAULT NULL,
  KEY `idx1` (`trade_date`,`market_id`,`product_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmp_yxt
-- ----------------------------
DROP TABLE IF EXISTS `tmp_yxt`;
CREATE TABLE `tmp_yxt` (
  `account_id` varchar(16) DEFAULT NULL,
  `jcbms_charge` decimal(30,10) DEFAULT NULL,
  `bos_charge` decimal(30,10) DEFAULT NULL,
  KEY `account_id` (`account_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tmpmax
-- ----------------------------
DROP TABLE IF EXISTS `tmpmax`;
CREATE TABLE `tmpmax` (
  `market_id` int(11) DEFAULT NULL,
  `product_id` varchar(32) DEFAULT NULL,
  `account_id` varchar(16) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT NULL,
  KEY `idx` (`market_id`,`product_id`,`custodian_code`,`custodian_account`,`account_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for tp
-- ----------------------------
DROP TABLE IF EXISTS `tp`;
CREATE TABLE `tp` (
  `product_id` varchar(32) DEFAULT NULL,
  `custodian_code` varchar(16) DEFAULT NULL,
  `net_quantity` decimal(30,10) DEFAULT NULL,
  KEY `product_id` (`product_id`,`custodian_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for trade_compare
-- ----------------------------
DROP TABLE IF EXISTS `trade_compare`;
CREATE TABLE `trade_compare` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `exchange_trade_date` date DEFAULT NULL,
  `exchange_exec_broker` char(16) DEFAULT NULL,
  `exchange_market_id` int(11) DEFAULT NULL,
  `exchange_product_id` char(16) DEFAULT NULL,
  `exchange_buy_sell` int(11) DEFAULT NULL,
  `exchange_exec_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `exchange_exec_price` decimal(30,10) DEFAULT '0.0000000000',
  `exchange_times` int(11) DEFAULT '0',
  `comp_times` int(11) DEFAULT '0',
  `trade_date` date DEFAULT NULL,
  `exec_broker` char(16) DEFAULT NULL,
  `market_id` int(11) DEFAULT NULL,
  `product_id` char(16) DEFAULT NULL,
  `buy_sell` int(11) DEFAULT NULL,
  `exec_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `exec_price` decimal(30,10) DEFAULT '0.0000000000',
  `times` int(11) DEFAULT '0',
  PRIMARY KEY (`id`),
  KEY `Index1` (`process_date`)
) ENGINE=InnoDB AUTO_INCREMENT=4096 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for uco_position
-- ----------------------------
DROP TABLE IF EXISTS `uco_position`;
CREATE TABLE `uco_position` (
  `account_id` varchar(16) DEFAULT '',
  `net_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `now_quantity` decimal(30,10) DEFAULT '0.0000000000',
  KEY `idx` (`account_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for uco_position2
-- ----------------------------
DROP TABLE IF EXISTS `uco_position2`;
CREATE TABLE `uco_position2` (
  `account_id` varchar(16) DEFAULT '',
  `net_quantity` decimal(30,10) DEFAULT '0.0000000000',
  `now_quantity` decimal(30,10) DEFAULT '0.0000000000',
  KEY `idx` (`account_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for unsettled
-- ----------------------------
DROP TABLE IF EXISTS `unsettled`;
CREATE TABLE `unsettled` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `market_id` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `amount` decimal(30,10) DEFAULT '0.0000000000'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for unsettled_position
-- ----------------------------
DROP TABLE IF EXISTS `unsettled_position`;
CREATE TABLE `unsettled_position` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `market_id` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT '0',
  `product_id` varchar(32) DEFAULT '',
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `amount` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx` (`process_date`,`market_id`,`product_type`),
  KEY `idx2` (`account_id`),
  KEY `idx3` (`market_id`,`product_id`,`account_id`,`account_type`,`custodian_code`,`custodian_account`)
) ENGINE=InnoDB AUTO_INCREMENT=2962186 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for unsettled_position_20200123
-- ----------------------------
DROP TABLE IF EXISTS `unsettled_position_20200123`;
CREATE TABLE `unsettled_position_20200123` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `market_id` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `amount` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for unsettled_position_20200511
-- ----------------------------
DROP TABLE IF EXISTS `unsettled_position_20200511`;
CREATE TABLE `unsettled_position_20200511` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `market_id` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `amount` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for unsettled_position_20201013
-- ----------------------------
DROP TABLE IF EXISTS `unsettled_position_20201013`;
CREATE TABLE `unsettled_position_20201013` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `market_id` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `amount` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for unsettled_position_20201014
-- ----------------------------
DROP TABLE IF EXISTS `unsettled_position_20201014`;
CREATE TABLE `unsettled_position_20201014` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `market_id` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `amount` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for unsettled_position_bak
-- ----------------------------
DROP TABLE IF EXISTS `unsettled_position_bak`;
CREATE TABLE `unsettled_position_bak` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `market_id` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `amount` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for unsettled_position_uco
-- ----------------------------
DROP TABLE IF EXISTS `unsettled_position_uco`;
CREATE TABLE `unsettled_position_uco` (
  `id` bigint(11) NOT NULL DEFAULT '0',
  `process_date` date DEFAULT NULL,
  `trade_date` date DEFAULT NULL,
  `settle_date` date DEFAULT NULL,
  `account_id` char(16) DEFAULT NULL,
  `account_type` int(11) DEFAULT '0',
  `market_id` int(11) DEFAULT NULL,
  `product_type` int(11) DEFAULT '0',
  `product_id` char(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `quantity` decimal(30,10) DEFAULT '0.0000000000',
  `amount` decimal(30,10) DEFAULT '0.0000000000',
  `custodian_code` varchar(16) DEFAULT NULL,
  `custodian_account` varchar(16) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for upload_file
-- ----------------------------
DROP TABLE IF EXISTS `upload_file`;
CREATE TABLE `upload_file` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `file_id` varchar(64) DEFAULT NULL,
  `file_description` varchar(64) DEFAULT NULL,
  `client_source_path` varchar(255) DEFAULT NULL,
  `client_dest_path` varchar(255) DEFAULT NULL,
  `last_upload_time` datetime DEFAULT NULL,
  `last_handle_time` datetime DEFAULT NULL,
  `path_setting` varchar(1) DEFAULT 'Y',
  `server_market_id` int(11) DEFAULT NULL,
  `server_file_id` varchar(32) DEFAULT NULL,
  `surpport_market_id` int(11) DEFAULT NULL,
  `surpport_product_type` int(11) DEFAULT NULL,
  `is_show` varchar(1) DEFAULT 'Y',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for us_loan_rate
-- ----------------------------
DROP TABLE IF EXISTS `us_loan_rate`;
CREATE TABLE `us_loan_rate` (
  `product_id` varchar(16) DEFAULT NULL,
  `loan_rate` decimal(30,10) DEFAULT NULL,
  KEY `idx` (`product_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `user_id` varchar(32) DEFAULT NULL,
  `user_pwd` varchar(128) DEFAULT NULL,
  `user_level` int(11) DEFAULT NULL,
  `created_by` varchar(32) DEFAULT NULL,
  `update_time` varchar(32) DEFAULT NULL,
  `update_user` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for user_privilege
-- ----------------------------
DROP TABLE IF EXISTS `user_privilege`;
CREATE TABLE `user_privilege` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` varchar(32) DEFAULT '',
  `menu_id` bigint(20) DEFAULT '0',
  `name` varchar(32) DEFAULT '',
  `visible` varchar(1) DEFAULT 'N',
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx1` (`user_id`,`menu_id`)
) ENGINE=InnoDB AUTO_INCREMENT=1122 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for voucher_data
-- ----------------------------
DROP TABLE IF EXISTS `voucher_data`;
CREATE TABLE `voucher_data` (
  `process_date` date NOT NULL,
  `voucher_key` varchar(32) NOT NULL,
  `voucher_value` decimal(30,10) DEFAULT NULL,
  `voucher_desc` varchar(256) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`process_date`,`voucher_key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for yxt_log
-- ----------------------------
DROP TABLE IF EXISTS `yxt_log`;
CREATE TABLE `yxt_log` (
  `account_id` varchar(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `amount` decimal(30,10) DEFAULT NULL,
  KEY `idx1` (`account_id`,`currency`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for yxt_log2
-- ----------------------------
DROP TABLE IF EXISTS `yxt_log2`;
CREATE TABLE `yxt_log2` (
  `account_id` varchar(16) DEFAULT NULL,
  `currency` int(11) DEFAULT NULL,
  `amount` decimal(30,10) DEFAULT NULL,
  KEY `idx1` (`account_id`,`currency`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Function structure for floor_sign
-- ----------------------------
DROP FUNCTION IF EXISTS `floor_sign`;
delimiter ;;
CREATE FUNCTION `floor_sign`(i_value DECIMAL(30,10))
 RETURNS decimal(30,10)
BEGIN
    RETURN case when i_value = 0 then 0 else (abs(i_value)/i_value)*floor(abs(i_value)) end;
END
;;
delimiter ;

-- ----------------------------
-- Function structure for floor_times
-- ----------------------------
DROP FUNCTION IF EXISTS `floor_times`;
delimiter ;;
CREATE FUNCTION `floor_times`(`i_left` DECIMAL(30,10))
 RETURNS decimal(30,10)
BEGIN
    RETURN floor(i_left * 10000)/10000;
END
;;
delimiter ;

-- ----------------------------
-- Function structure for funCashFlowType
-- ----------------------------
DROP FUNCTION IF EXISTS `funCashFlowType`;
delimiter ;;
CREATE FUNCTION `funCashFlowType`(i_remark  varchar(128))
 RETURNS int(11)
label_pro: BEGIN
    declare v_type int(11) default 0;  
    
    set v_type = case when i_remark like 'CorpAction-%' then 10                     -- 公司行动之派息
                      when i_remark like 'CorpAction %' then 11                     -- 公司行动之费用
                      when i_remark like 'IPO Apply Handling Fee%' then 5           -- IPO 手续费，含港交所 5 港币的费用
                      when i_remark like '%Placing Order Handling Fee%' then 5
                      when i_remark like 'IPO Apply%' then 4                        -- IPO 扣款, IPO 认购时的总金额
                      when i_remark like 'IPO Refund%' then 8                       -- IPO 退款，尊嘉在派发日退还未中签对应的金额
                      when i_remark like 'IPO Loan Return%' then 7                  -- IPO 融资金额的收回，尊嘉在派发日收回
                      when i_remark like '%Placing Order%' then 7 
                      when i_remark like 'IPO Loan Interest%' then 9                -- IPO 融资利息的扣款，尊嘉在派发日扣除
                      when i_remark like 'IPO Loan%' then 6                         -- IPO 融资金额的发放，尊嘉在截止日发放
                      when i_remark like 'conversion;%' then 3                      -- 货币兑换(兑换后，会出现 2 条记录)
                      when i_remark like '%申购出金%' then 15                        --  货币基金申购
                      when i_remark like '%赎回入金%' then 16                        -- 货币基金赎回
                      when i_remark like 'Portfolio Fee%' then 14                   -- 证券组合费，尊嘉每日计算，每月底扣除
                      when i_remark like 'Monthly Interest Received%' then 12       -- 客人应收利息，尊嘉每日计算，每月底支付
                      when i_remark like 'Monthly Interest Paid%' then 13           -- 客人应付利息，尊嘉每日计算，每月底扣除
                      when i_remark like '存款;%' then 1                            -- 客人发起的入金
                      when i_remark like '提款;%' then 2                            -- 客人发起的出金
                      else 0                                                        -- 其他类型
                      end;
    
    return v_type; 
END
;;
delimiter ;

-- ----------------------------
-- Function structure for funErrCode
-- ----------------------------
DROP FUNCTION IF EXISTS `funErrCode`;
delimiter ;;
CREATE FUNCTION `funErrCode`(i_enum_str VARCHAR(128))
 RETURNS int(11)
label: BEGIN
    DECLARE v_error_code INT DEFAULT NULL;
    SELECT error_code INTO v_error_code FROM error_code_info WHERE error_enum=i_enum_str;
    IF v_error_code IS NULL THEN
        SELECT error_code INTO v_error_code FROM error_code_info WHERE error_enum='ERR_OTHER_DEFAULT';
    END IF;
    RETURN v_error_code;
END
;;
delimiter ;

-- ----------------------------
-- Function structure for funGenerateCashID
-- ----------------------------
DROP FUNCTION IF EXISTS `funGenerateCashID`;
delimiter ;;
CREATE FUNCTION `funGenerateCashID`(i_process_date date)
 RETURNS bigint(20)
label_pro: BEGIN
   set @v_id = 0;  
   if not exists(select 1 from generate_cash_id where process_date = i_process_date) then 
        insert into generate_cash_id select i_process_date,1;
   end if; 
   select generate_id into @v_id from generate_cash_id where process_date = i_process_date;
   update generate_cash_id set generate_id =generate_id +1 where process_date = i_process_date;
     return @v_id;
END
;;
delimiter ;

-- ----------------------------
-- Function structure for funGenerateExecID
-- ----------------------------
DROP FUNCTION IF EXISTS `funGenerateExecID`;
delimiter ;;
CREATE FUNCTION `funGenerateExecID`(i_trade_id varchar(32))
 RETURNS bigint(20)
label_pro: BEGIN
   set @v_id = 0;  
   if not exists(select 1 from generate_exec_id where trade_id = i_trade_id) then 
   		insert into generate_exec_id select i_trade_id,1;
   end if; 
   select ifnull(id,0) into @v_id from generate_exec_id where trade_id = i_trade_id;
   update generate_exec_id set id =ifnull(id,0) +1 where trade_id = i_trade_id;
	 return @v_id;
END
;;
delimiter ;

-- ----------------------------
-- Function structure for funGenerateID
-- ----------------------------
DROP FUNCTION IF EXISTS `funGenerateID`;
delimiter ;;
CREATE FUNCTION `funGenerateID`(i_process_date date)
 RETURNS bigint(20)
label_pro: BEGIN
   set @v_id = 0;  
   if not exists(select 1 from generate_id where process_date = i_process_date) then 
   		insert into generate_id select i_process_date,1;
   end if; 
   select ifnull(generate_id,0) into @v_id from generate_id where process_date = i_process_date;
   update generate_id set generate_id =ifnull(generate_id,0) +1 where process_date = i_process_date;
	 return @v_id;
END
;;
delimiter ;

-- ----------------------------
-- Function structure for funIntervalNotHolidayForAllMarket
-- ----------------------------
DROP FUNCTION IF EXISTS `funIntervalNotHolidayForAllMarket`;
delimiter ;;
CREATE FUNCTION `funIntervalNotHolidayForAllMarket`(i_trade_date date,  -- 给定的交易日 
  i_days       int)
 RETURNS date
label_pro: BEGIN
    declare v_times int default 0 ; 
    declare v_date date default NULL; 
    set v_date = i_trade_date; 
    while v_times < i_days do 
        select min(calendar_day) into v_date from calendar where   calendar_day>i_trade_date and holiday <> 'Y';
        set v_times = v_times+1;
    end while; 
    return v_date; 
END
;;
delimiter ;

-- ----------------------------
-- Function structure for funIntervalNotWeekendDay
-- ----------------------------
DROP FUNCTION IF EXISTS `funIntervalNotWeekendDay`;
delimiter ;;
CREATE FUNCTION `funIntervalNotWeekendDay`(i_market_id  int ,  
  i_trade_date date,  
  i_days       int)
 RETURNS date
label_pro: BEGIN
    declare v_times int default 0 ; 
    declare v_date date default NULL; 
    set v_date = i_trade_date; 
    while v_times < i_days do 
        select min(calendar_day) into v_date from calendar where market_id = i_market_id and  calendar_day>i_trade_date and date_format(calendar_day,'%w') not in('0','6');
        set v_times = v_times+1;
    end while; 
    return v_date; 
END
;;
delimiter ;

-- ----------------------------
-- Function structure for funIntervalSettleDay
-- ----------------------------
DROP FUNCTION IF EXISTS `funIntervalSettleDay`;
delimiter ;;
CREATE FUNCTION `funIntervalSettleDay`(i_market_id  int ,  
  i_trade_date date,  
  i_days       int)
 RETURNS date
label_pro: BEGIN
    declare v_times int default 0 ; 
    declare v_date date default NULL; 
    set v_date = i_trade_date; 
    while v_times < i_days do 
        select min(calendar_day) into v_date from calendar where market_id = i_market_id and calendar_day>v_date and holiday in ('N','S'); 
        set v_times = v_times+1;
    end while; 
    return v_date; 
END
;;
delimiter ;

-- ----------------------------
-- Function structure for funIntervalTradingDay
-- ----------------------------
DROP FUNCTION IF EXISTS `funIntervalTradingDay`;
delimiter ;;
CREATE FUNCTION `funIntervalTradingDay`(i_market_id  int ,  
  i_trade_date date,  
  i_days       int)
 RETURNS date
label_pro: BEGIN
    declare v_times int default 0 ; 
    declare v_date date default NULL; 
    set v_date = i_trade_date; 
    while v_times < i_days do 
        select min(calendar_day) into v_date from calendar where market_id = i_market_id and calendar_day>v_date and holiday in ('N','H'); 
        set v_times = v_times+1;
    end while; 
    return v_date; 
END
;;
delimiter ;

-- ----------------------------
-- Function structure for funMarketID
-- ----------------------------
DROP FUNCTION IF EXISTS `funMarketID`;
delimiter ;;
CREATE FUNCTION `funMarketID`(i_market_id  int)
 RETURNS varchar(8) CHARSET utf8
label_pro: BEGIN
    declare v_market_id varchar(8) default '';  
    
    set v_market_id = case i_market_id when 1 then 'HK' when 2 then 'US' when 4 then 'SSE' when 8 then 'SZSE' when 16 then 'USOTC' else '' end;
    
    return v_market_id; 
END
;;
delimiter ;

-- ----------------------------
-- Function structure for funMAX
-- ----------------------------
DROP FUNCTION IF EXISTS `funMAX`;
delimiter ;;
CREATE FUNCTION `funMAX`(i_left decimal(21,6),
    i_right decimal(21,6))
 RETURNS decimal(21,6)
label_pro: BEGIN
    return if(i_left>i_right,i_left,i_right);
END
;;
delimiter ;

-- ----------------------------
-- Function structure for funMIN
-- ----------------------------
DROP FUNCTION IF EXISTS `funMIN`;
delimiter ;;
CREATE FUNCTION `funMIN`(i_left decimal(21,6),
    i_right decimal(21,6))
 RETURNS decimal(21,6)
label_pro: BEGIN
    return if(i_left<i_right,i_left,i_right);
END
;;
delimiter ;

-- ----------------------------
-- Function structure for funOptionSymbolFromOMS
-- ----------------------------
DROP FUNCTION IF EXISTS `funOptionSymbolFromOMS`;
delimiter ;;
CREATE FUNCTION `funOptionSymbolFromOMS`(i_oms_opt_symbol VARCHAR(32))
 RETURNS varchar(32) CHARSET utf8
BEGIN
    -- 'GE@20210115C11.5' => 'GE    20210115C000011500'
    DECLARE v_at_pos  INT;
    DECLARE v_CP_pos  INT;
    DECLARE v_dot_pos INT;
    DECLARE v_CP_flag CHAR(1);
    DECLARE v_symbol VARCHAR(32);
    DECLARE v_tmpstr VARCHAR(32);
    DECLARE v_yyyymmdd VARCHAR(16);
    DECLARE v_pxstr VARCHAR(16);
    DECLARE v_int_part VARCHAR(4) DEFAULT '';
    DECLARE v_dec_part VARCHAR(4) DEFAULT '';
    DECLARE v_destination VARCHAR(32);

    IF LENGTH(i_oms_opt_symbol) < 10 THEN -- LENGTH('@20210115C') = 10
        RETURN i_oms_opt_symbol;
    END IF;

    SET v_at_pos = LOCATE('@', i_oms_opt_symbol);
    IF v_at_pos = 0 THEN
        RETURN i_oms_opt_symbol;
    END IF;

    SET v_symbol =      LEFT(i_oms_opt_symbol, v_at_pos - 1); -- (GE@20210115C11.5)=>(GE)
    SET v_tmpstr = SUBSTRING(i_oms_opt_symbol, v_at_pos + 1); -- (GE@20210115C11.5)=>(20210115C11.5)

    SET v_CP_pos = LOCATE('C', v_tmpstr);
    IF v_CP_pos = 0 THEN
        SET v_CP_pos = LOCATE('P', v_tmpstr);
        SET v_CP_flag = 'P';
    ELSE
        SET v_CP_flag = 'C';
    END IF;
    IF v_CP_pos = 0 THEN
        RETURN i_oms_opt_symbol;
    END IF;

    SET v_yyyymmdd =   LEFT(v_tmpstr, v_CP_pos - 1); -- (GE@20210115C11.5)=>(20210115)
    SET v_pxstr = SUBSTRING(v_tmpstr, v_CP_pos + 1); -- (GE@20210115C11.5)=>(11.5)

    IF LENGTH(v_yyyymmdd) <> 8 THEN
        RETURN i_oms_opt_symbol;
    END IF;

    SET v_dot_pos = LOCATE('.', v_pxstr);
    IF v_dot_pos = 0 THEN
        SET v_int_part = v_pxstr;
    ELSE
        SET v_int_part =      LEFT(v_pxstr, v_dot_pos - 1);
        SET v_dec_part = SUBSTRING(v_pxstr, v_dot_pos + 1);
    END IF;

    SET v_destination = CONCAT( RPAD(v_symbol, 6, ' '), v_yyyymmdd, v_CP_flag, LPAD(v_int_part, 5, '0'), RPAD(v_dec_part, 3, '0'));
    RETURN v_destination;
END
;;
delimiter ;

-- ----------------------------
-- Function structure for funProductFlowType
-- ----------------------------
DROP FUNCTION IF EXISTS `funProductFlowType`;
delimiter ;;
CREATE FUNCTION `funProductFlowType`(i_remark  varchar(128))
 RETURNS int(11)
label_pro: BEGIN
    declare v_type int(11) default 0;  
    
    set v_type = case when i_remark like 'CorpAction%' then 4                     -- 公司行动 (含送红股，并股拆股，代码转换，上市公司回购)
                      when i_remark like '%IPO%' then 3                            -- IPO 中签派发
                      when i_remark like '%Placing Order%' then 3 
                      when i_remark like '转出%' then 2                        -- 客人发起的出仓
                      when i_remark like '转入%' then 1                        -- 客人发起的入仓
                      when i_remark like '%申购转入%' then 5                        --  货币基金申购
                      when i_remark like '%赎回转出%' then 6                        -- 货币基金赎回
                      else 0                                                       -- 其他类型
                      end;
    
    return v_type; 
END
;;
delimiter ;

-- ----------------------------
-- Function structure for funRIntervalTradingDay
-- ----------------------------
DROP FUNCTION IF EXISTS `funRIntervalTradingDay`;
delimiter ;;
CREATE FUNCTION `funRIntervalTradingDay`(i_market_id  int ,  
  i_trade_date date,  
  i_days       int)
 RETURNS date
label_pro: BEGIN
    declare v_times int default 0 ; 
    declare v_date date default NULL; 
    set v_date = i_trade_date; 
    while v_times < i_days do 
        select max(calendar_day) into v_date from calendar where market_id = i_market_id and calendar_day<v_date and holiday  <> 'Y'; 
        set v_times = v_times+1;
    end while; 
    return v_date; 
END
;;
delimiter ;

-- ----------------------------
-- Function structure for ljust
-- ----------------------------
DROP FUNCTION IF EXISTS `ljust`;
delimiter ;;
CREATE FUNCTION `ljust`(str varchar(64), 
    len  int, 
    filler varchar(64))
 RETURNS varchar(64) CHARSET utf8
label_pro: BEGIN
    return left(concat(str,repeat(filler,len - length(str))),len);
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proAccountTagSetting
-- ----------------------------
DROP PROCEDURE IF EXISTS `proAccountTagSetting`;
delimiter ;;
CREATE PROCEDURE `proAccountTagSetting`(IN  i_account_id  VARCHAR(64),
    IN  i_account_tag VARCHAR(16),
    OUT o_ret_code    INT,
    OUT o_ret_msg     VARCHAR(256))
label: BEGIN
DECLARE procedure_version VARCHAR(16) DEFAULT "1.0.2";
DECLARE `v_tag` VARCHAR(16);

IF IFNULL(i_account_tag,'') IN ('','0') THEN
    SET v_tag = 'N';
ELSE
    SET v_tag = 'Y';
END IF;

IF NOT EXISTS (SELECT DISTINCT 1 FROM jcbms.account_charge_rule WHERE account_id=i_account_id AND formula_type='CHRG' AND charge_code='US_JC_FEE:US') THEN
    INSERT INTO jcbms.account_charge_rule(  account_id,   charge_code,formula_type,formula_code,waive,update_time)
                                   VALUES(i_account_id,'US_JC_FEE:US',      'CHRG',          '',v_tag,      NOW());
ELSE
    IF NOT( v_tag='N' AND EXISTS(SELECT 1 FROM jcbms.capital_account WHERE account_id=i_account_id AND us_jcfee_waive='Y') ) THEN
        UPDATE jcbms.account_charge_rule SET waive=v_tag, update_time=NOW() WHERE account_id=i_account_id AND formula_type='CHRG' AND charge_code='US_JC_FEE:US';
    END IF;
END IF;

END label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proAfterUpdateAccountType
-- ----------------------------
DROP PROCEDURE IF EXISTS `proAfterUpdateAccountType`;
delimiter ;;
CREATE PROCEDURE `proAfterUpdateAccountType`(in  i_account_id varchar(16), 
    in  i_account_type varchar(16), 
    out o_ret_code int, 
    out o_ret_msg varchar(64))
label:begin 
    declare v_process_date date default NULL; 

    select buss_date into v_process_date from sys_info; 
    if v_process_date is NULL then 
        set o_ret_code = 1; 
        set o_ret_msg ="process_date not set up"; 
        leave label; 
    end if; 

    
    update account_balance a 
    set a.account_type = i_account_type
    where a.process_date = v_process_date and  a.account_id = i_account_id; 


    
    update account_position a 
    set a.account_type = i_account_type
    where a.process_date = v_process_date and  a.account_id = i_account_id; 
    
    
    update unsettled_position a 
    set a.account_type = i_account_type
    where a.account_id = i_account_id; 

    
    update product_flow a 
    set a.account_type = i_account_type
    where a.settle_date >= v_process_date and a.settle_date <> a.process_date and  a.account_id = i_account_id; 

    
    update account_interest_adj a 
    set a.account_type = i_account_type
    where a.process_date = v_process_date and  a.account_id = i_account_id;
    
    update account_position a
    inner join account_type_custodian b on a.market_id = b.market_id and a.account_type = b.account_type
	set a.custodian_code = b.custodian_code,
		 a.custodian_account = b.custodian_account
    where a.process_date = v_process_date and a.account_id = i_account_id and a.account_type = i_account_type;
    
    update unsettled_position a
    inner join account_type_custodian b on a.market_id = b.market_id and a.account_type = b.account_type
	set a.custodian_code = b.custodian_code,
		 a.custodian_account = b.custodian_account
    where a.account_id = i_account_id and a.account_type = i_account_type;

    
    update product_flow a
    inner join account_type_custodian b on a.market_id = b.market_id and a.account_type = b.account_type
	set a.custodian_code = b.custodian_code,
		 a.custodian_account = b.custodian_account
    where a.settle_date >= v_process_date and a.settle_date <> a.process_date and  a.account_id = i_account_id and a.account_type = i_account_type;

    UPDATE borrow_fee_flow 
    set account_type = i_account_type
    where process_date = v_process_date and account_id = i_account_id; 

    set o_ret_code = 0;
    set o_ret_msg = "Success";
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proASharesMarketTradeSummary
-- ----------------------------
DROP PROCEDURE IF EXISTS `proASharesMarketTradeSummary`;
delimiter ;;
CREATE PROCEDURE `proASharesMarketTradeSummary`(in i_process_date date)
label:begin
    

    
    drop table if exists tmp_charges; 
    create temporary table tmp_charges
    (
        account_type int, 
        buy_sell int, 
        currency int,
        seller_stamp decimal(30,10),
        handling_fee decimal(30,10), 
        securities_management_fee decimal(30,10), 
        transfer_fee decimal(30,10), 
        others decimal(30,10), 
        seller_stamp_hkd decimal(30,10),
        handling_fee_hkd decimal(30,10), 
        securities_management_fee_hkd decimal(30,10), 
        transfer_fee_hkd decimal(30,10), 
        others_hkd decimal(30,10), 
        index idx1(account_type, buy_sell,currency)
    ); 

    insert into tmp_charges
    (
        account_type, 
        buy_sell, 
        currency, 
        seller_stamp, 
        handling_fee,
        securities_management_fee, 
        transfer_fee, 
        others
    )
    select 
        a.account_type,
        a.buy_sell,
        b.currency,
        sum(round(case when b.charge_code in('STAMP DUTY:SHA','STAMP DUTY:SZA') then b.charges else 0 end  ,2)) as seller_stamp,
        sum(round(case when b.charge_code in('HANDLING_FEE_SHA:SHA','HANDLING_FEE_SZA:SZA') then b.charges else 0 end  ,2)) as handling_fee,
        sum(round(case when b.charge_code in('SMF_FEE_SHA:SHA','SMF_FEE_SZA:SZA') then b.charges else 0 end  ,2)) as management_fee,
        sum(round(case when b.charge_code in('TRANSFER_FEE:SHA','TRANSFER_FEE:SZA') then b.charges else 0 end  ,2)) as transfer_fee,
        sum(round(case when b.charge_code not in ('STAMP DUTY:SHA','STAMP DUTY:SZA','HANDLING_FEE_SHA:SHA','HANDLING_FEE_SZA:SZA','SMF_FEE_SHA:SHA','SMF_FEE_SZA:SZA','TRANSFER_FEE:SHA','TRANSFER_FEE:SZA','SSE_DEFAULT_COMMISSION','SZSE_DEFAULT_COMMISSION') then b.charges else 0 end  ,2)) as others
    from account_trade a 
    inner join account_charge b on a.trade_id = b.external_id
    where a.process_date = i_process_date and a.market_id in('4','8')
    group by a.account_type,a.buy_sell, b.currency;

    
    update tmp_charges a
    left join currency b on a.currency = b.currency 
    left join currency_history c on i_process_date = c.process_date and a.currency = c.currency
    set a.seller_stamp_hkd = round(ifnull(c.exchange_rate,b.exchange_rate)*a.seller_stamp,2),
        a.handling_fee_hkd = round(ifnull(c.exchange_rate,b.exchange_rate)*a.handling_fee,2),
        a.securities_management_fee_hkd = round(ifnull(c.exchange_rate,b.exchange_rate)*a.securities_management_fee,2),
        a.transfer_fee_hkd = round(ifnull(c.exchange_rate,b.exchange_rate)*a.transfer_fee,2),
        a.others_hkd = round(ifnull(c.exchange_rate,b.exchange_rate)*a.others,2);

    drop table if exists tmp_rpt; 
    create temporary table tmp_rpt
    (
        account_type int, 
        buy_sell int,
        currency int,
        broker_payable_receivable decimal(30,10), 
        commission_income decimal(30,10), 
        ae_commission decimal(30,10), 
        net_income decimal(30,10),
        seller_stamp decimal(30,10),
        handling_fee decimal(30,10), 
        securities_management_fee decimal(30,10), 
        transfer_fee decimal(30,10), 
        others decimal(30,10), 
        client_receivalbe_payable decimal(30,10), 
        broker_payable_receivable_hkd decimal(30,10), 
        commission_income_hkd decimal(30,10), 
        ae_commission_hkd decimal(30,10), 
        net_income_hkd decimal(30,10),
        seller_stamp_hkd decimal(30,10),
        handling_fee_hkd decimal(30,10), 
        securities_management_fee_hkd decimal(30,10), 
        transfer_fee_hkd decimal(30,10), 
        others_hkd decimal(30,10), 
        client_receivalbe_payable_hkd decimal(30,10), 
        index idx(account_type, buy_sell,currency)
    );

    insert into tmp_rpt
    (
        account_type, 
        buy_sell, 
        currency,
        broker_payable_receivable, 
        commission_income, 
        ae_commission, 
        client_receivalbe_payable
    )
    select 
        a.account_type,
        buy_sell,
        b.currency,
        sum(round(a.trade_amount,2)) as broker_payable_receivable, 
        sum(round(a.commission,2)) as commission_income,
        0 as ae_income, 
        sum(round(a.net_amount,2)) as client_receivalbe_payable
    from account_trade a 
    left join currency b on a.clearing_currency = b.currency 
    left join currency_history c on a.process_date = c.process_date and a.clearing_currency = c.currency
    where a.process_date = i_process_date
    and a.market_id in ('4','8')
    group by a.account_type, buy_sell,b.currency;

    update tmp_rpt a  
    left join tmp_charges b on a.account_type = b.account_type and a.buy_sell = b.buy_sell and a.currency = b.currency
    left join currency c on a.currency = c.currency 
    left join currency_history d on i_process_date = d.process_date and a.currency = d.currency
    set a.net_income = a.commission_income+ a.ae_commission, 
        a.seller_stamp = ifnull(b.seller_stamp,0), 
        a.handling_fee = ifnull(b.handling_fee,0), 
        a.securities_management_fee = ifnull(b.securities_management_fee,0), 
        a.transfer_fee = ifnull(b.transfer_fee,0),
        a.others = ifnull(b.others,0),
        a.seller_stamp_hkd = ifnull(b.seller_stamp_hkd,0), 
        a.handling_fee_hkd = ifnull(b.handling_fee_hkd,0), 
        a.securities_management_fee_hkd = ifnull(b.securities_management_fee_hkd,0), 
        a.transfer_fee_hkd = ifnull(b.transfer_fee_hkd,0),
        a.others_hkd = ifnull(b.others_hkd,0), 
        a.broker_payable_receivable_hkd = round(ifnull(d.exchange_rate,c.exchange_rate)*a.broker_payable_receivable,2),
        a.commission_income_hkd = round(ifnull(d.exchange_rate,c.exchange_rate)*a.commission_income,2),
        a.ae_commission_hkd = round(ifnull(d.exchange_rate,c.exchange_rate)*a.ae_commission,2),
        a.client_receivalbe_payable_hkd = round(ifnull(d.exchange_rate,c.exchange_rate)*a.client_receivalbe_payable,2);

    select *from tmp_rpt;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proAutoExchange
-- ----------------------------
DROP PROCEDURE IF EXISTS `proAutoExchange`;
delimiter ;;
CREATE PROCEDURE `proAutoExchange`(IN i_process_date date,
    In i_ignoreAccData varchar(1024),
    In i_input_user char(32), 
    In i_input_time datetime,
    OUT o_ret_code INT, 
    OUt o_ret_msg VARCHAR(64))
label: BEGIN
    declare v_process_date date; 
    declare v_account_id varchar(16);
    declare v_account_type int(11);
    declare v_currency_in int(1);
    declare v_currency_out int(1);
    declare v_exchange_rate decimal(30,10);
    declare remark_currency_out varchar(3);
    declare remark_currency_in varchar(3);
    declare v_amount_out decimal(30,10);
    declare v_amount_in decimal(30,10);
    
    declare v_done int;
    DECLARE v_error int;
        
    DECLARE cur_exchange CURSOR FOR
    SELECT
        a.process_date,a.account_id,b.account_type,a.currency_out,a.currency_in,a.exchange_rate,a.amount_out,a.amount_in
    FROM auto_exchange a
    inner join account_balance b on a.process_date = b.process_date and a.account_id = b.account_id and a.currency_in = b.currency
    where a.process_date = i_process_date and ifnull(currency_out,'') <> '' and a.account_id not in (select account_id from tmp_ignore_acct) order by a.id; 

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1; 

    set o_ret_code = 0, o_ret_msg ="Success";

    start transaction; 

    select buss_date  into v_process_date from sys_info; 

    if i_process_date is NULL then 
        set i_process_date = v_process_date;
    end if; 

    if i_process_date <> v_process_date then 
        set o_ret_code = 1, o_ret_msg ="请选择正确日期";
        LEAVE label;
    end if;

    if exists(select 1 from day_end_process where operation = 'AutoExchange' and status = '已处理') then 
        set o_ret_code = 0, o_ret_msg ="已处理";
        LEAVE label;
    end if;

    if i_ignoreAccData is not null then 
        set i_ignoreAccData = replace(i_ignoreAccData, '\"', '');

        drop temporary table if exists tmp_acct;
        create TEMPORARY table tmp_acct(account_id varchar(16));
        insert into tmp_acct
        SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(i_ignoreAccData,',',ID),',',-1) FROM dict WHERE ID <= (LENGTH(i_ignoreAccData) - LENGTH(REPLACE(i_ignoreAccData,',','')) + 1);

        truncate table tmp_ignore_acct;

        insert into tmp_ignore_acct
        select account_id from auto_exchange where process_date = i_process_date and account_id in (select account_id from tmp_acct) group by account_id;

        update jcbms.auto_exchange a 
        inner join jcbms.account_balance b on b.process_date = a.process_date and b.account_id = a.account_id and b.currency = a.currency_in
        set a.debit_balance = b.settle_balance,
            a.currency_out = NULL,
            a.exchange_rate = 0,
            a.amount_out = 0,
            a.amount_in = 0
        where a.process_date = i_process_date and a.account_id in (select account_id from tmp_ignore_acct);

        -- SET @sql = CONCAT('insert into tmp_ignore_acct ',
        --                   'select account_id from auto_exchange where process_date = \'', i_process_date, '\' and account_id in (\'', i_ignoreAccData,'\');');
        -- PREPARE stmt FROM @sql;
        -- EXECUTE stmt; 

        -- SET @sql = CONCAT('update jcbms.auto_exchange a  ',
        --                   'inner join jcbms.account_balance b on b.process_date = a.process_date and b.account_id = a.account_id and b.currency = a.currency_in '
        --                   'set a.debit_balance = b.settle_balance ',
        --                   ',a.currency_out = NULL ',
        --                   ',a.exchange_rate = 0 ',
        --                   ',a.amount_out = 0 ',
        --                   ',a.amount_in = 0 '
        --                   'where a.process_date = \'', i_process_date, '\' and a.account_id in (', i_ignoreAccData,');');
        -- PREPARE stmt FROM @sql;
        -- EXECUTE stmt; 
        
    end if;
    -- 遍历欠款信息
    open cur_exchange; 
        set v_done = 0; 
        fetch cur_exchange into v_process_date,v_account_id,v_account_type,v_currency_out,v_currency_in,v_exchange_rate,v_amount_out,v_amount_in; 
        while v_done <> 1 do 
            -- 转换币种格式
            set remark_currency_in = case v_currency_in when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end;
            set remark_currency_out = case v_currency_out when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end;
                    
            -- 被换汇币种出金
            call proCashOut (v_process_date,v_account_id,v_account_type,v_currency_out,v_amount_out,1,
                CONCAT('conversion; from ',remark_currency_out,' to ',remark_currency_in,'@',v_exchange_rate),
                'remark2','','','','','','','','',0,NULL, NULL,NULL,NULL,NULL, i_input_user,now(),o_ret_code,o_ret_msg);
            IF o_ret_code <> 0 THEN
                select v_process_date,v_account_id,v_account_type,v_currency_out,v_currency_in,v_exchange_rate,v_amount_out,v_amount_in;
                ROLLBACK;
                LEAVE label;
            END IF;
            -- 换汇币种入金
            call proCashIn (v_process_date,v_account_id,v_account_type,v_currency_in,v_amount_in,1,
                CONCAT('conversion; from ',remark_currency_out,' to ',remark_currency_in,'@',v_exchange_rate),
                'remark2','','','','','','','','',0,NULL, NULL,NULL,NULL,NULL, i_input_user,now(),o_ret_code,o_ret_msg);
            IF o_ret_code <> 0 THEN
                ROLLBACK;
                LEAVE label;
            END IF;

            set v_done = 0; 
            fetch cur_exchange into v_process_date,v_account_id,v_account_type,v_currency_out,v_currency_in,v_exchange_rate,v_amount_out,v_amount_in; 
        end while; 
    close cur_exchange; 

    update day_end_process
    set status = '已处理'
    where operation = 'AutoExchange';

  commit; 
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proBackup
-- ----------------------------
DROP PROCEDURE IF EXISTS `proBackup`;
delimiter ;;
CREATE PROCEDURE `proBackup`(OUT o_ret_code int, 
  OUT o_ret_msg varchar(64))
label:begin
    
    declare v_buss_date date default NULL;  
    declare v_last_buss_date date default NULL;

    set o_ret_code = 0, o_ret_msg = "Success";
    start transaction ; 

    select last_buss_date,buss_date into v_last_buss_date,v_buss_date from sys_info; 
    
    if v_buss_date is NULL then 
        set o_ret_code = 1, o_ret_msg = "Bussness date not setting up"; 
        rollback; 
        leave label; 
    end if;

    INSERT INTO currency_history
    (
        process_date,
        currency,
        currency_desc, 
        prime_rate, 
        saving_rate, 
        exchange_rate,
        debit_formula_type, 
        debit_formula_code,
        credit_formula_type, 
        credit_formula_code, 
        base, 
        update_user, 
        update_time
    )
    select 
        v_last_buss_date,
        currency,
        currency_desc, 
        prime_rate, 
        saving_rate, 
        exchange_rate,
        debit_formula_type, 
        debit_formula_code,
        credit_formula_type, 
        credit_formula_code, 
        base, 
        update_user,
        now()
    from currency;

    INSERT INTO currency_ratio_history
    (
        process_date,
        currency_from,
        currency_to,
        rate_molecular,
        rate_denominator,
        update_user,
        update_time
    )
    select 
        v_last_buss_date,
        currency_from,
        currency_to,
        rate_molecular,
        rate_denominator,
        update_user,
        now()
    from currency_ratio;

    set o_ret_code = 0, o_ret_msg = "Success";

    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proBalance
-- ----------------------------
DROP PROCEDURE IF EXISTS `proBalance`;
delimiter ;;
CREATE PROCEDURE `proBalance`(in i_market_id int,
   in i_product_type int,
   OUT o_ret_code int,
   OUT o_ret_msg char(128))
label:begin
    declare v_process_date date;

    
    set o_ret_code = 0; 
    set o_ret_msg = "更新余额信息完成"; 
    
    select buss_date into v_process_date from sys_info;

    -- 交易影响 BEGIN
    drop temporary table IF EXISTS tmp_trade_summary;
    create temporary table  tmp_trade_summary(
          account_id char(16),
          account_type int default 0,
          currency  int default 0,
          trade_amount     decimal(30,10),  
          net_amount       decimal(30,10),
          charges          decimal(30, 10),
          processed  char(1) default 'N',
          index idx(account_id, account_type, currency)
    ); 

    -- 汇总成交
    insert into tmp_trade_summary(
        account_id,
        account_type,
        currency,
        trade_amount,
        net_amount,
        charges,
        processed
      )
    select
        a.account_id,
        a.account_type,
        a.clearing_currency,
        sum(a.trade_amount * case a.buy_sell when 1 then -1 when 2 then 1 end),
        sum(a.net_amount * case a.buy_sell when 1 then -1 when 2 then 1 end),
        sum(ifnull(a.charges,0)+ifnull(a.commission,0)),
        'N'
    from tmp_account_trade a 
    group by a.account_id, a.account_type, a.clearing_currency;

    -- 创建余额信息
    INSERT
    INTO account_balance
    (
        process_date,
        account_id,
        account_type,
        currency
    )
    SELECT
        v_process_date,
        t.account_id, 
        t.account_type, 
        t.currency
    from  tmp_trade_summary t 
    where not  exists(select 1 from account_balance a  where a.process_date = v_process_date and a.account_id = t.account_id and a.account_type = t.account_type and a.currency = t.currency);

    -- 更新交易带来的余额变动
    update account_balance a, tmp_trade_summary b
        set   a.trade_balance = a.trade_balance+ ifnull(b.net_amount,0) ,
              a.balance_avail = a.balance_avail + ifnull(b.net_amount,0),
              a.balance_extract = a.balance_extract + funMAX(0, ifnull(b.trade_amount,0)) - ifnull(b.charges, 0),
              a.charges =a.charges +  b.charges,
              b.processed = 'Y'
        where a.account_id = b.account_id and
              a.account_type = b.account_type and
              a.currency = b.currency and
              a.process_date = v_process_date;
    drop temporary table if exists tmp_trade_summary; 
    -- 交易影响 END

   -- 交收金额，待交收金额 BEGIN
   -- 生成待交收持仓表
   drop temporary table if exists tmp_unsettled_position; 
   create temporary table tmp_unsettled_position
   (
       account_id varchar(16), 
       account_type int, 
       currency int,
       quantity decimal(30,10), 
       amount  decimal(30,10),
       amount_to_pay decimal(30,10), 
       amount_to_receive decimal(30,10),
       index idx(account_id,account_type,currency)
   );
   insert into tmp_unsettled_position
   select account_id,
          account_type,
          currency,
          sum(quantity),
          sum(amount), 
          sum(if(amount<0,  -1*amount,  0) ), 
          sum(if(amount>0,  amount, 0) )
    from unsettled_position
    where 
          settle_date > v_process_date and 
          market_id = i_market_id and 
          product_type = i_product_type
          group by account_id,account_type,currency;

   -- 生成已交收持仓表 
   drop temporary table if exists tmp_settled_position; 
   create temporary table tmp_settled_position
   (
       account_id varchar(16), 
       account_type int, 
       currency int,
       quantity decimal(30,10), 
       amount  decimal(30,10),
       index idx(account_id,account_type,currency)
   );
   insert into tmp_settled_position
   select account_id,
          account_type,
          currency,
          sum(quantity),
          sum(amount)
    from unsettled_position
    where settle_date <= v_process_date and 
          market_id = i_market_id and 
          product_type = i_product_type
          group by account_id,account_type,currency;

    -- 创建余额信息
    INSERT
    INTO account_balance
    (
        process_date,
        account_id,
        account_type,
        currency
    )
    SELECT
        v_process_date,
        t.account_id, 
        t.account_type, 
        t.currency
    from  tmp_unsettled_position t 
    where not  exists(select 1 from account_balance a  where a.process_date = v_process_date and a.account_id = t.account_id and a.account_type = t.account_type and a.currency = t.currency);

    INSERT
    INTO account_balance
    (
        process_date,
        account_id,
        account_type,
        currency
    )
    SELECT
        v_process_date,
        t.account_id, 
        t.account_type, 
        t.currency
    from  tmp_settled_position t 
    where not  exists(select 1 from account_balance a  where a.process_date = v_process_date and a.account_id = t.account_id and a.account_type = t.account_type and a.currency = t.currency);


   -- 更新余额信息交收字段和待交收字段
   update account_balance a 
     left join tmp_unsettled_position b on a.account_id = b.account_id  and a.account_type = b.account_type and a.currency = b.currency 
     left join tmp_settled_position c on a.account_id = c.account_id and a.account_type = c.account_type and a.currency = c.currency 
     set  a.unsettled_amount = a.unsettled_amount +  /*round(ifnull(b.amount,0),2)*/ + ifnull(b.amount,0),
          a.settle_balance = round(a.settle_balance + ifnull(c.amount,0),2), 
          a.unsettled_to_pay = a.unsettled_to_pay +ifnull(b.amount_to_pay,0), 
          a.unsettled_to_receive = a.unsettled_to_receive +ifnull(b.amount_to_receive,0)
    where a.process_date = v_process_date;


    -- 交收金额 待交收金额  END

    -- 市值 BEGIN
    drop temporary table if exists tmp_market_value; 
    create temporary table tmp_market_value
    (
        account_id varchar(16), 
        account_type int, 
        currency  int,
        market_value decimal(30,10),
        long_market_value decimal(30,10), 
        short_market_value decimal(30,10),
        index idx1(account_id,account_type,currency)
    ); 

    insert into tmp_market_value
    select account_id,
           account_type,
           currency, 
           sum(ifnull(market_value,0)), 
           sum(if(ifnull(market_value,0)>0, ifnull(market_value,0), 0) ),
           sum(if(ifnull(market_value,0)<0, ifnull(market_value,0), 0) )
    from account_position 
    where process_date = v_process_date and market_id = i_market_id and product_type = i_product_type 
    group by account_id,account_type,currency; 

    INSERT
    INTO account_balance
    (
        process_date,
        account_id,
        account_type,
        currency
    )
    SELECT
        v_process_date,
        t.account_id, 
        t.account_type, 
        t.currency
    from  tmp_market_value t 
    where not  exists(select 1 from account_balance a  where a.process_date = v_process_date and a.account_id = t.account_id and a.account_type = t.account_type and a.currency = t.currency);


    update account_balance a
    inner join tmp_market_value b on a.account_id = b.account_id and a.account_type = b.account_type and a.currency = b.currency
    set a.market_value = a.market_value+b.market_value, 
        a.long_market_value  = a.long_market_value + b.long_market_value, 
        a.short_market_value = a.short_market_value + b.short_market_value
    where a.process_date = v_process_date;
    -- 市值 END

    -- ipo_frozen 
    drop temporary table if exists ipo_frozen;
    create temporary table ipo_frozen
    (
        account_id varchar(16), 
        currency int, 
        amount_before_close decimal(30,10), 
        amount_before_allot decimal(30,10),
        placing_amount_before_allot decimal(30,10),
        index idx(account_id, currency)
    );

    insert into ipo_frozen
    select 
    t1.account_id,
    t1.currency as currency,
    ifnull(sum(if(ifnull(t1.sub_status,'') = '1',
                  case when ifnull(t1.app_posted,'') = 'Y' then  t1.amount-ifnull(t1.loan_amount,0) /*+t1.charge+t1.loan_charge*/ else 0 end,
                  0)
               ),0)  as amount_before_close,
    ifnull(sum(if(ifnull(t1.sub_status,'') = '1',
                  case when ifnull(t1.app_posted,'') = 'Y' then  t1.amount-ifnull(t1.loan_amount,0) else  t1.amount-ifnull(t1.loan_amount,0) +t1.charge+t1.loan_charge end,
                  0)
               ),0)  as amount_before_allot,
    ifnull(sum(if(ifnull(t1.sub_status,'') = '2',
                 case when ifnull(t1.app_posted,'') = 'Y' then  t1.amount-ifnull(t1.loan_amount,0) else  t1.amount-ifnull(t1.loan_amount,0) +t1.charge+t1.loan_charge end,
                 0)
               ),0) as placing_amount_before_allot
    from product_ipo_app t1  
    left join product_ipo_announcement t2 on t2.ipo_id = t1.ipo_id
    inner join product t3 on i_market_id = t3.list_market_id and t1.product_id = t3.product_id and t3.product_type = i_product_type
    where ifnull(t1.refund_posted,'') <> 'Y'
    group by t1.account_id,t1.currency;


    -- 更新ipo冻结
    update account_balance a  
    left join ipo_frozen b on  a.account_id = b.account_id  and  a.currency = b.currency
    set a.ipo_frozen_before_close = a.ipo_frozen_before_close + ifnull(b.amount_before_close,0),
        a.ipo_frozen_before_allot = a.ipo_frozen_before_allot + ifnull(b.amount_before_allot,0),
        a.placing_amount_before_allot = a.placing_amount_before_allot + ifnull(b.placing_amount_before_allot,0)
    where a.process_date = v_process_date;


    -- 如果没有数据需要单独插入
    INSERT
    INTO account_balance
    (
        process_date,
        account_id,
        account_type,
        currency,
        ipo_frozen_before_close,
        ipo_frozen_before_allot
  
    )
    SELECT
        v_process_date,
        t.account_id, 
        ifnull(b.account_type,-1),
        t.currency,
        amount_before_close,
        amount_before_allot
    from  ipo_frozen t 
    left join capital_account b on t.account_id = b.account_id
    where not  exists(select 1 from account_balance a  where a.process_date = v_process_date and a.account_id = t.account_id  and a.currency = t.currency);

    -- 最终的计算
    update account_balance a
    set 
        -- settle_balance就是交收后的余额，在手资金，trade_balance就是交收+未交收
        -- 客户权益，代表着如果客户把所有的仓都变现后，可以获取多少钱；（frozen_amount里面之前是包含利息的，现在既然单独了字段，就改成不包含利息）
        a.equity_balance = a.trade_balance  + a.unrealized_pnl + market_value  - accrued_interest + accrued_interest_credit,
        -- 现金结余 - 负债利息 - 冻结资金 - 做空市值  - IPO冻结(截止日前) - 配售冻结(配售是在派发日才扣款)
        a.balance_avail =   a.trade_balance + funMin(accrued_interest_credit- a.accrued_interest,0) - a.frozen_amount + 2*a.short_market_value - (a.ipo_frozen_before_allot - a.ipo_frozen_before_close) - a.placing_amount_before_allot  ,
        -- 在手资金 - 待付出资金 -负债利息  - 冻结资金 - 做空市值 - IPO冻结(截止日前）- 配售冻结(配售是在派发日前才扣款)
        a.balance_extract = a.settle_balance - a.unsettled_to_pay + funMin(accrued_interest_credit- a.accrued_interest,0) - a.frozen_amount + 2*a.short_market_value - (a.ipo_frozen_before_allot - a.ipo_frozen_before_close) - a.placing_amount_before_allot  ,
        -- 用这个来算现在总共欠了多少款，需要追加保证金，或者入金
        -- 也就是说客户现在权益在减去冻结的资金（如保证金等，冻结资金等）如果为负，那就代表危险了要入金了
        a.equity = a.equity_balance  - a.margin_amt - a.frozen_amount
    where process_date = v_process_date; 

/*  注释掉，不明白这个的含义
    update account_balance a 
     left join (select account_id, account_type, currency,sum(amount) as amount from unsettled_position  where market_id = i_market_id and product_type = i_product_type group by account_id,currency) b on a.account_id = b.account_id and a.currency = b.currency and a.account_type = b.account_type
     left join (select settle_date,account_id, account_type, currency,sum(amount) as amount from settled_position where market_id = i_market_id and product_type = i_product_type group by settle_date,account_id,currency) c on c.settle_date =v_process_date and a.account_id = c.account_id and a.currency = c.currency and a.currency = c.currency
     set  a.trade_balance = case ifnull(b.amount,0) when 0 then a.trade_balance else round(a.settle_balance + ifnull(b.amount,0), 2) end
    where a.process_date = v_process_date;
*/

    delete from unsettled_position  where settle_date <= v_process_date and market_id = i_market_id and product_type = i_product_type; 

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proBatchCashInOut
-- ----------------------------
DROP PROCEDURE IF EXISTS `proBatchCashInOut`;
delimiter ;;
CREATE PROCEDURE `proBatchCashInOut`(OUT o_ret_code int,
  OUT o_ret_msg  char(128))
label:begin
    declare v_done int default 0; 
    declare v_id bigint(11);
    declare v_process_date date;
    declare v_account_id char(16);
    declare v_account_type varchar(16);
    declare v_currency int(11);
    declare v_amount decimal(21,6);
    declare v_way char(32);
    declare v_purpose int(11);
    declare v_remark char(128);
    declare v_remark2 varchar(128);
    declare v_pay_bank_id varchar(32);
    declare v_pay_check_no char(16);
    declare v_pay_bank_account_name char(32);
    declare v_pay_bank_account_id char(32);
    declare v_rec_bank_id varchar(32);
    declare v_rec_check_no char(16);
    declare v_rec_bank_account_name char(32);
    declare v_rec_bank_account_id char(32);
    DECLARE v_gl_mapping_item_id VARCHAR(64);
    DECLARE v_reference          VARCHAR(128);
    declare v_custodian_code char(16);
    declare v_custodian_account char(16);
    declare v_update_user char(32);
    declare v_update_time datetime;

    declare cur_req cursor for
      select
            id,
            account_id,
            account_type,
            currency,
            amount,
            way,
            purpose,
            remark,
            remark2,
            pay_bank_id,
            pay_check_no,
            pay_bank_account_name,
            pay_bank_account_id,
            rec_bank_id,
            rec_check_no,
            rec_bank_account_name,
            rec_bank_account_id,
            gl_mapping_item_id,
            reference,
            custodian_code,
            custodian_account,
            update_user,
            update_time
      from bat_cash_flow; 

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done =1;

    set o_ret_code = 0, o_ret_msg = "Success";    

    truncate table CheckWarnings; 
    
    
     insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 1, 
           'batch_cash_in_out',
           '0',
           '',
           account_id,
           "account not exists",
           update_user,
           update_time  
    from bat_cash_flow t where not EXISTS (select 1 from capital_account a where t.account_id = a.account_id ); 

    if EXISTS(select 1 from CheckWarnings) then 
        set o_ret_code = 1, o_ret_msg = "Account not exists";
        leave label;
    end if; 

    start transaction; 
    
    select buss_date into v_process_date from sys_info; 
    if v_process_date is NULL then 
        set o_ret_code = 1, o_ret_msg = "Bussiness date is not  setted up";
        ROLLBACK;
        leave label;
    end if; 

    update bat_cash_flow a
    left join capital_account b on b.account_id = a.account_id
    set a.account_type = b.account_type;

    
    open cur_req; 
    set v_done = 0; 
    fetch cur_req into v_id,v_account_id,v_account_type,v_currency,v_amount,v_way,v_purpose,v_remark,v_remark2,v_pay_bank_id,v_pay_check_no,v_pay_bank_account_name,v_pay_bank_account_id,v_rec_bank_id,v_rec_check_no,v_rec_bank_account_name,v_rec_bank_account_id,v_gl_mapping_item_id,v_reference,v_custodian_code,v_custodian_account,v_update_user,v_update_time; 
    while v_done <> 1 do 
        if(v_amount >0 ) then 
            call proCashIn(v_process_date,v_account_id,v_account_type,v_currency,v_amount,1,v_remark,v_remark2,v_pay_bank_id,v_pay_check_no,v_pay_bank_account_name,v_pay_bank_account_id,v_rec_bank_id,v_rec_check_no,v_rec_bank_account_name,v_rec_bank_account_id,'','',v_gl_mapping_item_id,v_reference,v_custodian_code,v_custodian_account,v_update_user,now(),@r1,@r2); 
        elseif(v_amount <0) then 
            set v_amount = -1*v_amount;
            call proCashOut(v_process_date,v_account_id,v_account_type,v_currency,v_amount,1,v_remark,v_remark2,v_pay_bank_id,v_pay_check_no,v_pay_bank_account_name,v_pay_bank_account_id,v_rec_bank_id,v_rec_check_no,v_rec_bank_account_name,v_rec_bank_account_id,'','',v_gl_mapping_item_id,v_reference,v_custodian_code,v_custodian_account,v_update_user,now(),@r1,@r2); 
        end if; 

        if @r1 <> 0 then 
            set o_ret_code = @r1, o_ret_msg = @r2; 
            close cur_req; 
            ROLLBACK;
            leave label; 
        end if; 
        set v_done = 0; 
        set v_id = 0; 
        set v_amount = 0; 
        fetch cur_req into v_id,v_account_id,v_account_type,v_currency,v_amount,v_way,v_purpose,v_remark,v_remark2,v_pay_bank_id,v_pay_check_no,v_pay_bank_account_name,v_pay_bank_account_id,v_rec_bank_id,v_rec_check_no,v_rec_bank_account_name,v_rec_bank_account_id,v_gl_mapping_item_id,v_reference,v_custodian_code,v_custodian_account,v_update_user,v_update_time;
    end while; 
    close cur_req; 

    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proBatchCashInOut_cover
-- ----------------------------
DROP PROCEDURE IF EXISTS `proBatchCashInOut_cover`;
delimiter ;;
CREATE PROCEDURE `proBatchCashInOut_cover`(OUT o_ret_code int,
  OUT o_ret_msg  char(128))
label:begin
    declare v_done int default 0; 
    declare v_id bigint(11);
    declare v_process_date date;
    declare v_account_id char(16);
    declare v_account_type varchar(16);
    declare v_currency int(11);
    declare v_amount decimal(21,6);
    declare v_way char(32);
    declare v_purpose int(11);
    declare v_remark char(128);
    declare v_remark2 varchar(128);
    declare v_pay_bank_id varchar(32);
    declare v_pay_check_no char(16);
    declare v_pay_bank_account_name char(32);
    declare v_pay_bank_account_id char(32);
    declare v_rec_bank_id varchar(32);
    declare v_rec_check_no char(16);
    declare v_rec_bank_account_name char(32);
    declare v_rec_bank_account_id char(32);
    DECLARE v_gl_mapping_item_id VARCHAR(64);
    DECLARE v_reference          VARCHAR(128);
    declare v_custodian_code char(16);
    declare v_custodian_account char(16);
    declare v_dividend_market_id int; 
    DECLARE v_dividend_product_id varchar(32); 
    declare v_update_user char(32);
    declare v_update_time datetime;

    declare cur_req cursor for
      select
            a.id,
            a.account_id,
            c.account_type,
            a.currency,
            case when a.purpose = 1 then 1 else -1 end *a.amount,
            a.way,
            a.purpose,
            a.remark,
            a.remark2,
            a.pay_bank_id,
            a.pay_check_no,
            a.pay_bank_account_name,
            a.pay_bank_account_id,
            a.rec_bank_id,
            a.rec_check_no,
            a.rec_bank_account_name,
            a.rec_bank_account_id,
            a.gl_mapping_item_id,
            a.reference,
            case when a.dividend_product_id like '%YFD%' then '0' else a.dividend_market_id end as dividend_market_id,
            case when a.dividend_product_id like '%YFD%' then '' else a.dividend_product_id end as dividend_product_id,
            if(b.custodian_code is null, a.custodian_code, b.custodian_code),
            if(b.custodian_account is null , a.custodian_account, b.custodian_account),
            a.update_user,
            a.update_time
      from cash_flow a 
      left join account_type_custodian b on a.dividend_market_id = b.market_id and a.account_type = b.account_type	
      inner join capital_account c on a.account_id = c.account_id 
      where a.process_date  = v_process_date and a.status = 'Confirmed'
      order by a.id; 

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done =1;

    set o_ret_code = 0, o_ret_msg = "Success";    

    truncate table CheckWarnings; 
    
    
     insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 1, 
           'batch_cash_in_out',
           '0',
           '',
           account_id,
           "account not exists",
           update_user,
           update_time  
    from bat_cash_flow t where not EXISTS (select 1 from capital_account a where t.account_id = a.account_id ); 

    if EXISTS(select 1 from CheckWarnings) then 
        set o_ret_code = 1, o_ret_msg = "Account not exists";
        leave label;
    end if; 

    start transaction; 
    
    select buss_date into v_process_date from sys_info; 
    if v_process_date is NULL then 
        set o_ret_code = 1, o_ret_msg = "Bussiness date is not  setted up";
        ROLLBACK;
        leave label;
    end if; 

    update bat_cash_flow a
    left join capital_account b on b.account_id = a.account_id
        set a.account_type = b.account_type
    where a.account_type = '' or a.account_type is null;

    
    open cur_req; 
    set v_done = 0; 
    fetch cur_req into v_id,v_account_id,v_account_type,v_currency,v_amount,v_way,v_purpose,v_remark,v_remark2,v_pay_bank_id,v_pay_check_no,v_pay_bank_account_name,v_pay_bank_account_id,v_rec_bank_id,v_rec_check_no,v_rec_bank_account_name,v_rec_bank_account_id,v_gl_mapping_item_id,v_reference,v_dividend_market_id,v_dividend_product_id,v_custodian_code,v_custodian_account,v_update_user,v_update_time; 
    while v_done <> 1 do 
        if(v_amount >0 ) then 
            call procashin_cover(v_process_date,v_account_id,v_account_type,v_currency,v_amount,1,v_remark,v_remark2,v_pay_bank_id,v_pay_check_no,v_pay_bank_account_name,v_pay_bank_account_id,v_rec_bank_id,v_rec_check_no,v_rec_bank_account_name,v_rec_bank_account_id,v_dividend_market_id,v_dividend_product_id,v_gl_mapping_item_id,v_reference,v_custodian_code,v_custodian_account,v_update_user,v_update_time,@r1,@r2); 
        elseif(v_amount <0) then 
            set v_amount = -1*v_amount;
            call proCashOut_cover(v_process_date,v_account_id,v_account_type,v_currency,v_amount,1,v_remark,v_remark2,v_pay_bank_id,v_pay_check_no,v_pay_bank_account_name,v_pay_bank_account_id,v_rec_bank_id,v_rec_check_no,v_rec_bank_account_name,v_rec_bank_account_id,v_dividend_market_id,v_dividend_product_id,v_gl_mapping_item_id,v_reference,v_custodian_code,v_custodian_account,v_update_user,v_update_time,@r1,@r2); 
        end if; 

        if @r1 <> 0 then 
            set o_ret_code = @r1, o_ret_msg = @r2; 
            close cur_req; 
            ROLLBACK;
            leave label; 
        end if; 
        set v_done = 0; 
        set v_id = 0; 
        set v_amount = 0; 
        fetch cur_req into v_id,v_account_id,v_account_type,v_currency,v_amount,v_way,v_purpose,v_remark,v_remark2,v_pay_bank_id,v_pay_check_no,v_pay_bank_account_name,v_pay_bank_account_id,v_rec_bank_id,v_rec_check_no,v_rec_bank_account_name,v_rec_bank_account_id,v_gl_mapping_item_id,v_reference,v_dividend_market_id,v_dividend_product_id,v_custodian_code,v_custodian_account,v_update_user,v_update_time; 
    end while; 
    close cur_req; 

    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proBatchProductInOut
-- ----------------------------
DROP PROCEDURE IF EXISTS `proBatchProductInOut`;
delimiter ;;
CREATE PROCEDURE `proBatchProductInOut`(OUT o_ret_code int,
  OUT o_ret_msg  char(128))
label:begin
    declare v_process_date date default NULL;
    declare v_done int default 0; 
    declare v_id bigint(11);
    declare v_account_id varchar(16);
    declare v_account_type varchar(16);
    declare v_market_id int(11);
    declare v_product_id varchar(32);
    declare v_quantity decimal(30,10);
    declare v_custodian_code varchar(16);
    declare v_custodian_account varchar(16);
    declare v_nominee_quantity decimal(30,10);
    declare v_avg_price decimal(30,10);
    declare v_avg_price2 decimal(30,10);
    declare v_remark varchar(128);
    declare v_update_user varchar(16);
    declare v_update_time datetime;

    declare cur_req cursor for
      select
            id,
            account_id,
            account_type,
            market_id,
            product_id,
            quantity,
            custodian_code,
            custodian_account,
            nominee_quantity,
            avg_price,
            avg_price2,
            remark,
            update_user,
            update_time
      from bat_product_flow; 

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done =1;

    set o_ret_code = 0, o_ret_msg = "Success";    
    
    truncate table CheckWarnings; 

    
     insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 1, 
           'batch_cash_in_out',
           '0',
           '',
           account_id,
           "account not exists",
           update_user,
           update_time  
    from bat_product_flow t where not EXISTS (select 1 from capital_account a where t.account_id = a.account_id );     
    if EXISTS(select 1 from CheckWarnings) then 
        set o_ret_code = 1, o_ret_msg = "Account not exists";
        leave label;
    end if; 

    
    insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 1, 
           'batch_cash_in_out',
           market_id,
           product_id,
           account_id,
           "product not exists",
           update_user,
           update_time  
    from bat_product_flow t where not EXISTS (select 1 from product a where t.market_id = a.list_market_id and t.product_id = a.product_id );     
    if EXISTS(select 1 from CheckWarnings) then 
        set o_ret_code = 1, o_ret_msg = "Product not exists";
        leave label;
    end if; 

    start transaction; 
    
    select buss_date into v_process_date from sys_info; 
    if v_process_date is NULL then 
        set o_ret_code = 1, o_ret_msg = "Bussiness date is not  setted up";
        ROLLBACK;
        leave label;
    end if; 

    update bat_product_flow a
    left join capital_account b on b.account_id = a.account_id
    set a.account_type = b.account_type;

    
    update import_account_trade_detail a
    inner join account_type_custodian b on a.market_id = b.market_id and a.account_type = b.account_type
	set a.custodian_code = b.custodian_code,
		 a.custodian_account = b.custodian_account; 

    
    open cur_req; 
    set v_done = 0; 
    fetch cur_req into v_id,v_account_id,v_account_type,v_market_id,v_product_id,v_quantity,v_custodian_code,v_custodian_account,v_nominee_quantity,v_avg_price,v_avg_price2,v_remark,v_update_user,v_update_time;
    while v_done <> 1 do 
        if(v_quantity >0 ) then 
            call proProductIn(NULL,v_account_id,v_account_type,v_market_id,v_product_id,v_quantity,v_custodian_code,v_custodian_account,v_nominee_quantity,v_avg_price,v_avg_price2,v_remark,v_update_user,now(),@r1,@r2);
        elseif(v_quantity <0) then 
            set v_quantity = -1*v_quantity;
            call proProductOut(NULL,v_account_id,v_account_type,v_market_id,v_product_id,v_quantity,v_custodian_code,v_custodian_account,v_nominee_quantity,v_avg_price,v_avg_price2,v_remark,v_update_user,now(),@r1,@r2);
        end if; 

        if @r1 <> 0 then 
            set o_ret_code = @r1, o_ret_msg = @r2; 
            close cur_req; 
            ROLLBACK;
            leave label; 
        end if; 
        set v_done = 0; 
        set v_id = 0; 
        set v_quantity = 0; 
        fetch cur_req into v_id,v_account_id,v_account_type,v_market_id,v_product_id,v_quantity,v_custodian_code,v_custodian_account,v_nominee_quantity,v_avg_price,v_avg_price2,v_remark,v_update_user,v_update_time;
    end while; 
    close cur_req; 

    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proBatchProductInOut_cover
-- ----------------------------
DROP PROCEDURE IF EXISTS `proBatchProductInOut_cover`;
delimiter ;;
CREATE PROCEDURE `proBatchProductInOut_cover`(OUT o_ret_code int,
  OUT o_ret_msg  char(128))
label:begin
    declare v_process_date date default NULL;
    declare v_done int default 0; 
    declare v_id bigint(11);
    declare v_account_id varchar(16);
    declare v_account_type varchar(16);
    declare v_market_id int(11);
    declare v_product_id varchar(16);
    declare v_quantity decimal(30,10);
    declare v_custodian_code varchar(16);
    declare v_custodian_account varchar(16);
    declare v_nominee_quantity decimal(30,10);
    declare v_avg_price decimal(30,10);
    declare v_avg_price2 decimal(30,10);
    declare v_remark varchar(128);
    declare v_update_user varchar(16);
    declare v_update_time datetime;

    declare cur_req cursor for
      select
            a.id,
            a.account_id,
            c.account_type,
            a.market_id,
            a.product_id,
            case when a.purpose = 1 then 1 else -1 end *a.quantity,
            if(b.custodian_code is null, a.custodian_code, b.custodian_code),
            if(b.custodian_account is null , a.custodian_account, b.custodian_account),
            a.nominee_quantity,
            a.avg_price,
            a.avg_price2,
            a.remark,
            a.update_user,
            a.update_time
      from product_flow a 
      left join account_type_custodian b on a.market_id = b.market_id and a.account_type = b.account_type	
      inner join capital_account c on a.account_id = c.account_id
      where a.process_date  = v_process_date and a.status = 'Confirmed' 
      order by a.id; 

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done =1;

    set o_ret_code = 0, o_ret_msg = "Success";    
    
    truncate table CheckWarnings; 

    
     insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 1, 
           'batch_cash_in_out',
           '0',
           '',
           account_id,
           "account not exists",
           update_user,
           update_time  
    from bat_product_flow t where not EXISTS (select 1 from capital_account a where t.account_id = a.account_id );     
    if EXISTS(select 1 from CheckWarnings) then 
        set o_ret_code = 1, o_ret_msg = "Account not exists";
        leave label;
    end if; 

    
    insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 1, 
           'batch_cash_in_out',
           market_id,
           product_id,
           account_id,
           "product not exists",
           update_user,
           update_time  
    from bat_product_flow t where not EXISTS (select 1 from product a where t.market_id = a.list_market_id and t.product_id = a.product_id );     
    if EXISTS(select 1 from CheckWarnings) then 
        set o_ret_code = 1, o_ret_msg = "Product not exists";
        leave label;
    end if; 

    start transaction; 
    
    select buss_date into v_process_date from sys_info; 
    if v_process_date is NULL then 
        set o_ret_code = 1, o_ret_msg = "Bussiness date is not  setted up";
        ROLLBACK;
        leave label;
    end if; 

    update bat_product_flow a
    left join capital_account b on b.account_id = a.account_id
        set a.account_type = b.account_type
    where a.account_type = '' or a.account_type is null;

    
    open cur_req; 
    set v_done = 0; 
    fetch cur_req into v_id,v_account_id,v_account_type,v_market_id,v_product_id,v_quantity,v_custodian_code,v_custodian_account,v_nominee_quantity,v_avg_price,v_avg_price2,v_remark,v_update_user,v_update_time;
    while v_done <> 1 do 
        if(v_quantity >0 ) then 
            call proProductIn_cover(NULL,v_account_id,v_account_type,v_market_id,v_product_id,v_quantity,v_custodian_code,v_custodian_account,v_nominee_quantity,v_avg_price,v_avg_price2,v_remark,v_update_user,v_update_time,@r1,@r2);
        elseif(v_quantity <0) then 
            set v_quantity = -1*v_quantity;
            call proProductOut_cover(NULL,v_account_id,v_account_type,v_market_id,v_product_id,v_quantity,v_custodian_code,v_custodian_account,v_nominee_quantity,v_avg_price,v_avg_price2,v_remark,v_update_user,v_update_time,@r1,@r2);
        end if; 

        if @r1 <> 0 then 
            set o_ret_code = @r1, o_ret_msg = @r2; 
            close cur_req; 
            ROLLBACK;
            leave label; 
        end if; 
        set v_done = 0; 
        set v_id = 0; 
        set v_quantity = 0; 
        fetch cur_req into v_id,v_account_id,v_account_type,v_market_id,v_product_id,v_quantity,v_custodian_code,v_custodian_account,v_nominee_quantity,v_avg_price,v_avg_price2,v_remark,v_update_user,v_update_time;
    end while; 
    close cur_req; 

    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proBcanEnding
-- ----------------------------
DROP PROCEDURE IF EXISTS `proBcanEnding`;
delimiter ;;
CREATE PROCEDURE `proBcanEnding`(OUT o_ret_code   INT,
    OUT o_ret_msg    VARCHAR(256))
label: BEGIN
DECLARE procedure_version VARCHAR(16) DEFAULT "1.0.3";
DECLARE v_done INT DEFAULT 0;
DECLARE `v_account_id` VARCHAR(16);
DECLARE `v_bcan` VARCHAR(10);
DECLARE `v_rslt_bcan` VARCHAR(10);
DECLARE `v_fimg_bcan` VARCHAR(10);
DECLARE `v_fimg_rs` VARCHAR(4);

DECLARE cur_req CURSOR FOR SELECT account_id, bcan, rslt_bcan, fimg_bcan, fimg_rs FROM bcan_rslt_fimg
where fimg_rs <> 'S';
DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1;

SET o_ret_code = 0, o_ret_msg = "SUCCESS";

IF NOT EXISTS(SELECT DISTINCT 1 FROM bcan_rslt_fimg)THEN
    SET o_ret_code = 1, o_ret_msg = "database table is empty";
    LEAVE label;
END IF;

START TRANSACTION;

OPEN cur_req;
loop_cycle: LOOP
    SET v_account_id = NULL;
    FETCH cur_req INTO v_account_id,v_bcan,v_rslt_bcan,v_fimg_bcan,v_fimg_rs;
    IF v_done <> 0 THEN
        LEAVE loop_cycle;
    END IF;
    IF v_account_id IS NULL THEN
        SET o_ret_code = 1, o_ret_msg = "find account_id=NULL";
        ROLLBACK;
        LEAVE label;
    END IF;
    IF v_bcan<>v_rslt_bcan OR v_bcan<>v_fimg_bcan THEN
        SET o_ret_code = 1, o_ret_msg = CONCAT("logical error, v_account_id=",IFNULL(v_account_id,'NULL'));
        ROLLBACK;
        LEAVE label;
    END IF;
END LOOP;
CLOSE cur_req;

UPDATE bcan_mapp_info bmi INNER JOIN bcan_rslt_fimg brf ON bmi.account_id=brf.account_id AND bmi.status<>brf.fimg_rs SET status=brf.fimg_rs,update_time=NOW();

DELETE FROM bcan_config WHERE field_key='record_sequence_number';

COMMIT;
-- truncate会自动提交事务
TRUNCATE TABLE bcan_rslt_fimg;

END label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proBcanFimg
-- ----------------------------
DROP PROCEDURE IF EXISTS `proBcanFimg`;
delimiter ;;
CREATE PROCEDURE `proBcanFimg`(OUT o_ret_code   INT,
    OUT o_ret_msg    VARCHAR(256))
label: BEGIN
DECLARE procedure_version VARCHAR(16) DEFAULT "1.0.2";

SET o_ret_code = 0, o_ret_msg = "SUCCESS";


UPDATE tmp_bcan_rslt_fimg SET id=1; -- 临时用id标识(哪些BCAN要被处理).

DROP   TABLE IF     EXISTS tmp_bcan_rslt_fimg_4_skip;
CREATE TABLE IF NOT EXISTS tmp_bcan_rslt_fimg_4_skip SELECT * FROM bcan_rslt_fimg WHERE 1=2;
CREATE INDEX idx_1 ON tmp_bcan_rslt_fimg_4_skip(fimg_sfirm);
CREATE INDEX idx_2 ON tmp_bcan_rslt_fimg_4_skip(fimg_bcan);

INSERT INTO tmp_bcan_rslt_fimg_4_skip(fimg_bcan,fimg_sfirm) SELECT fimg_bcan,fimg_sfirm FROM (
        SELECT fimg_bcan,fimg_sfirm,ttep_min_bcan,ttep_max_bcan FROM tmp_bcan_rslt_fimg t LEFT JOIN bcan_aufm_info bai ON t.fimg_sfirm=bai.ttep_firm_id
    )t2 WHERE ttep_min_bcan<=fimg_bcan AND fimg_bcan<=ttep_max_bcan;

UPDATE tmp_bcan_rslt_fimg SET id=0 WHERE fimg_bcan IN(SELECT DISTINCT fimg_bcan FROM tmp_bcan_rslt_fimg_4_skip);
DROP   TABLE IF     EXISTS tmp_bcan_rslt_fimg_4_skip;

drop table if exists tmp_bcan_rslt_fimg_2b; 
create table tmp_bcan_rslt_fimg_2b select * from tmp_bcan_rslt_fimg;

IF EXISTS(SELECT 1 FROM tmp_bcan_rslt_fimg t LEFT JOIN bcan_mapp_info b ON t.fimg_bcan=b.bcan WHERE t.id=1 and t.fimg_rs <> 'S' AND b.account_id IS NULL)THEN
    SET o_ret_code = 1, o_ret_msg = "precheck BCANFIMG_YYYYMMDD_2 fail";
    LEAVE label;
END IF;

UPDATE tmp_bcan_rslt_fimg SET fimg_time=NOW();

INSERT INTO bcan_rslt_fimg(    account_id,    ec_firm_id,    bcan,    fimg_rs,    fimg_bcan,    fimg_sfirm,    fimg_time)
                    SELECT bmi.account_id,bmi.ec_firm_id,bmi.bcan,brf.fimg_rs,brf.fimg_bcan,brf.fimg_sfirm,brf.fimg_time
                    FROM tmp_bcan_rslt_fimg brf LEFT JOIN bcan_mapp_info bmi ON brf.fimg_bcan=bmi.bcan WHERE brf.id=1
ON DUPLICATE KEY UPDATE
account_id = bmi.account_id,
ec_firm_id = bmi.ec_firm_id,
      bcan = bmi.bcan,
   fimg_rs = brf.fimg_rs,
 fimg_bcan = brf.fimg_bcan,
fimg_sfirm = brf.fimg_sfirm,
 fimg_time = brf.fimg_time ;

END label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proBcanGenMappInfo
-- ----------------------------
DROP PROCEDURE IF EXISTS `proBcanGenMappInfo`;
delimiter ;;
CREATE PROCEDURE `proBcanGenMappInfo`(OUT o_ret_code   INT,
    OUT o_ret_msg    VARCHAR(256))
label: BEGIN
DECLARE v_done INT DEFAULT 0; 
DECLARE v_account_id_profile VARCHAR(16);
DECLARE v_account_class INT;
DECLARE `v_checked` INT;
DECLARE `v_status` VARCHAR(8);
DECLARE `v_account_id` VARCHAR(16);
DECLARE `v_record_type` VARCHAR(1);
DECLARE `v_client_type` VARCHAR(2);
DECLARE `v_ec_firm_id` VARCHAR(5);
DECLARE `v_bcan` VARCHAR(10);
DECLARE `v_number_oah` VARCHAR(2);
DECLARE `v_english_fnamn` VARCHAR(40);
DECLARE `v_english_lname` VARCHAR(40);
DECLARE `v_english_lename` VARCHAR(100);
DECLARE `v_chinese_name` VARCHAR(40);
DECLARE `v_chinese_lename` VARCHAR(120);
DECLARE `v_country_oi` VARCHAR(3);
DECLARE `v_id_type` VARCHAR(2);
DECLARE `v_id_number` VARCHAR(40);

DECLARE cur_req CURSOR FOR 
    SELECT 
        account_id 
    FROM tmp_bcan_mapp_info 
    where account_id not in (select account_id from ttep_list);
DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1;

SET o_ret_code = 0, o_ret_msg = "SUCCESS";

IF NOT EXISTS(SELECT DISTINCT 1 FROM tmp_bcan_mapp_info)THEN
    SET o_ret_code = 1, o_ret_msg = "no account_id need generate BCAN";
    LEAVE label;
END IF;

-- SELECT REVERSE(-(-REVERSE(member_id)))+0 INTO v_ec_firm_id FROM market WHERE market_id=1;
SELECT field_value INTO v_ec_firm_id FROM bcan_config WHERE field_key='bcan_firm_id';
IF IFNULL(v_ec_firm_id,0)=0 THEN
    SET o_ret_code = 1, o_ret_msg = "invalid bcan_firm_id in table bcan_config";
    LEAVE label;
END IF;

SELECT MAX(bcan) INTO v_bcan FROM bcan_mapp_info;
IF IFNULL(v_bcan,0)=0 THEN
    SET v_bcan = v_ec_firm_id*1000*1000;
END IF;

SET v_record_type = 'D';

START TRANSACTION;

create index idx1 on tmp_bcan_mapp_info(account_id);

OPEN cur_req;
loop_cycle: LOOP
    FETCH cur_req INTO v_account_id;
    IF v_done <> 0 THEN
        LEAVE loop_cycle;
    END IF;

    SET v_account_id_profile = NULL;
    SELECT account_id, account_class INTO v_account_id_profile, v_account_class FROM account_profile WHERE account_id=v_account_id;
    IF v_account_id_profile IS NULL THEN -- 判断账户是否存在.
        SET o_ret_code = 1, o_ret_msg = CONCAT("invalid account_id=",IFNULL(v_account_id,'NULL'));
        ROLLBACK;
        LEAVE label;
    END IF;
    IF EXISTS(SELECT 1 FROM bcan_mapp_info WHERE account_id=v_account_id)THEN
        SET o_ret_code = 1, o_ret_msg = CONCAT("already has bcan, account_id=",IFNULL(v_account_id,'NULL'));
        ROLLBACK;
        LEAVE label;
    END IF;

    IF v_account_class = 3 THEN -- SELECT * FROM dict WHERE class='ACCOUNT' AND sub_class='CLASS';
        SET v_client_type = 1;
    ELSEIF v_account_class = 4 THEN
        SET v_client_type = 2;
    ELSEIF v_account_class = 1 THEN
        SET v_client_type = 4;
    ELSE
        SET o_ret_code = 1, o_ret_msg = CONCAT("invalid account_class=",IFNULL(v_account_class,'NULL'),", account_id=",IFNULL(v_account_id,'NULL'));
        ROLLBACK;
        LEAVE label;
    END IF;

    SET v_bcan = v_bcan + 1;
    SET v_number_oah = 1;

    IF v_client_type = 1 THEN -- (个人)
        SELECT CONCAT(IFNULL(first_name,''),' ',IFNULL(middle_name,'')),  last_name,     short_name,photo_country,photoid_type,photoid INTO v_english_fnamn,v_english_lname,v_chinese_name,  v_country_oi,v_id_type,v_id_number FROM account_profile WHERE account_id=v_account_id;
        SET v_english_lename = ''; -- (English Legal Entity Name)
        SET v_chinese_lename = ''; -- (Chinese Legal Entity Name)
        IF REPLACE(IFNULL(v_chinese_name,''),' ','')='' THEN -- 如果中文是空,就用英文.
            --  v_english_fnamn -- (English First Name and Middle Name)
            --  v_english_lname -- (English Last Name)
            SET v_chinese_name = ''; -- (Chinese Name)
        ELSE
            SET v_english_fnamn = ''; -- (English First Name and Middle Name)
            SET v_english_lname = ''; -- (English Last Name)
            --  v_chinese_name -- (Chinese Name)
        END IF;
        IF v_id_type IN (1,2) THEN -- SELECT * FROM dict WHERE sub_class='PHOTOID_TYPE';(字段转换)
            SET v_id_type = 5;
        ELSEIF v_id_type = 3 THEN
            SET v_id_type = 2;
        ELSEIF v_id_type = 4 THEN
            SET v_id_type = 1;
        ELSE
            SET v_id_type = '';
        END IF;
    ELSEIF v_client_type IN (3,4,5) THEN -- (机构)
        SELECT CONCAT(IFNULL(first_name,''),IFNULL(middle_name,''),IFNULL(last_name,'')),short_name,party_country,partyid_type,partyid INTO v_english_lename,               v_chinese_lename,v_country_oi,v_id_type,v_id_number FROM account_profile WHERE account_id=v_account_id;
        SET v_english_fnamn = ''; -- (English First Name and Middle Name)
        SET v_english_lname = ''; -- (English Last Name)
        SET v_chinese_name = ''; -- (Chinese Name)
        IF REPLACE(IFNULL(v_chinese_lename,''),' ','')='' THEN -- 如果中文是空,就用英文.
            --  v_english_lename -- (English Legal Entity Name)
            SET v_chinese_lename = ''; -- (Chinese Legal Entity Name)
        ELSE
            SET v_english_lename = ''; -- (English Legal Entity Name)
            --  v_chinese_lename -- (Chinese Legal Entity Name)
        END IF;
        SET v_id_type = 3;
    ELSE
        SET o_ret_code = 1, o_ret_msg = CONCAT("invalid client_type=",v_client_type,", account_id=",IFNULL(v_account_id,'NULL'));
        ROLLBACK;
        LEAVE label;
    END IF;

    IF IFNULL(v_id_type,'') = '' THEN
        SET o_ret_code = 1, o_ret_msg = CONCAT("invalid id_type, account_id=",IFNULL(v_account_id,'NULL'));
        ROLLBACK;
        LEAVE label;
    END IF;

    INSERT INTO bcan_mapp_info(  account_id,  record_type,record_sn,  client_type,  ec_firm_id,  bcan,  number_oah,  english_fnamn,  english_lname,  english_lename,  chinese_name,  chinese_lename,  country_oi,  id_type,  id_number,insert_user,insert_time)
                        VALUES(v_account_id,v_record_type,     NULL,v_client_type,v_ec_firm_id,v_bcan,v_number_oah,v_english_fnamn,v_english_lname,v_english_lename,v_chinese_name,v_chinese_lename,v_country_oi,v_id_type,v_id_number,       NULL,      NOW());
END LOOP;

COMMIT;

END label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proBcanMappContent
-- ----------------------------
DROP PROCEDURE IF EXISTS `proBcanMappContent`;
delimiter ;;
CREATE PROCEDURE `proBcanMappContent`(OUT o_ret_code   INT,
    OUT o_ret_msg    VARCHAR(256))
label: BEGIN
DECLARE v_done INT DEFAULT 0;
DECLARE `v_head_ssn` INT;
DECLARE `v_account_id` VARCHAR(16);
DECLARE `v_ec_firm_id` VARCHAR(5);
DECLARE `v_bcan` VARCHAR(10);

SET o_ret_code = 0, o_ret_msg = "SUCCESS";

IF NOT EXISTS(SELECT DISTINCT 1 FROM bcan_mapp_info WHERE checked = 1)THEN
    SET o_ret_code = 1, o_ret_msg = "no selected data to generate MAPP content";
    LEAVE label;
END IF;

IF NOT EXISTS(SELECT DISTINCT 1 FROM bcan_mapp_info WHERE checked = 1 AND IFNULL(status,'')='')THEN
    SET o_ret_code = 1, o_ret_msg = "maybe no new data, will not generate MAPP content";
    LEAVE label;
END IF;

IF EXISTS(SELECT DISTINCT 1 FROM bcan_mapp_resp)THEN
    SET o_ret_code = 1, o_ret_msg = "already generate MAPP content";
    LEAVE label;
END IF;

SELECT field_value INTO v_head_ssn FROM bcan_config WHERE field_key='record_sequence_number';
SET v_head_ssn = IFNULL(v_head_ssn,0)+1;

START TRANSACTION;

INSERT INTO bcan_mapp_resp(account_id, ec_firm_id, bcan,  head_ssn, mapp_time)
                    SELECT a.account_id, a.ec_firm_id, a.bcan,v_head_ssn,     NOW() FROM bcan_mapp_info a
                    inner join account_profile b on a.account_id = b.account_id
                    WHERE a.checked = 1 and b.status <> 2;

UPDATE bcan_mapp_resp SET record_sn=id;

REPLACE INTO bcan_config(               field_key, field_value, update_user, update_time)
                   VALUE('record_sequence_number',  v_head_ssn, 'PROCEDURE',       NOW());

COMMIT;

END label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proBcanResp
-- ----------------------------
DROP PROCEDURE IF EXISTS `proBcanResp`;
delimiter ;;
CREATE PROCEDURE `proBcanResp`(OUT o_ret_code   INT,
    OUT o_ret_msg    VARCHAR(256))
label: BEGIN
DECLARE procedure_version VARCHAR(16) DEFAULT "1.0.2";
DECLARE v_done INT DEFAULT 0;
DECLARE `v_resp_orsn` VARCHAR(11);
DECLARE `v_resp_rcode` VARCHAR(5);
DECLARE `v_resp_rtext` VARCHAR(200);
DECLARE `v_resp_rfn` VARCHAR(2);
DECLARE v_total_count INT DEFAULT 0;
DECLARE v_resp_count  INT DEFAULT 0;

DECLARE cur_req CURSOR FOR SELECT resp_orsn, resp_rcode, resp_rtext, resp_rfn FROM tmp_bcan_mapp_resp;
DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1;

SET o_ret_code = 0, o_ret_msg = "SUCCESS";

IF EXISTS(SELECT 1 FROM tmp_bcan_mapp_resp WHERE resp_orsn NOT IN (SELECT record_sn FROM bcan_mapp_resp))THEN
    SET o_ret_code = 1, o_ret_msg = "check BCANRESP_YYYYMMDD fail";
    LEAVE label;
END IF;

IF NOT EXISTS(SELECT DISTINCT 1 FROM bcan_mapp_resp WHERE resp_time IS NULL)THEN
    SET o_ret_code = 1, o_ret_msg = "maybe already RESP";
    LEAVE label;
END IF;

START TRANSACTION;

OPEN cur_req;
loop_cycle: LOOP
    FETCH cur_req INTO v_resp_orsn, v_resp_rcode, v_resp_rtext, v_resp_rfn;
    IF v_done <> 0 THEN
        LEAVE loop_cycle;
    END IF;
    IF NOT EXISTS(SELECT 1 FROM bcan_mapp_resp WHERE record_sn=v_resp_orsn AND resp_time IS NULL)THEN
        SET o_ret_code = 1, o_ret_msg = "record_sn maybe already RESP";
        ROLLBACK;
        LEAVE label;
    END IF;
    UPDATE bcan_mapp_resp SET resp_orsn=v_resp_orsn, resp_rcode=v_resp_rcode, resp_rtext=v_resp_rtext, resp_rfn=v_resp_rfn, resp_time=NOW() WHERE record_sn=v_resp_orsn;
END LOOP;
CLOSE cur_req;

UPDATE bcan_mapp_resp SET resp_time=NOW() WHERE resp_time IS NULL;

SELECT COUNT(*) INTO v_total_count FROM bcan_mapp_resp;
SELECT COUNT(*) INTO v_resp_count  FROM bcan_mapp_resp WHERE resp_orsn IS NOT NULL;

IF 0 <> v_resp_count THEN
    SET o_ret_code = 0, o_ret_msg = CONCAT("WARNNING: total_count=",v_total_count,", resp_count[ERROR_count]=",v_resp_count);
END IF;

COMMIT;

END label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proBcanRslt
-- ----------------------------
DROP PROCEDURE IF EXISTS `proBcanRslt`;
delimiter ;;
CREATE PROCEDURE `proBcanRslt`(OUT o_ret_code   INT,
    OUT o_ret_msg    VARCHAR(256))
label: BEGIN
DECLARE procedure_version VARCHAR(16) DEFAULT "1.0.2";
DECLARE v_done INT DEFAULT 0;
DECLARE `v_account_id` VARCHAR(16);
DECLARE `v_ec_firm_id` VARCHAR(5);
DECLARE `v_bcan` VARCHAR(10);
DECLARE `v_rslt_bcan` VARCHAR(10);
DECLARE `v_rslt_ac` VARCHAR(1);
DECLARE `v_rslt_rc` VARCHAR(4);
DECLARE `v_rslt_rsnart` VARCHAR(120);
DECLARE v_total_count INT DEFAULT 0;
DECLARE v_rslt_count  INT DEFAULT 0;
DECLARE v_error_count INT DEFAULT 0;

SET o_ret_code = 0, o_ret_msg = "SUCCESS";

-- (20210210)在C++代码中创建了tmp_bcan_rslt_fimg,临时在这里创建索引,试图提高SQL语句的执行速度;
CREATE INDEX idx_1 ON tmp_bcan_rslt_fimg(rslt_bcan);
CREATE INDEX idx_2 ON tmp_bcan_rslt_fimg(fimg_sfirm);
CREATE INDEX idx_3 ON tmp_bcan_rslt_fimg(fimg_bcan);

IF EXISTS(SELECT DISTINCT 1 FROM bcan_rslt_fimg)THEN
    SET o_ret_code = 1, o_ret_msg = "table is not empty, maybe already RSLT";
    LEAVE label;
END IF;

IF EXISTS(SELECT 1 FROM tmp_bcan_rslt_fimg t LEFT JOIN bcan_mapp_info b ON t.rslt_bcan=b.bcan WHERE t.fimg_rs <> 'S' and b.account_id IS NULL)THEN
    SET o_ret_code = 1, o_ret_msg = "precheck BCANRSLT_YYYYMMDD fail";
    LEAVE label;
END IF;

INSERT INTO bcan_rslt_fimg(    account_id,    ec_firm_id,    bcan,    rslt_bcan,    rslt_ac,    rslt_rc,    rslt_rsnart,         rslt_time)
                    SELECT bmi.account_id,bmi.ec_firm_id,bmi.bcan,brf.rslt_bcan,brf.rslt_ac,brf.rslt_rc,brf.rslt_rsnart,NOW() AS rslt_time
                    FROM tmp_bcan_rslt_fimg brf LEFT JOIN bcan_mapp_info bmi ON brf.rslt_bcan=bmi.bcan;

SELECT COUNT(*) INTO v_rslt_count  FROM bcan_rslt_fimg WHERE IFNULL(rslt_rc,'')<>'';
SELECT COUNT(*) INTO v_error_count FROM bcan_rslt_fimg WHERE IFNULL(rslt_rc,'')<>'0000';

IF v_error_count <> 0 THEN
    SET o_ret_code = 0, o_ret_msg = CONCAT("WARNNING: rslt_count=",v_rslt_count,", error_count=",v_error_count);
END IF;

END label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCalDayInterest
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCalDayInterest`;
delimiter ;;
CREATE PROCEDURE `proCalDayInterest`(IN  i_process_date date, 
  OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin
    declare v_process_date date; 
    declare v_last_process_date  date; 
    declare v_done int; 
    declare v_formula_value char(255); 
    declare v_formula_value2 char(255); 
    declare v_id bigint;  
    declare v_date date ; 
    declare v_last_month_date date; 
    declare v_day1 date; 
    declare v_day2 date; 
    declare v_end_date date; 
    declare v_sum_date_s date; 
    declare v_sum_date_e date; 

    declare cur_interest cursor for
        select a.id, b.formula_value, c.formula_value
        from account_interest a
        left join formula b on a.debit_formula_type = b.formula_type and a.debit_formula_code = b.formula_code
        left join formula c on a.credit_formula_type = c.formula_type and a.credit_formula_code = c.formula_code
        where a.process_date = i_process_date;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done=1;

    select buss_date,last_buss_date  into v_process_date,v_last_process_date from sys_info; 

    if i_process_date is  NULL then 
        set i_process_date = v_process_date;
    end if; 


    ###清除本日利息数据
    delete from account_interest where process_date  = i_process_date; 
    #如果计算日期大于当前业务日（周六、周日）
    /*
    if i_process_date > v_process_date then 
        insert into account_interest(
                    process_date,
                    account_id,
                    account_type,
                    currency,
                    Bal,
                    PrimeRate,
                    SavingRate,
                    debit_formula_type,
                    debit_formula_code,
                    credit_formula_type,
                    credit_formula_code,
                    debit_interest,
                    credit_interest
            )
            select 
                    i_process_date,
                    account_id,
                    account_type,
                    currency,
                    Bal,
                    PrimeRate,
                    SavingRate,
                    debit_formula_type,
                    debit_formula_code,
                    credit_formula_type,
                    credit_formula_code,
                    debit_interest,
                    credit_interest
                from account_interest 
                where  process_date = v_process_date; 
    else 
    */
        insert into account_interest(
                    process_date,
                    account_id,
                    account_type,
                    currency,
                    Bal,
                    PrimeRate,
                    SavingRate,
                    debit_formula_type,
                    debit_formula_code,
                    credit_formula_type,
                    credit_formula_code,
                    debit_interest,
                    credit_interest,
                    waive
            )
        select  i_process_date,
                a.account_id,
                a.account_type,
                a.currency,
                case when a.settle_balance < 0 then if((a.settle_balance + ifnull(c.amount,0)) > 0,0,(a.settle_balance + ifnull(c.amount,0))) else a.settle_balance end,
                -- a.settle_balance,    -- 是不是收利息要看客户是否真的欠款了
                b.prime_rate,
                b.saving_rate,
                b.debit_formula_type,
                b.debit_formula_code,
                b.credit_formula_type,  
                b.credit_formula_code, 
                0.0,  -- debit
                0.0,  -- credit
                'N'  -- waive
        from account_balance a 
        left join currency b on a.currency = b.currency
        left join (
            select account_id,account_type,currency,sum(case purpose when 1 then 1 else -1 end * amount) as amount 
                from cash_flow_cit group by account_id,account_type,currency
                ) c on 
            c.account_id = a.account_id and c.account_type = a.account_type and c.currency = a.currency
        where process_date = v_process_date;
        -- select  i_process_date,
        --         a.account_id,
        --         a.account_type,
        --         a.currency,
        --         a.settle_balance,    -- 是不是收利息要看客户是否真的欠款了
        --         b.prime_rate,
        --         b.saving_rate,
        --         b.debit_formula_type,
        --         b.debit_formula_code,
        --         b.credit_formula_type,  
        --         b.credit_formula_code, 
        --         0.0,  -- debit
        --         0.0,  -- credit
        --         'N'  -- waive
        -- from account_balance a 
        -- left join currency b on a.currency = b.currency
        -- where process_date = v_process_date;

        update account_interest a
        inner join  account_interest_rule b on a.account_id = b.account_id and a.currency = b.currency 
        set
            a.debit_formula_code = b.debit_formula_code,
            a.credit_formula_code = b.credit_formula_code
        where a.process_date = i_process_date; 
        
        
        open cur_interest; 
        set v_done =0; 
        fetch cur_interest into v_id,v_formula_value,v_formula_value2;  
        while v_done <> 1 do 
            
            set @sql = concat("update account_interest 
                               set 
                               debit_interest_rate = (", v_formula_value, ")/365/100," 
                              ,"debit_interest = case when Bal < 0 then round(-1*Bal*(",v_formula_value,")/365/100, 2) else 0 end where id = ",v_id,";");
            prepare stmt from @sql; 
            execute stmt; 

            set @sql = concat("update account_interest 
                               set 
                               credit_interest_rate = (",v_formula_value2, ")/365/100,"
                               ,"credit_interest = case when Bal > 0 then round(Bal*(",v_formula_value2,")/365/100, 2) else 0 end where id = ", v_id,";");
            prepare stmt from @sql; 
            execute stmt; 
            
            set v_done =0; 
            fetch cur_interest into v_id,v_formula_value,v_formula_value2;  
        end while; 
    /* end if;  */

    /* 
	-- 汇总出入金产生的利息：头一天结算完切日之后，第二天之前的出入金
    drop temporary table if exists tmp_cash_interest;
    create temporary table tmp_cash_interest
    (
        account_id varchar(16), 
        currency varchar(1),
        credit_interest DECIMAL(30,10), 
        debit_interest DECIMAL(30,10), 
        index idx1(account_id,currency)
    );

    insert into tmp_cash_interest
    (
        account_id,
        currency,
        credit_interest,
        debit_interest
    )
    select 
        t.account_id,
        t.currency,
        case when round(sum(t.interest) - sum(t.credit_interest - t.debit_interest),2) > 0 then round(sum(t.interest) - sum(t.credit_interest - t.debit_interest),2) else 0 end,
        case when round(sum(t.interest) - sum(t.credit_interest - t.debit_interest),2) < 0 then -1*round(sum(t.interest) - sum(t.credit_interest - t.debit_interest),2) else 0 end
    from(
        select 
            b.update_time,
            b.account_id,
            b.currency,
            ifnull(a.Bal,0) as Bal,
            case when ifnull(a.debit_interest,'') = '' then 0 else a.debit_interest end as debit_interest,
            case when ifnull(a.credit_interest,'') = '' then 0 else a.credit_interest end as credit_interest,
            round(case when (ifnull(a.Bal,0) + b.amt)>=0 
                       then (ifnull(a.Bal,0) + b.amt)* (case when ifnull(a.credit_interest_rate,'') = '' then d.credit_interest_rate else a.credit_interest_rate end) 
                       else (ifnull(a.Bal,0) + b.amt)* (case when ifnull(a.debit_interest_rate,'') = '' then d.debit_interest_rate else a.debit_interest_rate end) 
                    end,2) * day_num as interest,
            case when ifnull(a.credit_interest_rate,'') = '' then d.credit_interest_rate else a.credit_interest_rate end as debit_interest_rate,
            case when ifnull(a.credit_interest_rate,'') = '' then d.credit_interest_rate else a.credit_interest_rate end as credit_interest_rate,
            b.amt
        from account_interest a 
        right join (
            select 
            c.process_date,
            DATE_FORMAT(c.update_time,'%Y-%m-%d') as update_time,
            datediff(DATE_FORMAT(c.process_date,'%Y%m%d'), DATE_FORMAT(c.update_time,'%Y%m%d')) as day_num,
            c.account_id,
            c.currency,
            sum(case c.purpose when 1 then 1 else -1 end * c.amount) as amt 
            from cash_flow c where c.process_date = i_process_date and c.process_date <> DATE_FORMAT(c.update_time,'%y-%m-%d')
            group by process_date,DATE_FORMAT(c.update_time,'%Y-%m-%d'),account_id,currency
        ) b on a.process_date >= b.update_time and a.process_date < b.process_date and a.account_id = b.account_id and a.currency = b.currency
        inner join account_interest d on d.process_date = i_process_date and d.account_id = b.account_id and d.currency = b.currency
    ) t
    group by t.account_id,t.currency;

    -- 出入金流水中value date不等于结算日的资金产生的利息
    update account_interest a
    inner join tmp_cash_interest b on b.account_id = a.account_id and b.currency = a.currency
    set a.debit_interest = ifnull(a.debit_interest,0) + ifnull(b.debit_interest,0),
        a.credit_interest = ifnull(a.credit_interest,0) + ifnull(b.credit_interest,0)
    where a.process_date = i_process_date;  
*/

    -- 今日利息调整  
    update account_balance a
        inner join account_interest_adj b on i_process_date = b.process_date and a.account_id = b.account_id and a.account_type = b.account_type and a.currency = b.currency
        set a.accrued_interest = a.accrued_interest + (case when b.adj_interest < 0 then b.adj_interest else 0 end ),
            a.accrued_interest_credit = a.accrued_interest_credit + (case when b.adj_interest > 0 then b.adj_interest else 0 end ), 
            a.interest = a.interest + b.adj_interest
        where a.process_date = v_process_date; 

    -- 成交撤销或出入金撤销产生的利息
    UPDATE account_interest a
    left join cancel_cash_flow b on b.process_date = i_process_date and b.account_id = a.account_id and b.account_type = a.account_type and b.currency = a.currency
    set a.debit_interest = a.debit_interest + (case when ifnull(b.interest,0) < 0 then ifnull(b.interest,0) else 0 end),
        a.credit_interest = a.credit_interest + (case when ifnull(b.interest,0) > 0 then ifnull(b.interest,0) else 0 end)
    where a.process_date = i_process_date;

    -- 更新累计利息
    drop temporary table if exists tmp_interest;
    create temporary table tmp_interest
    (
       account_id varchar(16), 
       account_type int,
       currency int , 
       debit_interest decimal(30,10) default 0 , 
       credit_interest decimal(30,10) default 0,
       debit_interest_rate decimal(30,10) default 0, 
       credit_interest_rate decimal(30,10) default 0,
       index idx1(account_id,account_type,currency)  
    ); 

    -- 删掉冗余数据
    delete from account_interest where process_date = i_process_date and  credit_interest = 0 and debit_interest  = 0; 

    -- 汇总余新收入的利息
    insert into tmp_interest
    select a.account_id,b.account_type,a.currency,(ifnull(a.debit_interest,0)), (ifnull(a.credit_interest,0)),a.debit_interest_rate, a.credit_interest_rate
    from account_interest a
    inner join capital_account b on a.account_id = b.account_id 
    where process_date  = i_process_date;

    -- 计算融券利息
    delete from borrow_fee_flow where process_date = i_process_date;
    INSERT INTO borrow_fee_flow(process_date, account_id, account_type, market_id, product_id, custodian_code,custodian_account, currency, quantity, borrow_fee_rate, borrow_fee)
    SELECT i_process_date, a.account_id, a.account_type, a.market_id, a.product_id,  a.custodian_code, a.custodian_account, a.currency, a.quantity,
        ROUND(ifnull(b.borrow_fee/100,0)/360,6) AS borrow_fee_rate, abs(ROUND(a.market_value*ROUND(ifnull(b.borrow_fee/100,0)/360,6),2)) AS borrow_fee
    FROM account_position a 
    LEFT JOIN borrow_list b ON a.process_date=b.process_date AND a.market_id=b.market_id AND a.product_id=b.product_id
    WHERE a.process_date=v_process_date AND a.quantity<0 AND a.market_id in ('2','16');

    -- 删除冗余数据
    delete from borrow_fee_flow where process_date = i_process_date and borrow_fee = 0; 

    -- 计算成本价
    update account_position a 
    inner join borrow_fee_flow b on i_process_date = b.process_date and a.market_id = b.market_id and a.product_id = b.product_id and a.account_id = b.account_id and a.account_type = b.account_type and a.custodian_code = b.custodian_code and a.custodian_account = b.custodian_account
    inner join product c on c.list_market_id = a.market_id and c.product_id = a.product_id 
    set a.position_cost = case when a.net_quantity = 0 then 0 else a.position_cost + b.borrow_fee end
    where a.process_date = v_process_date; 

    update account_position a 
    inner join borrow_fee_flow b on i_process_date = b.process_date and a.market_id = b.market_id and a.product_id = b.product_id and a.account_id = b.account_id and a.account_type = b.account_type and a.custodian_code = b.custodian_code and a.custodian_account = b.custodian_account
    inner join product c on c.list_market_id = a.market_id and c.product_id = a.product_id 
    set a.avg_price1 = round(case when a.net_quantity = 0 then 0 else a.position_cost/a.net_quantity/ifnull(c.price_factor,1) end, 6)
    where a.process_date = v_process_date; 

    -- 融券利息汇总
    drop temporary table if exists tmp_borrow_fee_summary;
    create temporary table tmp_borrow_fee_summary
    (
       account_id varchar(16), 
       account_type int,
       currency int , 
       borrow_fee decimal(30,10), 
       index idx1(account_id,account_type,currency)  
    ); 
    insert into tmp_borrow_fee_summary
    select a.account_id, a.account_type, a.currency, sum(borrow_fee)
    from borrow_fee_flow a
    where process_date  = i_process_date
    group by a.account_id, a.account_type, a.currency;

    update account_balance a 
        left join tmp_interest b on  a.account_id = b.account_id and a.account_type = b.account_type and a.currency =b.currency
        left join tmp_borrow_fee_summary c on  a.account_id = c.account_id and a.account_type  = c.account_type and a.currency = c.currency
        set a.accrued_interest = a.accrued_interest + ifnull((b.debit_interest),0) + ifnull(c.borrow_fee,0),
            a.accrued_interest_credit = a.accrued_interest_credit + ifnull((b.credit_interest),0),
            a.interest = ifnull((b.credit_interest),0) - ifnull((b.debit_interest),0) - ifnull(c.borrow_fee,0),
            a.debit_interest_rate = ifnull(b.debit_interest_rate,0),
            a.credit_interest_rate = ifnull(b.credit_interest_rate,0)
        where a.process_date = v_process_date;

    set o_ret_code = 0; 
    set o_ret_msg = "利息计算完成";

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCalDayInterestTool
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCalDayInterestTool`;
delimiter ;;
CREATE PROCEDURE `proCalDayInterestTool`(IN  i_process_date date, 
  IN  v_process_date date, 
  OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin
    -- declare v_process_date date; 
    declare v_last_process_date  date; 
    declare v_done int; 
    declare v_formula_value char(255); 
    declare v_formula_value2 char(255); 
    declare v_id bigint;  
    declare v_date date ; 
    declare v_last_month_date date; 
    declare v_day1 date; 
    declare v_day2 date; 
    declare v_end_date date; 
    declare v_sum_date_s date; 
    declare v_sum_date_e date; 

    declare cur_interest cursor for
        select a.id, b.formula_value, c.formula_value
        from account_interest a
        left join formula b on a.debit_formula_type = b.formula_type and a.debit_formula_code = b.formula_code
        left join formula c on a.credit_formula_type = c.formula_type and a.credit_formula_code = c.formula_code
        where a.process_date = i_process_date;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done=1;

    -- select buss_date,last_buss_date  into v_process_date,v_last_process_date from sys_info; 

    if i_process_date is  NULL then 
        set i_process_date = v_process_date;
    end if; 


    ###清除本日利息数据
    delete from account_interest where process_date  = i_process_date; 
    #如果计算日期大于当前业务日（周六、周日）
    /*
    if i_process_date > v_process_date then 
        insert into account_interest(
                    process_date,
                    account_id,
                    account_type,
                    currency,
                    Bal,
                    PrimeRate,
                    SavingRate,
                    debit_formula_type,
                    debit_formula_code,
                    credit_formula_type,
                    credit_formula_code,
                    debit_interest,
                    credit_interest
            )
            select 
                    i_process_date,
                    account_id,
                    account_type,
                    currency,
                    Bal,
                    PrimeRate,
                    SavingRate,
                    debit_formula_type,
                    debit_formula_code,
                    credit_formula_type,
                    credit_formula_code,
                    debit_interest,
                    credit_interest
                from account_interest 
                where  process_date = v_process_date; 
    else 
    */
        insert into account_interest(
                    process_date,
                    account_id,
                    account_type,
                    currency,
                    Bal,
                    PrimeRate,
                    SavingRate,
                    debit_formula_type,
                    debit_formula_code,
                    credit_formula_type,
                    credit_formula_code,
                    debit_interest,
                    credit_interest,
                    waive
            )
        select  i_process_date,
                a.account_id,
                a.account_type,
                a.currency,
                case when a.settle_balance < 0 then if((a.settle_balance + ifnull(c.amount,0)) > 0,0,(a.settle_balance + ifnull(c.amount,0))) else a.settle_balance end,
                -- a.settle_balance,    -- 是不是收利息要看客户是否真的欠款了
                b.prime_rate,
                b.saving_rate,
                b.debit_formula_type,
                b.debit_formula_code,
                b.credit_formula_type,  
                b.credit_formula_code, 
                0.0,  -- debit
                0.0,  -- credit
                'N'  -- waive
        from account_balance a 
        left join currency b on a.currency = b.currency
        left join (
            select account_id,account_type,currency,sum(case purpose when 1 then 1 else -1 end * amount) as amount 
                from cash_flow_cit group by account_id,account_type,currency
                ) c on 
            c.account_id = a.account_id and c.account_type = a.account_type and c.currency = a.currency
        where process_date = v_process_date;
        -- select  i_process_date,
        --         a.account_id,
        --         a.account_type,
        --         a.currency,
        --         a.settle_balance,    -- 是不是收利息要看客户是否真的欠款了
        --         b.prime_rate,
        --         b.saving_rate,
        --         b.debit_formula_type,
        --         b.debit_formula_code,
        --         b.credit_formula_type,  
        --         b.credit_formula_code, 
        --         0.0,  -- debit
        --         0.0,  -- credit
        --         'N'  -- waive
        -- from account_balance a 
        -- left join currency b on a.currency = b.currency
        -- where process_date = v_process_date;

        update account_interest a
        inner join  account_interest_rule b on a.account_id = b.account_id and a.currency = b.currency 
        set
            a.debit_formula_code = b.debit_formula_code,
            a.credit_formula_code = b.credit_formula_code
        where a.process_date = i_process_date; 
        
        
        open cur_interest; 
        set v_done =0; 
        fetch cur_interest into v_id,v_formula_value,v_formula_value2;  
        while v_done <> 1 do 
            
            set @sql = concat("update account_interest 
                               set 
                               debit_interest_rate = (", v_formula_value, ")/365/100," 
                              ,"debit_interest = case when Bal < 0 then round(-1*Bal*(",v_formula_value,")/365/100, 2) else 0 end where id = ",v_id,";");
            prepare stmt from @sql; 
            execute stmt; 

            set @sql = concat("update account_interest 
                               set 
                               credit_interest_rate = (",v_formula_value2, ")/365/100,"
                               ,"credit_interest = case when Bal > 0 then round(Bal*(",v_formula_value2,")/365/100, 2) else 0 end where id = ", v_id,";");
            prepare stmt from @sql; 
            execute stmt; 
            
            set v_done =0; 
            fetch cur_interest into v_id,v_formula_value,v_formula_value2;  
        end while; 
    /* end if;  */

    /* 
	-- 汇总出入金产生的利息：头一天结算完切日之后，第二天之前的出入金
    drop temporary table if exists tmp_cash_interest;
    create temporary table tmp_cash_interest
    (
        account_id varchar(16), 
        currency varchar(1),
        credit_interest DECIMAL(30,10), 
        debit_interest DECIMAL(30,10), 
        index idx1(account_id,currency)
    );

    insert into tmp_cash_interest
    (
        account_id,
        currency,
        credit_interest,
        debit_interest
    )
    select 
        t.account_id,
        t.currency,
        case when round(sum(t.interest) - sum(t.credit_interest - t.debit_interest),2) > 0 then round(sum(t.interest) - sum(t.credit_interest - t.debit_interest),2) else 0 end,
        case when round(sum(t.interest) - sum(t.credit_interest - t.debit_interest),2) < 0 then -1*round(sum(t.interest) - sum(t.credit_interest - t.debit_interest),2) else 0 end
    from(
        select 
            b.update_time,
            b.account_id,
            b.currency,
            ifnull(a.Bal,0) as Bal,
            case when ifnull(a.debit_interest,'') = '' then 0 else a.debit_interest end as debit_interest,
            case when ifnull(a.credit_interest,'') = '' then 0 else a.credit_interest end as credit_interest,
            round(case when (ifnull(a.Bal,0) + b.amt)>=0 
                       then (ifnull(a.Bal,0) + b.amt)* (case when ifnull(a.credit_interest_rate,'') = '' then d.credit_interest_rate else a.credit_interest_rate end) 
                       else (ifnull(a.Bal,0) + b.amt)* (case when ifnull(a.debit_interest_rate,'') = '' then d.debit_interest_rate else a.debit_interest_rate end) 
                    end,2) * day_num as interest,
            case when ifnull(a.credit_interest_rate,'') = '' then d.credit_interest_rate else a.credit_interest_rate end as debit_interest_rate,
            case when ifnull(a.credit_interest_rate,'') = '' then d.credit_interest_rate else a.credit_interest_rate end as credit_interest_rate,
            b.amt
        from account_interest a 
        right join (
            select 
            c.process_date,
            DATE_FORMAT(c.update_time,'%Y-%m-%d') as update_time,
            datediff(DATE_FORMAT(c.process_date,'%Y%m%d'), DATE_FORMAT(c.update_time,'%Y%m%d')) as day_num,
            c.account_id,
            c.currency,
            sum(case c.purpose when 1 then 1 else -1 end * c.amount) as amt 
            from cash_flow c where c.process_date = i_process_date and c.process_date <> DATE_FORMAT(c.update_time,'%y-%m-%d')
            group by process_date,DATE_FORMAT(c.update_time,'%Y-%m-%d'),account_id,currency
        ) b on a.process_date >= b.update_time and a.process_date < b.process_date and a.account_id = b.account_id and a.currency = b.currency
        inner join account_interest d on d.process_date = i_process_date and d.account_id = b.account_id and d.currency = b.currency
    ) t
    group by t.account_id,t.currency;

    -- 出入金流水中value date不等于结算日的资金产生的利息
    update account_interest a
    inner join tmp_cash_interest b on b.account_id = a.account_id and b.currency = a.currency
    set a.debit_interest = ifnull(a.debit_interest,0) + ifnull(b.debit_interest,0),
        a.credit_interest = ifnull(a.credit_interest,0) + ifnull(b.credit_interest,0)
    where a.process_date = i_process_date;  
*/

    -- 今日利息调整  
    update account_balance a
        inner join account_interest_adj b on i_process_date = b.process_date and a.account_id = b.account_id and a.account_type = b.account_type and a.currency = b.currency
        set a.accrued_interest = a.accrued_interest + (case when b.adj_interest < 0 then b.adj_interest else 0 end ),
            a.accrued_interest_credit = a.accrued_interest_credit + (case when b.adj_interest > 0 then b.adj_interest else 0 end ), 
            a.interest = a.interest + b.adj_interest
        where a.process_date = v_process_date; 

    -- 成交撤销或出入金撤销产生的利息
    UPDATE account_interest a
    left join cancel_cash_flow b on b.process_date = i_process_date and b.account_id = a.account_id and b.account_type = a.account_type and b.currency = a.currency
    set a.debit_interest = a.debit_interest + (case when ifnull(b.interest,0) < 0 then ifnull(b.interest,0) else 0 end),
        a.credit_interest = a.credit_interest + (case when ifnull(b.interest,0) > 0 then ifnull(b.interest,0) else 0 end)
    where a.process_date = i_process_date;

    -- 更新累计利息
    drop temporary table if exists tmp_interest;
    create temporary table tmp_interest
    (
       account_id varchar(16), 
       account_type int,
       currency int , 
       debit_interest decimal(30,10) default 0 , 
       credit_interest decimal(30,10) default 0,
       debit_interest_rate decimal(30,10) default 0, 
       credit_interest_rate decimal(30,10) default 0,
       index idx1(account_id,account_type,currency)  
    ); 

    -- 删掉冗余数据
    delete from account_interest where process_date = i_process_date and  credit_interest = 0 and debit_interest  = 0; 

    -- 汇总余新收入的利息
    insert into tmp_interest
    select a.account_id,b.account_type,a.currency,(ifnull(a.debit_interest,0)), (ifnull(a.credit_interest,0)),a.debit_interest_rate, a.credit_interest_rate
    from account_interest a
    inner join capital_account b on a.account_id = b.account_id 
    where process_date  = i_process_date;

    -- 计算融券利息
    delete from borrow_fee_flow where process_date = i_process_date;
    INSERT INTO borrow_fee_flow(process_date, account_id, account_type, market_id, product_id, custodian_code,custodian_account, currency, quantity, borrow_fee_rate, borrow_fee)
    SELECT i_process_date, a.account_id, a.account_type, a.market_id, a.product_id,  a.custodian_code, a.custodian_account, a.currency, a.quantity,
        ROUND(ifnull(b.borrow_fee/100,0)/360,6) AS borrow_fee_rate, abs(ROUND(a.market_value*ROUND(ifnull(b.borrow_fee/100,0)/360,6),2)) AS borrow_fee
    FROM account_position a 
    LEFT JOIN borrow_list b ON a.process_date=b.process_date AND a.market_id=b.market_id AND a.product_id=b.product_id
    WHERE a.process_date=v_process_date AND a.quantity<0 AND a.market_id in ('2','16');

    -- 删除冗余数据
    delete from borrow_fee_flow where process_date = i_process_date and borrow_fee = 0; 

    -- 计算成本价
    update account_position a 
    inner join borrow_fee_flow b on i_process_date = b.process_date and a.market_id = b.market_id and a.product_id = b.product_id and a.account_id = b.account_id and a.account_type = b.account_type and a.custodian_code = b.custodian_code and a.custodian_account = b.custodian_account
    inner join product c on c.list_market_id = a.market_id and c.product_id = a.product_id 
    set a.position_cost = case when a.net_quantity = 0 then 0 else a.position_cost + b.borrow_fee end
    where a.process_date = v_process_date; 

    update account_position a 
    inner join borrow_fee_flow b on i_process_date = b.process_date and a.market_id = b.market_id and a.product_id = b.product_id and a.account_id = b.account_id and a.account_type = b.account_type and a.custodian_code = b.custodian_code and a.custodian_account = b.custodian_account
    inner join product c on c.list_market_id = a.market_id and c.product_id = a.product_id 
    set a.avg_price1 = round(case when a.net_quantity = 0 then 0 else a.position_cost/a.net_quantity/ifnull(c.price_factor,1) end, 6)
    where a.process_date = v_process_date; 

    -- 融券利息汇总
    drop temporary table if exists tmp_borrow_fee_summary;
    create temporary table tmp_borrow_fee_summary
    (
       account_id varchar(16), 
       account_type int,
       currency int , 
       borrow_fee decimal(30,10), 
       index idx1(account_id,account_type,currency)  
    ); 
    insert into tmp_borrow_fee_summary
    select a.account_id, a.account_type, a.currency, sum(borrow_fee)
    from borrow_fee_flow a
    where process_date  = i_process_date
    group by a.account_id, a.account_type, a.currency;

    update account_balance a 
        left join tmp_interest b on  a.account_id = b.account_id and a.account_type = b.account_type and a.currency =b.currency
        left join tmp_borrow_fee_summary c on  a.account_id = c.account_id and a.account_type  = c.account_type and a.currency = c.currency
        set a.accrued_interest = a.accrued_interest + ifnull((b.debit_interest),0) + ifnull(c.borrow_fee,0),
            a.accrued_interest_credit = a.accrued_interest_credit + ifnull((b.credit_interest),0),
            a.interest = ifnull((b.credit_interest),0) - ifnull((b.debit_interest),0) - ifnull(c.borrow_fee,0),
            a.debit_interest_rate = ifnull(b.debit_interest_rate,0),
            a.credit_interest_rate = ifnull(b.credit_interest_rate,0)
        where a.process_date = v_process_date;

    set o_ret_code = 0; 
    set o_ret_msg = "利息计算完成";

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCalInterest
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCalInterest`;
delimiter ;;
CREATE PROCEDURE `proCalInterest`(OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin
    declare v_process_date date; 
    declare v_last_process_date  date; 
    declare v_done int; 
    declare v_formula_value char(255); 
    declare v_formula_value2 char(255); 
    declare v_id bigint;  
    declare v_date date ; 
    declare v_last_month_date date; 
    declare v_day1 date; 
    declare v_day2 date; 
    declare v_end_date date; 
    declare v_sum_date_s date; 
    declare v_sum_date_e date; 

    declare cur_interest cursor for
        select a.id, b.formula_value, c.formula_value
        from account_interest a
        left join formula b on a.debit_formula_type = b.formula_type and a.debit_formula_code = b.formula_code
        left join formula c on a.credit_formula_type = c.formula_type and a.credit_formula_code = c.formula_code;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done=1;

    start transaction;
    select buss_date,last_buss_date  into v_process_date,v_last_process_date from sys_info; 
    
    delete from account_interest where process_date  = v_process_date; 

    
    call proSettleCashFlow(v_process_date,o_ret_code,o_ret_msg); 
    if o_ret_code then 
        rollback; 
        leave label; 
    end if; 

    call proCalDayInterest(v_process_date,o_ret_code,o_ret_msg);
    if o_ret_code then 
        rollback; 
        leave label;
    end if; 

    set v_sum_date_s = v_process_date;
    set v_sum_date_e = v_process_date; 
    
    set v_end_date = NULL; 
    if date_format(v_process_date,'%w') = 5 then 
        
        set v_day1 = date_add(v_process_date,interval 1 day); 
        set v_day2 = date_add(v_process_date,interval 2 day); 
        set v_last_month_date = last_day(v_process_date);

        
        if v_day1 = v_last_month_date then 
            call proCalDayInterest(v_day1,o_ret_code,o_ret_msg);
            if o_ret_code then 
                rollback; 
                leave label;
            end if; 
        end if; 

        
        if v_day2 = v_last_month_date then 
            call proCalDayInterest(v_day1,o_ret_code,o_ret_msg);
            if o_ret_code then 
                rollback; 
                leave label;
            end if; 

            call proCalDayInterest(v_day2,o_ret_code,o_ret_msg);
            if o_ret_code then 
                rollback; 
                leave label;
            end if; 
        end if;     

    end if; 

    

  

    set o_ret_code = 0; 
    set o_ret_msg = "利息计算完成";

    commit;
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCalPositionCost
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCalPositionCost`;
delimiter ;;
CREATE PROCEDURE `proCalPositionCost`(i_date_from date, 
    i_date_to date,   
    i_market_id int,  
    i_product_id varchar(16))
label: BEGIN



    declare v_pre_date_from date; 
    declare v_day date; 
    declare v_ipo_id varchar(64); 
    declare v_type int; 


    
    drop table if exists tmp_proCalPositionCost_position; 
    create temporary table tmp_proCalPositionCost_position
    (
        market_id int, 
        product_id varchar(16), 
        account_id varchar(16),
        net_quantity decimal(30,10), 
        position_cost decimal(30,10), 
        avg_price decimal(30,10),
        index idx(market_id,product_id,account_id), 
        index idx2(net_quantity)
    );

    
    select ipo_id 
    into v_ipo_id 
    from product_ipo_announcement 
    where list_market_id = i_market_id and
          product_id = i_product_id and 
          allot_date = i_date_from; 

    if v_ipo_id is not null then 
        
        insert into tmp_proCalPositionCost_position
        select  list_market_id, 
                product_id, 
                account_id, 
                allot_qty,  
                amount+charge+loan_charge+interest - refund_amount, 
                0 as avg_price
        from product_ipo_app 
        where ipo_id = v_ipo_id and sub_status = 2;
    else 
        
        select max(process_date) 
        into v_pre_date_from 
        from  account_position
        where process_date < i_date_from and 
              market_id  = i_market_id and 
              product_id = i_product_id; 

        if v_pre_date_from is null then 
            
            set v_pre_date_from = v_pre_date_from; 
        end if; 

        insert into tmp_proCalPositionCost_position
        select  market_id, 
                product_id, 
                account_id, 
                net_quantity,  
                position_cost, 
                0 as avg_price
        from account_position 
        where process_date = v_pre_date_from and 
              market_id = i_market_id and 
              product_id = i_product_id and 
              net_quantity <> 0; 
    end if; 

    
    drop table if exists tmp_cost_cal; 
    create temporary table tmp_cost_cal
    (
       type int, 
       process_date date, 
       market_id int, 
       product_id varchar(16), 
       account_id varchar(16), 
       net_quantity decimal(30,10), 
       net_cost decimal(30,10), 
       code int, 
       index idx(type,process_date, market_id, product_id, account_id), 
       index idx2(type,process_date, market_id, product_id, code)
    );
    
    insert into tmp_cost_cal
    select 1,
           a.process_date, 
           a.market_id, 
           a.product_id,
           a.account_id, 
           sum(case when buy_sell = 1 then 1 else -1 end *a.quantity) as net_quantity, 
           sum(case when buy_sell = 1 then 1 else -1 end *a.net_amount) as net_cost, 
           0 as code
    from account_trade a 
    inner join product_ipo_app b on b.ipo_id = v_ipo_id and b.account_id = a.account_id and b.sub_status = 2
    where a.process_date >=i_date_from and a.process_date <=i_date_to and 
          a.market_id = i_market_id and 
          a.product_id = i_product_id 
    group by a.process_date,a.market_id,a.product_id,a.account_id;


    
    insert into tmp_cost_cal
    select 2,
           a.process_date, 
           a.dividend_market_id, 
           a.dividend_product_id,
           a.account_id, 
           0, 
           sum(case when purpose = 2 then 1 else -1 end *a.amount) as net_cost, 
           0 as code
    from cash_flow a 
    inner join product_ipo_app b on b.ipo_id = v_ipo_id and b.account_id = a.account_id and b.sub_status = 2
    where a.process_date >=i_date_from and a.process_date <=i_date_to and 
          a.dividend_market_id = i_market_id and 
          a.dividend_product_id = i_product_id and 
          a.reference <> ifnull(v_ipo_id,'') 
    group by a.process_date,a.dividend_market_id,a.dividend_product_id,a.account_id;


    
    insert into tmp_cost_cal
    select 3,
           a.process_date, 
           a.market_id, 
           a.product_id,
           a.account_id, 
           sum(case when purpose = 1 then 1 else -1 end *a.quantity) as net_quantity, 
           sum(case when purpose = 1 then 1 else - 1 end *a.quantity*a.avg_price) as net_cost,  
           0 as code
    from product_flow a
    inner join product_ipo_app b on b.ipo_id = v_ipo_id and b.account_id = a.account_id and b.sub_status = 2
    where a.process_date >=i_date_from and process_date <=i_date_to and 
          a.market_id = i_market_id and 
          a.product_id = i_product_id and 
          (a.remark not like 'Successful IPO%' and a.remark not like '%Placing Order%')  
    group by a.process_date,a.market_id,a.product_id,a.account_id;


    
    set v_day = i_date_from; 
    while  v_day <= i_date_to do 
        
        
        set v_type= 1; 
        while v_type<=3 do
            
            update tmp_proCalPositionCost_position a 
            inner join tmp_cost_cal b on b.type = v_type and b.process_date = v_day and a.market_id= b.market_id and a.product_id = b.product_id and a.account_id = b.account_id
            set a.net_quantity = a.net_quantity + b.net_quantity, 
                a.position_cost = a.position_cost + b.net_cost, 
                b.code = 1; 
            
            
            insert into tmp_proCalPositionCost_position
            select market_id, 
                product_id, 
                account_id,
                net_quantity, 
                net_cost,
                0
            from tmp_cost_cal 
            where type = v_type and 
                process_date = v_day and 
                market_id = i_market_id and 
                product_id = i_product_id and 
                code = 0;

            set v_type = v_type + 1;
        end while; 

        
        update tmp_proCalPositionCost_position a 
        set position_cost = 0 
        where net_quantity = 0; 

        
        set v_day = date_add(v_day, interval 1 day); 
        if date_format(v_day,'%w') = 6 then 
            
            set v_day = date_add(v_day, interval 2 day); 
        end if; 
    end while; 

    
    update  tmp_proCalPositionCost_position 
    set avg_price = case when net_quantity = 0 then 0 else round(position_cost/net_quantity,6) end; 

    
    select * from tmp_proCalPositionCost_position; 

    
    
    
    
    
    
    
    
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCancelCash
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCancelCash`;
delimiter ;;
CREATE PROCEDURE `proCancelCash`(IN  i_id int, 
    IN  i_update_user varchar(32), 
    In  i_update_time datetime,
    OUT o_ret_code int,
    OUT o_ret_msg char(128))
label:begin
    declare v_buss_date date; 
    declare v_process_date date;  
    declare v_account_id varchar(16); 
    declare v_account_type int; 
    declare v_amount decimal(30,10); 
    declare v_currency varchar(1);
    declare v_remark varchar(256);
    declare v_dividend_market_id int; 
    declare v_dividend_product_id varchar(32); 
    declare v_custodian_code varchar(16); 
    declare v_custodian_account varchar(16); 
    
    set o_ret_code = 0; 
    set o_ret_msg = 'Success';

    start transaction; 

    -- check bussness date
    select buss_date into v_buss_date from sys_info; 
    if v_buss_date is NULL then 
        set o_ret_code = 1, o_ret_msg = "Bussness date not setting up"; 
        leave label; 
    end if; 

    if EXISTS (select 1 from cash_flow where id = i_id and status = 'Cancelled') then
        set o_ret_code = 1, o_ret_msg = "this cash flow had Cancelled"; 
        leave label; 
    end if;

    select process_date,account_id,account_type,currency,
           case purpose when 1 then -1 when 2 then 1 end * amount, remark,dividend_market_id,dividend_product_id,custodian_code,custodian_account
    into  v_process_date,v_account_id,v_account_type,v_currency,v_amount,v_remark,v_dividend_market_id,v_dividend_product_id,v_custodian_code,v_custodian_account
    from cash_flow where id = i_id;

    -- 更新客户类型
    select account_type into v_account_type from capital_account where account_id = v_account_id;

    set v_remark = concat("Cash_Cancel:",v_remark);
     
    call proCancelForAmount(
        v_process_date,NULL,v_account_id,v_account_type,v_currency,v_amount,v_amount,v_remark,v_dividend_market_id,v_dividend_product_id,v_custodian_code,v_custodian_account,
        i_update_user, i_update_time,o_ret_code,o_ret_msg);
    if o_ret_code then 
        rollback; 
        leave label; 
    end if;

    update cash_flow set status = 'Cancelled' where id = i_id;

    COMMIT;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCancelCashFlow
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCancelCashFlow`;
delimiter ;;
CREATE PROCEDURE `proCancelCashFlow`(IN i_proces_date date,
  IN i_settle_date date,
  IN i_trade_id varchar(32),
  IN i_account_id char(16),
  IN i_account_type int,
  IN i_currency int,
  IN i_trade_amount decimal(30,6),
  IN i_settle_amount decimal(30,6),
  IN i_interest decimal(30,6),
  In i_dividend_market_id varchar(16), 
  In i_dividend_product_id varchar(32),
  In i_custodian_code varchar(16), 
  In i_custodian_account varchar(16),
  In i_remark varchar(256), 
  IN  i_update_user varchar(32), 
  IN  i_update_time datetime)
label:begin

    insert into cancel_cash_flow
    (
        process_date,
        settle_date,
        trade_id,
        account_id,
        account_type,
        currency,
        trade_amount,
        settle_amount,
        interest,
        dividend_market_id,
        dividend_product_id,
        custodian_code,
        custodian_account,
        remark,
        update_user,
        update_time
    )
    select 
          i_proces_date,
          i_settle_date,
          i_trade_id,
          i_account_id,
          i_account_type,
          i_currency,
          i_trade_amount,
          i_settle_amount,
          i_interest,
          i_dividend_market_id,
          i_dividend_product_id,
          i_custodian_code,
          i_custodian_account,
          i_remark,
          i_update_user,
          i_update_time;

end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCancelForAmount
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCancelForAmount`;
delimiter ;;
CREATE PROCEDURE `proCancelForAmount`(In i_settle_date date,
   IN i_trade_id varchar(32),
   In i_account_id char(16),
   In i_account_type int,
   In i_currency int,
   In i_trade_amount decimal(30,10),
   In i_settle_amount decimal(30,10),
   In i_remark varchar(256), 
   In i_dividend_market_id varchar(16), 
   In i_dividend_product_id varchar(32),
   In i_custodian_code varchar(16), 
   In i_custodian_account varchar(16),
   IN  i_update_user varchar(32), 
   IN  i_update_time datetime,
   Out o_code int,
   Out o_message varchar(128))
label:begin
    declare v_buss_date date;
    declare v_day_end_performed varchar(1); 
    declare v_balance decimal(30,10) default 0.0;
    declare v_done int; 
    declare v_bal decimal(30,10) default 0.0;
    declare v_debit_interest_rate decimal(30,10) default 0.0; 
    declare v_credit_interest_rate decimal(30,10) default 0.0; 
    declare v_interest decimal(30,10) default 0.0;
    declare v_debit_interest decimal(30,10) default 0.0;
    declare v_credit_interest decimal(30,10) default 0.0;
    declare v_true_date date; 
    declare v_day2 date;

    declare cur_interest cursor for
        select ifnull(a.bal,0),ifnull(a.debit_interest_rate,0),ifnull(a.credit_interest_rate,0)
        from account_interest a 
        where a.process_date >= i_settle_date and a.process_date <= v_true_date and i_settle_date <= v_buss_date and 
              a.account_id = i_account_id and a.currency = i_currency;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done=1;

    select buss_date,day_end_performed into v_buss_date,v_day_end_performed from sys_info; 
    if v_buss_date is NULL then 
        set o_code = 1, o_message = "Bussness date not setting up"; 
        leave label; 
    end if; 

   if i_dividend_market_id <>  ''  and i_dividend_product_id <> ''  and   not EXISTS(select 1 from product where list_market_id=i_dividend_market_id and product_id = i_dividend_product_id) then 
        set o_code = 1; 
        set o_message = concat('unkonw market-product'); 
        leave label; 
   end if; 

   if i_dividend_market_id = '' then 
        set i_dividend_market_id = '0'; 
    end if; 
    
    set v_true_date = v_buss_date;
    if date_format(v_buss_date,'%w') = 5 then 
        set v_day2 = date_add(v_buss_date,interval 2 day); 
        if EXISTS (select 1 from account_interest a where a.process_date = v_day2 and a.account_id = i_account_id and a.account_type = i_account_type and a.currency = i_currency ) then 
            set v_true_date = v_day2;
        end if;
    end if;

    if not EXISTS (select 1 from account_balance where process_date = v_buss_date and account_id = i_account_id and account_type = i_account_type and currency = i_currency) then 
        call proCreateAccountBalance(v_buss_date, i_account_id,i_account_type,i_currency);
    end if; 

    update account_balance a
        set trade_balance = trade_balance + i_trade_amount,
            settle_balance = settle_balance + i_settle_amount,
            -- settle_balance就是交收后的余额，在手资金，trade_balance就是交收+未交收
            -- 客户权益，代表着如果客户把所有的仓都变现后，可以获取多少钱；（frozen_amount里面之前是包含利息的，现在既然单独了字段，就改成不包含利息）
            a.equity_balance = a.trade_balance  + a.unrealized_pnl + market_value  - accrued_interest + accrued_interest_credit,
            -- 利息如果是负的就不可用
            a.balance_avail =   funMax(a.trade_balance + funMin(accrued_interest_credit- a.accrued_interest,0)  -a.frozen_amount - a.margin_amt,0),
            -- 利息为负不可取，持仓盈亏和市值：如果为负，就不可取，为正就认为是0
            a.balance_extract = funMax(a.settle_balance + /*funMIN(0,a.unrealized_pnl) +*/ + funMIN(a.unsettled_amount,0) + funMin(a.accrued_interest_credit- a.accrued_interest,0) - a.margin_amt  + funMIN(0,a.market_value) - a.frozen_amount,0),
            -- 用这个来算现在总共欠了多少款，需要追加保证金，或者入金
            -- 也就是说客户现在权益在减去冻结的资金（如保证金等，冻结资金等）如果为负，那就代表危险了要入金了
            a.equity = a.equity_balance  - a.margin_amt - a.frozen_amount
        where process_date = v_buss_date and 
              account_id =i_account_id and 
              account_type = i_account_type and
              currency = i_currency;

    -- 计算开仓成本 
    update account_position a 
    inner join product b on b.list_market_id = a.market_id and b.product_id = a.product_id 
    set a.position_cost = a.position_cost - i_trade_amount
    where a.process_date = v_buss_date and 
          a.market_id = i_dividend_market_id and 
          a.product_id = i_dividend_product_id and 
          a.account_id = i_account_id and 
          a.account_type = i_account_type and 
          a.custodian_code = i_custodian_code and 
          a.custodian_account = i_custodian_account; 

    update account_position a 
    inner join product b on b.list_market_id = a.market_id and b.product_id = a.product_id 
    set a.avg_price1 = round(case when a.net_quantity = 0 then 0 else a.position_cost/a.net_quantity/ifnull(b.price_factor,1) end, 6)
    where a.process_date = v_buss_date and 
          a.market_id = i_dividend_market_id and 
          a.product_id = i_dividend_product_id and 
          a.account_id = i_account_id and 
          a.account_type = i_account_type and 
          a.custodian_code = i_custodian_code and 
          a.custodian_account = i_custodian_account; 

    -- 利息计算 
    -- 计算 settle_date 到 process_date 之间的利息;
    -- settle_date > process_date不计算利息;
    -- settle_date = process_date,结算标志'Y',需计算利息，'N',不需要计算利息;
    set v_interest = 0;
    set v_credit_interest = 0;
    set v_debit_interest = 0;

    open cur_interest; 
        set v_done =0; 
        fetch cur_interest into v_bal,v_debit_interest_rate,v_credit_interest_rate;  
        while v_done <> 1 do 
                set v_bal = v_bal + i_settle_amount;
                if v_bal > 0 then
                    set v_credit_interest = v_credit_interest + round(v_bal * v_credit_interest_rate,2);
                elseif v_bal < 0 then
                    set v_debit_interest = v_debit_interest + round(v_bal * v_debit_interest_rate,2);
                end if;
                
            set v_done =0; 
            fetch cur_interest into v_bal,v_debit_interest_rate,v_credit_interest_rate;  
        end while; 
    close cur_interest;
    -- 应收利息
    set v_interest = v_credit_interest + v_debit_interest;
    set v_credit_interest = 0;
    set v_debit_interest = 0;
    -- 实际收取的利息
    select ifnull(sum(debit_interest),0),ifnull(sum(credit_interest),0)
    into v_debit_interest,v_credit_interest
    from account_interest a where a.process_date >= i_settle_date and a.process_date <= v_true_date and 
              a.account_id = i_account_id and a.currency = i_currency;
    -- 应收- 实际(撤销产生的利息)
    set v_interest = v_interest - v_credit_interest - v_debit_interest;

    -- 当日结算完后撤销的成交或出入金，修改当日利息和累计利息；非结算完，利息处理时将撤销相关利息增加到当日结算利息中
    if EXISTS (select 1 from account_interest a where a.process_date = v_true_date and a.account_id = i_account_id and a.account_type = i_account_type and a.currency = i_currency ) and v_interest <> 0 then
        update account_interest a 
        set a.debit_interest = a.debit_interest + case when v_interest < 0 then -1*v_interest else 0 end,
            a.credit_interest = a.credit_interest + case when v_interest > 0 then v_interest else 0 end
        where a.process_date = v_true_date and a.account_id = i_account_id and a.account_type = i_account_type and a.currency = i_currency;

        update account_balance a 
        set a.accrued_interest = a.accrued_interest + (case when v_interest < 0 then -1*v_interest else 0 end ),
            a.accrued_interest_credit = a.accrued_interest_credit + (case when v_interest > 0 then v_interest else 0 end ), 
            a.interest = a.interest + v_interest,
            a.equity_balance = a.trade_balance  + a.unrealized_pnl + market_value  - accrued_interest + accrued_interest_credit,
            -- 利息如果是负的就不可用
            a.balance_avail =   funMax(a.trade_balance + funMin(accrued_interest_credit- a.accrued_interest,0)  -a.frozen_amount - a.margin_amt,0),
            -- 利息为负不可取，持仓盈亏和市值：如果为负，就不可取，为正就认为是0
            a.balance_extract = funMax(a.settle_balance + /*funMIN(0,a.unrealized_pnl) +*/ + funMIN(a.unsettled_amount,0) + funMin(accrued_interest_credit- a.accrued_interest,0) - a.margin_amt  + funMIN(0,a.market_value) - a.frozen_amount,0),
            -- 用这个来算现在总共欠了多少款，需要追加保证金，或者入金
            -- 也就是说客户现在权益在减去冻结的资金（如保证金等，冻结资金等）如果为负，那就代表危险了要入金了
            a.equity = a.equity_balance  - a.margin_amt - a.frozen_amount
        where a.process_date = v_buss_date and a.account_id = i_account_id and a.account_type = i_account_type and a.currency = i_currency;
    end if;

   call proCancelCashFlow(
        v_buss_date,
        i_settle_date,
        i_trade_id,
        i_account_id,
        i_account_type,
        i_currency,
        i_trade_amount,
        i_settle_amount,
        v_interest,
        i_dividend_market_id,
        i_dividend_product_id,
        i_custodian_code,
        i_custodian_account,
        i_remark, 
        i_update_user, 
        i_update_time
    );

   set o_code = 0; 
   set o_message = "Success";
end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCancelForQuantity
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCancelForQuantity`;
delimiter ;;
CREATE PROCEDURE `proCancelForQuantity`(IN  i_settle_date date,
  IN  i_account_id varchar(16), 
  IN  i_trade_id varchar(32), 
  IN  i_account_type int,
  IN  i_market_id int, 
  IN  i_product_id varchar(32), 
  IN  i_product_type int,
  IN  i_currency varchar(16), 
  IN  i_quantity decimal(30,10),
  IN  i_net_quantity decimal(30,10),
  IN  i_custodian_code varchar(16), 
  IN  i_custodian_account varchar(16), 
  IN  i_avg_price decimal(30,10), 
  In  i_remark varchar(128),
  In  i_update_user varchar(32), 
  In  i_update_time datetime,
  OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin
    declare v_id int default NULL; 
    declare v_buss_date date default NULL;
    declare v_last_buss_date date default NULL;
    declare v_process_date date default NULL;
    declare v_true_date date default NULL;
    declare v_dayend_performed varchar(1); 
    declare v_market_value decimal(30,10) default 0; 
    declare v_exchange_rate decimal(30,10) default 0.0000;
    declare v_portfolio_fee decimal(30,10) default 0.0000;
    declare v_tmp_portfolio_fee decimal(30,10) default 0.0000;
    declare v_avg_price decimal(30,10) default 0.0000;
    declare v_tmp_amount decimal(30,10) default 0.0000;
    declare v_base_charge_amount decimal(30,10) default 0.0000;
    declare v_formula varchar(255) default '0';
    declare v_done int; 


    declare cur_portfolio cursor for
        select a.process_date,sum(a.market_value)
        from tmp_account_position a
        group by a.process_date;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done=1;

    -- check bussness date 
    select buss_date,last_buss_date,day_end_performed into v_buss_date,v_last_buss_date,v_dayend_performed from sys_info; 
    if v_buss_date is NULL then 
        set o_ret_code = 1, o_ret_msg = "Bussness date not setting up"; 
        leave label; 
    end if; 

    -- check account
    if not EXISTS(select 1 from capital_account where account_id = i_account_id) then 
        set o_ret_code = 1, o_ret_msg = "Account not exists"; 
        leave label; 
    end if; 

    -- check product 
    if not EXISTS(select 1 from product where list_market_id  = i_market_id and product_id = i_product_id) then 
        set o_ret_code = 1, o_ret_msg = "Product not exists"; 
        leave label; 
    end if; 
    -- 判断本日是否已结算 已结算，取buss_date日期，未结算，取last_buss_date
    set v_true_date = v_buss_date;
    if EXISTS (select 1 from account_portfolio_fee where process_date = v_buss_date) then 
        if date_format(v_buss_date,'%w') = 5 then 
            set v_true_date = date_add(v_buss_date,interval 2 day); 
        else 
            set v_true_date = v_buss_date;
        end if;
    else
        set v_true_date = v_last_buss_date;
    end if;

    -- select round(exchange_rate,6) into v_exchange_rate from currency where currency = 1;

    -- 中华通需计算证券组合费
    if i_market_id = 4 or i_market_id = 8 then
        drop temporary table if exists tmp_account_position; 
        create temporary table tmp_account_position
        (    
        process_date date,
        market_id int,
        account_id varchar(16),
        product_id varchar(32),
        product_type int,
        currency int,
        net_quantity decimal(30,10), -- 净持仓数量
        market_value decimal(30,10),
        closing_price decimal(30,10),
        custodian_code varchar(16),
        custodian_account varchar(16),
        index idx1(process_date,market_id,product_id,account_id)
        ); 
    
        insert into tmp_account_position
        (
            process_date,
            market_id, 
            account_id,  
            product_id, 
            product_type, 
            currency, 
            net_quantity, 
            market_value,
            closing_price, 
            custodian_code,
            custodian_account
        )
        select 
            process_date,
            market_id, 
            account_id, 
            product_id, 
            product_type, 
            currency, 
            net_quantity, 
            market_value,
            closing_price, 
            custodian_code,
            custodian_account
        from account_position 
        where process_date >= i_settle_date and process_date <= v_true_date and account_id = i_account_id and market_id = i_market_id;
        -- 计算应收证券组合费的市值
        update tmp_account_position a
        set net_quantity = net_quantity + i_net_quantity,
            market_value = (case when net_quantity <= 0 then 0 else net_quantity end) * closing_price
        where process_date >= i_settle_date and process_date <= v_true_date and 
                a.market_id = i_market_id and a.product_id = i_product_id and a.account_id = i_account_id and 
                a.custodian_code = i_custodian_code and a.custodian_account = i_custodian_account;

        -- 计算证券组合费
        select 
            formula_value
        into 
            v_formula
        from formula 
        where formula_code = 'PORTFOLIO_FEE_SHA';

        set v_portfolio_fee = 0;
        set v_tmp_portfolio_fee = 0;
        open cur_portfolio; 
            set v_done =0; 
            fetch cur_portfolio into v_process_date,v_market_value;
            while v_done <> 1 do
                set v_exchange_rate = 0;
                if EXISTS (select 1 from currency_history where process_date = v_process_date) then 
                    select exchange_rate into v_exchange_rate from currency_history where process_date = v_process_date and currency = 1;
                else
                    if v_process_date = v_buss_date then
                        select exchange_rate into v_exchange_rate from currency where currency = 1;
                    else
                        set o_ret_code = 1, o_ret_msg = concat("exchange_rate not exists:",v_process_date); 
                        leave label; 
                    end if;
                end if;
                
                set v_tmp_amount = 0;
                drop temporary table if EXISTS cal1; 
                create temporary table cal1
                (
                    mv decimal(30,10),   -- base_portfolio_value
                    base_charge_amount decimal(30,10)
                );

                -- 公式表
                insert into cal1 
                (
                    mv
                ) 
                select 
                    v_market_value * v_exchange_rate;
                
                SET @sql = CONCAT('update cal1 ',
                            'set base_charge_amount = ', v_formula, ' ');
                PREPARE stmt FROM @sql;
                EXECUTE stmt;

                select base_charge_amount into v_tmp_amount from cal1;

                if date_format(v_process_date,'%w') = 5 and v_process_date < v_true_date then
                    set v_tmp_amount = 3*v_tmp_amount;
                end if;
                
                set v_tmp_portfolio_fee = v_tmp_portfolio_fee + v_tmp_amount;
                
                set v_done =0; 
                fetch cur_portfolio into v_process_date,v_market_value;  
            end while; 
        close cur_portfolio;
        -- 应收费用
        set v_portfolio_fee = v_tmp_portfolio_fee;
        
        set v_tmp_portfolio_fee = 0;
        -- 实际收取的费用
        select ifnull(sum(a.base_charge_amount),0)
        into v_tmp_portfolio_fee
        from account_portfolio_fee a 
        where a.process_date >= i_settle_date and a.process_date <= v_true_date and
                a.market_id = i_market_id and a.account_id = i_account_id;
        
        -- 应收 - 实际(撤销产生的托管费)
        set v_portfolio_fee = v_portfolio_fee - v_tmp_portfolio_fee;
        -- 当日结算完后撤销的成交或转仓，修改当日托管费和累计托管费；未结算完，托管费处理时将托管费增加到当日结算托管费中
        if EXISTS (select 1 from account_portfolio_fee where process_date = v_buss_date and 
                        market_id = i_market_id and currency = i_currency and account_type = i_account_type and  account_id = i_account_id ) and v_portfolio_fee <> 0 then
            update account_portfolio_fee
            set base_charge_amount = base_charge_amount + v_portfolio_fee
            where process_date = v_buss_date and market_id = i_market_id and currency = i_currency and account_type = i_account_type and  account_id = i_account_id;

            update account_balance a
            set a.portfolio_fee = a.portfolio_fee + v_portfolio_fee
            where a.process_date = v_buss_date and a.account_id = i_account_id and a.account_type = i_account_type and a.currency = i_currency;
        end if;
    end if;

    select id into v_id
    from account_position 
    where process_date = v_buss_date and 
          market_id = i_market_id and 
          product_id = i_product_id and  
          account_id = i_account_id and  
          account_type = i_account_type and 
          custodian_code = i_custodian_code and 
          custodian_account = i_custodian_account; 
    -- 如果转仓中未提供成本价，则取上一日的成本价
    select round(ifnull(avg_price1,0),6) into v_avg_price 
    from account_position a 
    where a.process_date = case when i_settle_date >= v_buss_date then v_last_buss_date else i_settle_date end and 
        a.market_id = i_market_id and a.product_id = i_product_id and a.account_id = i_account_id and 
        a.custodian_code = i_custodian_code and a.custodian_account = i_custodian_account;

    if v_id is null then 
        insert into account_position 
        (
            process_date, 
            market_id, 
            account_id, 
            account_type, 
            product_type, 
            product_id, 
            currency,
            quantity, 
            net_quantity, 
            frozen_quantity,
            avg_price1, 
            avg_price2,
            custodian_code, 
            custodian_account,
            nominee_quantity,
	    	position_cost
        )
        select 
            v_buss_date,
            i_market_id, 
            i_account_id, 
            i_account_type,
            i_product_type, 
            i_product_id, 
            i_currency,
            i_quantity,
            i_net_quantity, -- net_quantity 
            0, 
            case when ifnull(i_avg_price,0) = 0 then v_avg_price else round(i_avg_price,6) end, 
            0,
            i_custodian_code, 
            i_custodian_account,
            0,
	    	round(case when ifnull(i_avg_price,0) = 0 then v_avg_price else round(i_avg_price,6) end * i_quantity,2);
    else 
        if i_net_quantity > 0 then
            update account_position a
            inner join product b on b.list_market_id = a.market_id and b.product_id = a.product_id 
            set 
                a.position_cost =case when a.net_quantity + i_net_quantity = 0 then 0 else a.position_cost + round(case when ifnull(i_avg_price,0) = 0 then v_avg_price else i_avg_price end * i_net_quantity, 6) end ,  -- 成本价只和可用相关
                a.quantity = a.quantity + i_quantity, 
                a.net_quantity = a.net_quantity + i_net_quantity, 
                a.custodian_code = i_custodian_code, 
                a.custodian_account = i_custodian_account,
                a.avg_price1 = case when a.net_quantity <> 0 then round(a.position_cost/a.net_quantity/ifnull(b.price_factor,1),6) else 0 end,
                avg_price2 = 0,
                a.market_value = a.net_quantity * a.closing_price * ifnull(b.price_factor,1)
            where a.id = v_id; 
        elseif i_net_quantity < 0 then
            update account_position a 
            inner join product b on b.list_market_id = a.market_id and b.product_id = a.product_id 
            set 
                a.position_cost = case when a.net_quantity = 0 then 0 else round(a.position_cost*((a.net_quantity + i_net_quantity)/a.net_quantity),6) end ,   -- 成本价只和可用相关
                a.quantity = a.quantity + i_quantity, 
                a.net_quantity = a.net_quantity + i_net_quantity, 
                a.custodian_code = i_custodian_code, 
                a.custodian_account = i_custodian_account,
                a.market_value = a.net_quantity * a.closing_price
            where a.id = v_id; 

            update account_position a 
            inner join product b on b.list_market_id = a.market_id and b.product_id = a.product_id 
            set 
                a.avg_price1 = case when a.net_quantity <> 0 then round(a.position_cost/a.net_quantity/ifnull(b.price_factor,1),6) else 0 end,
                a.avg_price2 = 0
            where a.id = v_id; 

        end if;
    end if; 

    call proCancelProductFlow(
        v_buss_date,
        i_settle_date,
        i_trade_id,
        i_account_id, 
        i_account_type,
        i_market_id, 
        i_product_id, 
        i_product_type, 
        i_currency,
        i_quantity,
        i_net_quantity,
        v_portfolio_fee,
        i_custodian_code, 
        i_custodian_account, 
        i_avg_price, 
        i_remark,
        i_update_user, 
        i_update_time
    );

    set o_ret_code = 0, o_ret_msg ="Success";
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCancelProduct
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCancelProduct`;
delimiter ;;
CREATE PROCEDURE `proCancelProduct`(IN  i_id int, 
    IN  i_update_user varchar(32), 
    In  i_update_time datetime,
    OUT o_ret_code int,
    OUT o_ret_msg char(128))
label:begin
    declare v_buss_date date; 
    declare v_process_date date; 
    declare v_settle_date date;
    declare v_market_id int; 
    declare v_product_id varchar(32); 
    declare v_account_id varchar(16); 
    declare v_account_type int; 
    declare v_avg_price decimal(30,10); 
    declare v_quantity decimal(30,10); 
    declare v_currency varchar(1);
    declare v_product_type int; 
    declare v_custodian_code varchar(16);
    declare v_custodian_account varchar(16);
    declare v_remark varchar(128);
    set o_ret_code = 0; 
    set o_ret_msg = 'Success';

    start transaction; 

    
    select buss_date into v_buss_date from sys_info; 
    if v_buss_date is NULL then 
        set o_ret_code = 1, o_ret_msg = "Bussness date not setting up"; 
        leave label; 
    end if; 

    if EXISTS (select 1 from product_flow where id = i_id and status = 'Cancelled') then
        set o_ret_code = 1, o_ret_msg = "this product flow had Cancelled"; 
        leave label; 
    end if;

    select process_date,settle_date,account_id,account_type,market_id,product_id,
           case purpose when 1 then -1 when 2 then 1 end * quantity,custodian_code,custodian_account,avg_price,remark
    into  v_process_date,v_settle_date,v_account_id,v_account_type,v_market_id,v_product_id,v_quantity,v_custodian_code,v_custodian_account,v_avg_price,v_remark
    from product_flow where id = i_id;

    set v_remark = concat("Product_Cancel:",v_remark);

    if v_currency is null then 
        select quote_currency into v_currency from market where market_id = v_market_id;
    end if;

    if v_product_type is null then
        select product_type into v_product_type from product where product_id = v_product_id;
    end if;

    
    select account_type into v_account_type from capital_account where account_id = v_account_id;

    call proCancelForQuantity(
        v_settle_date,
        v_account_id, 
        NULL,
        v_account_type,
        v_market_id, 
        v_product_id, 
        v_product_type,
        v_currency,
        v_quantity,
        v_quantity,
        v_custodian_code, 
        v_custodian_account, 
        v_avg_price, 
        v_remark,
        i_update_user, 
        i_update_time,
        o_ret_code,
        o_ret_msg
    );
    if o_ret_code then 
        rollback; 
        leave label; 
    end if; 

    update product_flow set status = 'Cancelled' where id = i_id;

    COMMIT;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCancelProductFlow
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCancelProductFlow`;
delimiter ;;
CREATE PROCEDURE `proCancelProductFlow`(IN i_proces_date date,
  IN i_settle_date date,
  IN i_trade_id varchar(32),
  IN i_account_id char(16),
  IN i_account_type int,
  IN i_market_id int,
  IN i_product_id varchar(32),
  IN i_product_type int,
  IN i_currency int,
  IN i_quantity decimal(30,6),
  IN i_net_quantity decimal(30,6),
  IN i_portfolio_fee decimal(30,6),
  IN i_custodian_code char(16),
  IN i_custodian_account char(16),
  IN i_avg_price decimal(30,6),
  In i_remark char(128), 
  IN i_update_user varchar(32), 
  IN i_update_time datetime)
label:begin

    insert into cancel_product_flow(
        process_date,
        settle_date,
        trade_id,
        account_id,
        account_type,
        market_id,
        product_id,
        product_type,
        currency,
        quantity,
        net_quantity,
        portfolio_fee,
        avg_price,
        custodian_code,
        custodian_account,
        remark,
        update_user,
        update_time
    )
    select 
          i_proces_date,
          i_settle_date,
          i_trade_id,
          i_account_id,
          i_account_type,
          i_market_id,
          i_product_id,
          i_product_type,
          i_currency,
          i_quantity,
          i_net_quantity,
          i_portfolio_fee,
          i_avg_price,
          i_custodian_code,
          i_custodian_account,
          i_remark,
          i_update_user,
          i_update_time; 
end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCancelTrade
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCancelTrade`;
delimiter ;;
CREATE PROCEDURE `proCancelTrade`(IN  i_id int, 
    IN  i_update_user varchar(32), 
    IN  i_update_time datetime,
    OUT o_ret_code int,
    OUT o_ret_msg char(128))
label:begin
    declare v_buss_date date; 
    declare v_settle_date date; 
    declare v_trade_id varchar(32);
    declare v_market_id int; 
    declare v_product_id varchar(32); 
    declare v_account_id varchar(16); 
    declare v_account_type int; 
    declare v_avg_price decimal(30,10); 
    declare v_quantity decimal(30,10); 
    declare v_net_quantity decimal(30,10); 
    declare v_trade_amount decimal(30,10); 
    declare v_settle_balance decimal(30,10); 
    declare v_trade_balance decimal(30,10); 
    declare v_currency varchar(1);
    declare v_buy_sell int; 
    declare v_product_type int; 
    declare v_custodian_code varchar(16);
    declare v_custodian_account varchar(16);
    declare v_remark varchar(128);
    declare v_day_end_performed varchar(1);
    set o_ret_code = 0; 
    set o_ret_msg = 'Success';

    start transaction; 

    
    select buss_date,day_end_performed into v_buss_date,v_day_end_performed from sys_info; 
    if v_buss_date is NULL then 
        set o_ret_code = 1, o_ret_msg = "Bussness date not setting up"; 
        leave label; 
    end if; 

    if EXISTS (select 1 from account_trade where id = i_id and status = 'Cancelled') then
        set o_ret_code = 1, o_ret_msg = "this trade had Cancelled"; 
        leave label; 
    end if;

    select settle_date,trade_id,account_id,account_type,market_id,product_id,product_type,buy_sell,avg_price,
	    case buy_sell when 1 then -1 else 1 end * quantity as quantity,
        case buy_sell when 1 then -1 else 1 end * quantity as net_quantity,
        case buy_sell when 1 then 1 else -1 end * net_amount as net_amount,
        clearing_currency,custodian_code,custodian_account
    into  v_settle_date,v_trade_id,v_account_id,v_account_type,v_market_id,v_product_id,v_product_type,v_buy_sell,v_avg_price,
          v_quantity,v_net_quantity,v_trade_balance,
          v_currency,v_custodian_code,v_custodian_account
    from account_trade where id = i_id;
    
    select account_type into v_account_type from capital_account where account_id = v_account_id;
    
    set v_settle_balance = v_trade_balance;
    
    
    
    if (v_settle_date > v_buss_date) or ((v_settle_date = v_buss_date and v_day_end_performed = 'N') and 
              EXISTS (select 1 from unsettled_position where settle_date = v_settle_date  and account_id = v_account_id and account_type = v_account_type and market_id = v_market_id and product_id = v_product_id and currency = v_currency and 
              custodian_code = v_custodian_code and custodian_account = v_custodian_account)) then
        update unsettled_position 
        set quantity = quantity + v_quantity,
            amount = amount + v_trade_balance
        where settle_date = v_settle_date and account_id = v_account_id and account_type = v_account_type and market_id = v_market_id and
              product_id = v_product_id and currency = v_currency and 
              custodian_code = v_custodian_code and custodian_account = v_custodian_account;
        
        set v_quantity = 0;
        set v_settle_balance = 0;
    end if;

    set v_remark = concat("Cancel_Trade:",v_trade_id);
    
    call proCancelForQuantity(
        v_settle_date,
        v_account_id, 
        v_trade_id,
        v_account_type,
        v_market_id, 
        v_product_id, 
        v_product_type,
        v_currency,
        v_quantity,
        v_net_quantity,
        v_custodian_code, 
        v_custodian_account, 
        v_avg_price, 
        v_remark,
        i_update_user, 
        i_update_time,
        o_ret_code,
        o_ret_msg
    );

    if o_ret_code then 
        rollback; 
        leave label; 
    end if; 

    call proCancelForAmount(
        v_settle_date,v_trade_id,v_account_id,v_account_type,v_currency,v_trade_balance,v_settle_balance,v_remark,
        v_market_id,v_product_id,'','',
        i_update_user, i_update_time,o_ret_code,o_ret_msg);
    if o_ret_code then 
        rollback; 
        leave label; 
    end if;
    
    insert into import_account_trade_detail
    select 
        NULL,
        trade_id,
        NULL,
        process_date,
        order_no,
        order_date,
        NULL,
        NULL,
        NULL,
        account_id,
        account_type,
        trade_date,
        settle_date,
        market_id,
        list_market_id,
        product_type,
        product_sub_type,
        product_id,
        product_description,
        quote_currency,
        clearing_currency,
        exchange_rate,
        buy_sell,
        avg_price,
        quantity,
        quantity,
        NULL,
        NULL,
        0,
        0,
        0,
        NULL,
        input_channel,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        quantity,
        avg_price,
        0,
        '产品存在',
        num_of_trades,
        trade_amount,
        net_amount,
        NULL,
        NULL,
        'Cancelled',
        NULL,
        NULL,
        NULL
    from account_trade where id = i_id;

    update account_trade set status = 'Cancelled' where id = i_id;

    COMMIT;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCashIn
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCashIn`;
delimiter ;;
CREATE PROCEDURE `proCashIn`(In i_process_date date,
   In i_account_id char(16),
   In i_account_type int,
   In i_currency int,
   In i_amount decimal(30,10),
   In i_way    int, 
   In i_remark char(128), 
   In i_remark2 varchar(128), 
   In i_pay_bank_id char(32), 
   In i_pay_check_no char(16),
   In i_pay_bank_account_name char(32), 
   In i_pay_bank_account_id char(32), 
   In i_rec_bank_id char(32), 
   In i_rec_check_no char(16), 
   In i_rec_bank_account_name char(32), 
   In i_rec_bank_account_id char(32), 
   In i_dividend_market_id varchar(16), 
   In i_dividend_product_id varchar(32),
   In i_gl_mapping_item_id VARCHAR(64),
   In i_reference          VARCHAR(128),
   In i_custodian_code varchar(16), 
   In i_custodian_account varchar(16),
   In i_input_user char(32), 
   In i_input_time datetime,
   Out o_code int ,
   Out o_message varchar(128))
label:begin
    declare v_balance decimal(30,10) default 0.0;
    declare v_process_date date default NULL; 

    select buss_date into v_process_date from sys_info; 
    if v_process_date is NULL then 
        set o_code = jcbms.funErrCode('ERR_OTHER_DEFAULT'), o_message = "Bussness date not setting up";
        leave label; 
    end if; 

    if i_process_date is null  then 
        set i_process_date = v_process_date;
    end if; 

    IF NOT EXISTS (SELECT 1 FROM jcbms.account_profile WHERE account_id = i_account_id)THEN
         SET o_code = 1;
         SET o_message = CONCAT('account_id not exists : ', IFNULL(i_account_id,'NULL'));
         LEAVE label;
    END IF;

    IF NOT EXISTS (SELECT 1 FROM jcbms.dict WHERE class='ACCOUNT' AND sub_class='ACCOUNT_TYPE' AND item=i_account_type)THEN
         SET o_code = 1;
         SET o_message = CONCAT('unkonw account_type=', IFNULL(i_account_type,'NULL'));
         LEAVE label;
    END IF;
    
    IF NOT EXISTS(SELECT 1 FROM jcbms.currency WHERE currency=i_currency)THEN
         SET o_code = 1;
         SET o_message = CONCAT('unkonw currency=', IFNULL(i_currency,'NULL'));
         LEAVE label;
    END IF;

   
    if i_dividend_market_id <>  ''  and i_dividend_product_id <> ''  and   not EXISTS(select 1 from product where list_market_id=i_dividend_market_id and product_id = i_dividend_product_id) then 
        set o_code = 1; 
        set o_message = concat('unkonw market-product'); 
        leave label; 
    end if; 

    if i_dividend_market_id = '' then 
        set i_dividend_market_id = '0'; 
    end if; 

    if not EXISTS (select 1 from account_balance where process_date = v_process_date and account_id = i_account_id and account_type = i_account_type and currency = i_currency) then 
        call proCreateAccountBalance(v_process_date, i_account_id,i_account_type,i_currency);
    end if; 

    update account_balance a
    set trade_balance = trade_balance + i_amount,
        settle_balance = settle_balance + (case when i_process_date > v_process_date then 0 else i_amount end)
        -- settle_balance就是交收后的余额，在手资金，trade_balance就是交收+未交收
    where process_date = v_process_date and 
            account_id =i_account_id and 
            account_type = i_account_type and
            currency = i_currency;

    update account_balance a
    set 
        -- 客户权益，代表着如果客户把所有的仓都变现后，可以获取多少钱；（frozen_amount里面之前是包含利息的，现在既然单独了字段，就改成不包含利息）
        a.equity_balance = a.trade_balance  + a.unrealized_pnl + market_value  - accrued_interest + accrued_interest_credit,
        -- 现金结余 - 负债利息 - 冻结资金 - 做空市值  - IPO冻结(截止日前) - 配售冻结(配售是在派发日才扣款)
        a.balance_avail =   a.trade_balance + funMin(accrued_interest_credit- a.accrued_interest,0) - a.frozen_amount + 2*a.short_market_value - (a.ipo_frozen_before_allot - a.ipo_frozen_before_close) - a.placing_amount_before_allot  ,
        -- 在手资金 - 待付出资金 -负债利息  - 冻结资金 - 做空市值 - IPO冻结(截止日前）- 配售冻结(配售是在派发日前才扣款)
        a.balance_extract = a.settle_balance - a.unsettled_to_pay + funMin(accrued_interest_credit- a.accrued_interest,0) - a.frozen_amount + 2*a.short_market_value - (a.ipo_frozen_before_allot - a.ipo_frozen_before_close) - a.placing_amount_before_allot
        -- 用这个来算现在总共欠了多少款，需要追加保证金，或者入金
    where process_date = v_process_date and 
            account_id =i_account_id and 
            account_type = i_account_type and
            currency = i_currency;

    update account_balance a
    set 
        -- 也就是说客户现在权益在减去冻结的资金（如保证金等，冻结资金等）如果为负，那就代表危险了要入金了
        a.equity = a.equity_balance  - a.margin_amt - a.frozen_amount
    where process_date = v_process_date and 
            account_id =i_account_id and 
            account_type = i_account_type and
            currency = i_currency;


    select settle_balance into v_balance from account_balance 
        where process_date = v_process_date and 
              account_id = i_account_id and 
              account_type = i_account_type and 
              currency = i_currency;

    -- 计算开仓成本 
    update account_position
    set position_cost = position_cost - i_amount
    where process_date = v_process_date and 
          market_id = i_dividend_market_id and 
          product_id = i_dividend_product_id and 
          account_id = i_account_id and 
          account_type = i_account_type and 
          custodian_code = i_custodian_code and 
          custodian_account = i_custodian_account; 

    update account_position a 
    inner join product b on b.list_market_id = a.market_id and b.product_id = a.product_id 
    set a.avg_price1 = round(case when a.net_quantity = 0 then 0 else a.position_cost/a.net_quantity/ifnull(b.price_factor,1) end, 6)
    where a.process_date = v_process_date and 
          a.market_id = i_dividend_market_id and 
          a.product_id = i_dividend_product_id and 
          a.account_id = i_account_id and 
          a.account_type = i_account_type and 
          a.custodian_code = i_custodian_code and 
          a.custodian_account = i_custodian_account; 

   call proRecordCashFlow(
        v_process_date,
        i_process_date,
        i_account_id,
        i_account_type,
        i_currency,
        i_amount,
        i_way,
        1, 
        i_remark, 
        i_remark2, 
        i_pay_bank_id, 
        i_pay_check_no,
        i_pay_bank_account_name, 
        i_pay_bank_account_id, 
        i_rec_bank_id, 
        i_rec_check_no, 
        i_rec_bank_account_name, 
        i_rec_bank_account_id, 
        v_balance,
        i_dividend_market_id, 
        i_dividend_product_id,
        i_gl_mapping_item_id,
        i_reference,
        i_custodian_code,
        i_custodian_account,
        i_input_user, 
        i_input_time
    );

   set o_code = 0; 
   set o_message = "Success";
end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCashInCIT
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCashInCIT`;
delimiter ;;
CREATE PROCEDURE `proCashInCIT`(In i_process_date date,
   In i_account_id char(16),
   In i_account_type int,
   In i_currency int,
   In i_amount decimal(30,10),
   In i_way    int, 
   In i_remark char(128), 
   In i_remark2 varchar(128), 
   In i_pay_bank_id char(32), 
   In i_pay_check_no char(16),
   In i_pay_bank_account_name char(32), 
   In i_pay_bank_account_id char(32), 
   In i_rec_bank_id char(32), 
   In i_rec_check_no char(16), 
   In i_rec_bank_account_name char(32), 
   In i_rec_bank_account_id char(32), 
   In i_dividend_market_id varchar(16), 
   In i_dividend_product_id varchar(32),
   In i_gl_mapping_item_id VARCHAR(64),
   In i_reference          VARCHAR(128),
   In i_custodian_code varchar(16), 
   In i_custodian_account varchar(16),
   In i_input_user char(32), 
   In i_input_time datetime,
   Out o_code int ,
   Out o_message varchar(128))
label:begin
    declare v_balance decimal(30,10) default 0.0;

    IF NOT EXISTS (SELECT 1 FROM jcbms.dict WHERE class='ACCOUNT' AND sub_class='ACCOUNT_TYPE' AND item=i_account_type)THEN
         SET o_code = 1;
         SET o_message = CONCAT('unkonw account_type=', IFNULL(i_account_type,'NULL'));
         LEAVE label;
    END IF;
    IF NOT EXISTS(SELECT 1 FROM jcbms.currency WHERE currency=i_currency)THEN
         SET o_code = 1;
         SET o_message = CONCAT('unkonw currency=', IFNULL(i_currency,'NULL'));
         LEAVE label;
    END IF;

   
    if i_dividend_market_id <>  ''  and i_dividend_product_id <> ''  and   not EXISTS(select 1 from product where list_market_id=i_dividend_market_id and product_id = i_dividend_product_id) then 
        set o_code = 1; 
        set o_message = concat('unkonw market-product'); 
        leave label; 
    end if; 

    if i_dividend_market_id = '' then 
        set i_dividend_market_id = '0'; 
    end if; 

    if not EXISTS (select 1 from account_balance where process_date = i_process_date and account_id = i_account_id and account_type = i_account_type and currency = i_currency) then 
        call proCreateAccountBalance(i_process_date, i_account_id,i_account_type,i_currency);
    end if; 

    update account_balance a
        set trade_balance = trade_balance + i_amount,
            -- settle_balance = settle_balance + i_amount, -- 在途资金不应该修改这个字段.
            -- settle_balance就是交收后的余额，在手资金，trade_balance就是交收+未交收
            -- 客户权益，代表着如果客户把所有的仓都变现后，可以获取多少钱；（frozen_amount里面之前是包含利息的，现在既然单独了字段，就改成不包含利息）
            a.equity_balance = a.trade_balance  + a.unrealized_pnl + market_value  - accrued_interest + accrued_interest_credit,
            -- 利息如果是负的就不可用
            a.balance_avail =   funMax(a.trade_balance + funMin(accrued_interest_credit- a.accrued_interest,0)  -a.frozen_amount - a.margin_amt,0),
            -- 利息为负不可取，持仓盈亏和市值：如果为负，就不可取，为正就认为是0
            a.balance_extract = funMax(a.settle_balance + /*funMIN(0,a.unrealized_pnl) +*/ + funMIN(a.unsettled_amount,0) + funMin(a.accrued_interest_credit- a.accrued_interest,0) - a.margin_amt  + funMIN(0,a.market_value) - a.frozen_amount,0),
            -- 用这个来算现在总共欠了多少款，需要追加保证金，或者入金
            -- 也就是说客户现在权益在减去冻结的资金（如保证金等，冻结资金等）如果为负，那就代表危险了要入金了
            a.equity = a.equity_balance  - a.margin_amt - a.frozen_amount
        where process_date = i_process_date and 
              account_id =i_account_id and 
              account_type = i_account_type and
              currency = i_currency;


    select settle_balance into v_balance from account_balance 
        where process_date = i_process_date and 
              account_id = i_account_id and 
              account_type = i_account_type and 
              currency = i_currency;

    -- 计算开仓成本 
    update account_position a 
    inner join product b on b.list_market_id = a.market_id and b.product_id = a.product_id 
    set a.position_cost = a.position_cost - i_amount
    where a.process_date = i_process_date and 
          a.market_id = i_dividend_market_id and 
          a.product_id = i_dividend_product_id and 
          a.account_id = i_account_id and 
          a.account_type = i_account_type and 
          a.custodian_code = i_custodian_code and 
          a.custodian_account = i_custodian_account; 

    update account_position a 
    inner join product b on b.list_market_id = a.market_id and b.product_id = a.product_id 
    set a.avg_price1 = round(case when a.net_quantity = 0 then 0 else a.position_cost/a.net_quantity/ifnull(b.price_factor,1) end, 6)
    where a.process_date = i_process_date and 
          a.market_id = i_dividend_market_id and 
          a.product_id = i_dividend_product_id and 
          a.account_id = i_account_id and 
          a.account_type = i_account_type and 
          a.custodian_code = i_custodian_code and 
          a.custodian_account = i_custodian_account; 

   call proRecordCashFlowCIT(
        i_process_date,
        i_account_id,
        i_account_type,
        i_currency,
        i_amount,
        i_way,
        1, 
        i_remark, 
        i_remark2, 
        i_pay_bank_id, 
        i_pay_check_no,
        i_pay_bank_account_name, 
        i_pay_bank_account_id, 
        i_rec_bank_id, 
        i_rec_check_no, 
        i_rec_bank_account_name, 
        i_rec_bank_account_id, 
        v_balance,
        i_dividend_market_id, 
        i_dividend_product_id,
        i_gl_mapping_item_id,
        i_reference,
        i_custodian_code,
        i_custodian_account,
        i_input_user, 
        i_input_time
    );

   set o_code = 0; 
   set o_message = "Success";
end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCashIn_cover
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCashIn_cover`;
delimiter ;;
CREATE PROCEDURE `proCashIn_cover`(In i_process_date date,
   In i_account_id char(16),
   In i_account_type int,
   In i_currency int,
   In i_amount decimal(30,10),
   In i_way    int, 
   In i_remark char(128), 
   In i_remark2 varchar(128), 
   In i_pay_bank_id char(32), 
   In i_pay_check_no char(16),
   In i_pay_bank_account_name char(32), 
   In i_pay_bank_account_id char(32), 
   In i_rec_bank_id char(32), 
   In i_rec_check_no char(16), 
   In i_rec_bank_account_name char(32), 
   In i_rec_bank_account_id char(32), 
   In i_dividend_market_id varchar(16), 
   In i_dividend_product_id varchar(16),
   In i_gl_mapping_item_id VARCHAR(64),
   In i_reference          VARCHAR(128),
   In i_custodian_code varchar(16), 
   In i_custodian_account varchar(16),
   In i_input_user char(32), 
   In i_input_time datetime,
   Out o_code int ,
   Out o_message varchar(128))
label:begin
    declare v_balance decimal(30,10) default 0.0;
    declare v_process_date date default NULL; 

    select buss_date into v_process_date from sys_info; 
    if v_process_date is NULL then 
        set o_code = jcbms.funErrCode('ERR_OTHER_DEFAULT'), o_message = "Bussness date not setting up";
        leave label; 
    end if; 

    if i_process_date is null  then 
        set i_process_date = v_process_date;
    end if; 

    IF NOT EXISTS (SELECT 1 FROM jcbms.dict WHERE class='ACCOUNT' AND sub_class='ACCOUNT_TYPE' AND item=i_account_type)THEN
         SET o_code = 1;
         SET o_message = CONCAT('unkonw account_type=', IFNULL(i_account_type,'NULL'));
         LEAVE label;
    END IF;
    IF NOT EXISTS(SELECT 1 FROM jcbms.currency WHERE currency=i_currency)THEN
         SET o_code = 1;
         SET o_message = CONCAT('unkonw currency=', IFNULL(i_currency,'NULL'));
         LEAVE label;
    END IF;

   
    if i_dividend_market_id <>  ''  and i_dividend_product_id <> ''  and   not EXISTS(select 1 from product where list_market_id=i_dividend_market_id and product_id = i_dividend_product_id) then 
        set o_code = 1; 
        set o_message = concat('unkonw market-product'); 
        leave label; 
    end if; 

    if i_dividend_market_id = '' then 
        set i_dividend_market_id = '0'; 
    end if; 

    if not EXISTS (select 1 from account_balance where process_date = v_process_date and account_id = i_account_id and account_type = i_account_type and currency = i_currency) then 
        call proCreateAccountBalance(v_process_date, i_account_id,i_account_type,i_currency);
    end if; 

    update account_balance a
        set trade_balance = trade_balance + i_amount,
            settle_balance = settle_balance + (case when i_process_date > v_process_date then 0 else i_amount end),
            
            
            a.equity_balance = a.trade_balance  + a.unrealized_pnl + market_value  - accrued_interest + accrued_interest_credit,
            
            a.balance_avail =   funMax(a.trade_balance + funMin(accrued_interest_credit- a.accrued_interest,0)  -a.frozen_amount - a.margin_amt,0),
            
            a.balance_extract = funMax(a.settle_balance +  + funMIN(a.unsettled_amount,0) + funMin(a.accrued_interest_credit- a.accrued_interest,0) - a.margin_amt  + funMIN(0,a.market_value) - a.frozen_amount,0),
            
            
            a.equity = a.equity_balance  - a.margin_amt - a.frozen_amount
        where process_date = v_process_date and 
              account_id =i_account_id and 
              account_type = i_account_type and
              currency = i_currency;


    select settle_balance into v_balance from account_balance 
        where process_date = v_process_date and 
              account_id = i_account_id and 
              account_type = i_account_type and 
              currency = i_currency;

    
    update account_position
    set position_cost = position_cost - i_amount, 
        avg_price1 = round(case when net_quantity = 0 then 0 else position_cost/net_quantity end, 6)
    where process_date = v_process_date and 
          market_id = i_dividend_market_id and 
          product_id = i_dividend_product_id and 
          account_id = i_account_id and 
          account_type = i_account_type and 
          custodian_code = i_custodian_code and 
          custodian_account = i_custodian_account; 































   set o_code = 0; 
   set o_message = "Success";
end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCashOut
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCashOut`;
delimiter ;;
CREATE PROCEDURE `proCashOut`(In i_process_date date,
   In i_account_id char(16),
   In i_account_type int,
   In i_currency int,
   In i_amount decimal(30,10),
   In i_way    int, 
   In i_remark char(128), 
   In i_remark2 varchar(128), 
   In i_pay_bank_id char(32), 
   In i_pay_check_no char(16),
   In i_pay_bank_account_name char(32), 
   In i_pay_bank_account_id char(32), 
   In i_rec_bank_id char(32), 
   In i_rec_check_no char(16), 
   In i_rec_bank_account_name char(32), 
   In i_rec_bank_account_id char(32), 
   In i_dividend_market_id varchar(16), 
   In i_dividend_product_id varchar(32),
   In i_gl_mapping_item_id VARCHAR(64),
   In i_reference          VARCHAR(128),
   In i_custodian_code varchar(16), 
   In i_custodian_account varchar(16),
   In i_input_user char(32), 
   In i_input_time datetime,
   Out o_ret int , 
   Out o_message varchar(128))
label:begin 

    declare v_balance decimal(30,10) default 0.0; 
    declare v_balance_extract decimal(30,10) default 0.0; 
    declare v_id bigint default 0.0;
    declare v_process_date date default NULL;  

    select buss_date into v_process_date from sys_info; 
    if v_process_date is NULL then 
        set o_ret = jcbms.funErrCode('ERR_OTHER_DEFAULT'), o_message = "Bussness date not setting up";
        leave label; 
    end if; 

    if i_process_date is null  then 
        set i_process_date = v_process_date;
    end if; 

    IF NOT EXISTS (SELECT 1 FROM jcbms.account_profile WHERE account_id = i_account_id)THEN
         SET o_ret = 1;
         SET o_message = CONCAT('account_id not exists : ', IFNULL(i_account_id,'NULL'));
         LEAVE label;
    END IF;

    IF NOT EXISTS (SELECT 1 FROM jcbms.dict WHERE class='ACCOUNT' AND sub_class='ACCOUNT_TYPE' AND item=i_account_type)THEN
        SET o_ret = 1;
        SET o_message = CONCAT('unkonw account_type=', IFNULL(i_account_type,'NULL'));
        LEAVE label;
    END IF;
    IF NOT EXISTS(SELECT 1 FROM jcbms.currency WHERE currency=i_currency)THEN
        SET o_ret = 1;
        SET o_message = CONCAT('unkonw currency=', IFNULL(i_currency,'NULL'));
        LEAVE label;
    END IF;

    if i_dividend_market_id <>  ''  and i_dividend_product_id <> '' and   not EXISTS(select 1 from product where list_market_id=i_dividend_market_id and product_id = i_dividend_product_id) then 
        set o_ret = 1; 
        set o_message = concat('unkonw market-product'); 
        leave label; 
    end if; 

    if i_dividend_market_id = '' then 
        set i_dividend_market_id = '0'; 
    end if; 


    if not EXISTS (select 1 from account_balance where process_date = v_process_date and account_id = i_account_id and account_type = i_account_type and currency = i_currency) then 
        call proCreateAccountBalance(v_process_date, i_account_id,i_account_type,i_currency);
    end if; 

    select id, balance_extract, settle_balance into v_id, v_balance_extract,v_balance from account_balance 
        where process_date = v_process_date and 
              account_id = i_account_id and 
              account_type = i_account_type and 
              currency = i_currency;


    set v_balance = v_balance - i_amount;
    /*
    if v_balance_extract < i_amount  then 
        set o_ret = 1, o_message = concat('amount is not enough:total extractable balance[',v_balance,']');
        leave label; 
    else
        set v_balance = v_balance - i_amount;
    end if; 
    */

   update account_balance a
    set trade_balance = trade_balance - i_amount,
        settle_balance = settle_balance - (case when i_process_date > v_process_date then 0 else i_amount end)
        -- settle_balance就是交收后的余额，在手资金，trade_balance就是交收+未交收
    where  id = v_id; 

    update account_balance a
    set 
        -- 客户权益，代表着如果客户把所有的仓都变现后，可以获取多少钱；（frozen_amount里面之前是包含利息的，现在既然单独了字段，就改成不包含利息）
        a.equity_balance = a.trade_balance  + a.unrealized_pnl + market_value  - accrued_interest + accrued_interest_credit,
        -- 现金结余 - 负债利息 - 冻结资金 - 做空市值  - IPO冻结(截止日前) - 配售冻结(配售是在派发日才扣款)
        a.balance_avail =   a.trade_balance + funMin(accrued_interest_credit- a.accrued_interest,0) - a.frozen_amount + 2*a.short_market_value - (a.ipo_frozen_before_allot - a.ipo_frozen_before_close) - a.placing_amount_before_allot  ,
        -- 在手资金 - 待付出资金 -负债利息  - 冻结资金 - 做空市值 - IPO冻结(截止日前）- 配售冻结(配售是在派发日前才扣款)
        a.balance_extract = a.settle_balance - a.unsettled_to_pay + funMin(accrued_interest_credit- a.accrued_interest,0) - a.frozen_amount + 2*a.short_market_value - (a.ipo_frozen_before_allot - a.ipo_frozen_before_close) - a.placing_amount_before_allot
    where  id = v_id;

    update account_balance a
    set 
       -- 用这个来算现在总共欠了多少款，需要追加保证金，或者入金
        -- 也就是说客户现在权益在减去冻结的资金（如保证金等，冻结资金等）如果为负，那就代表危险了要入金了
        a.equity = a.equity_balance  - a.margin_amt - a.frozen_amount
    where  id = v_id;

    update account_position
    set position_cost = position_cost + i_amount
    where process_date = v_process_date and 
          market_id = i_dividend_market_id and 
          product_id = i_dividend_product_id and 
          account_id = i_account_id and 
          account_type = i_account_type and 
          custodian_code = i_custodian_code and 
          custodian_account = i_custodian_account; 

    update account_position a 
    inner join product b on b.list_market_id = a.market_id and b.product_id = a.product_id 
    set a.avg_price1 = round(case when a.net_quantity = 0 then 0 else a.position_cost/a.net_quantity/ifnull(b.price_factor,1) end, 6)
    where a.process_date = v_process_date and 
          a.market_id = i_dividend_market_id and 
          a.product_id = i_dividend_product_id and 
          a.account_id = i_account_id and 
          a.account_type = i_account_type and 
          a.custodian_code = i_custodian_code and 
          a.custodian_account = i_custodian_account; 

   call proRecordCashFlow(
        v_process_date,
        i_process_date,
        i_account_id,
        i_account_type,
        i_currency,
        i_amount,
        i_way,
        2, 
        i_remark, 
        i_remark2, 
        i_pay_bank_id, 
        i_pay_check_no,
        i_pay_bank_account_name, 
        i_pay_bank_account_id, 
        i_rec_bank_id, 
        i_rec_check_no, 
        i_rec_bank_account_name, 
        i_rec_bank_account_id, 
        v_balance,
        i_dividend_market_id, 
        i_dividend_product_id,
        i_gl_mapping_item_id,
        i_reference,
        i_custodian_code,
        i_custodian_account,
        i_input_user, 
        i_input_time
    );

    set o_ret = '0' ,o_message = 'Cash Out Success' ; 
end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCashOutCIT
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCashOutCIT`;
delimiter ;;
CREATE PROCEDURE `proCashOutCIT`(In i_process_date date,
   In i_account_id char(16),
   In i_account_type int,
   In i_currency int,
   In i_amount decimal(30,10),
   In i_way    int, 
   In i_remark char(128), 
   In i_remark2 varchar(128), 
   In i_pay_bank_id char(32), 
   In i_pay_check_no char(16),
   In i_pay_bank_account_name char(32), 
   In i_pay_bank_account_id char(32), 
   In i_rec_bank_id char(32), 
   In i_rec_check_no char(16), 
   In i_rec_bank_account_name char(32), 
   In i_rec_bank_account_id char(32), 
   In i_dividend_market_id varchar(16), 
   In i_dividend_product_id varchar(32),
   In i_gl_mapping_item_id VARCHAR(64),
   In i_reference          VARCHAR(128),
   In i_custodian_code varchar(16), 
   In i_custodian_account varchar(16),
   In i_input_user char(32), 
   In i_input_time datetime,
   Out o_ret int , 
   Out o_message varchar(128))
label:begin 

   declare v_balance decimal(30,10) default 0.0; 
   declare v_balance_extract decimal(30,10) default 0.0; 
   declare v_id bigint default 0.0;

   IF NOT EXISTS (SELECT 1 FROM jcbms.dict WHERE class='ACCOUNT' AND sub_class='ACCOUNT_TYPE' AND item=i_account_type)THEN
        SET o_ret = 1;
        SET o_message = CONCAT('unkonw account_type=', IFNULL(i_account_type,'NULL'));
        LEAVE label;
   END IF;
   IF NOT EXISTS(SELECT 1 FROM jcbms.currency WHERE currency=i_currency)THEN
        SET o_ret = 1;
        SET o_message = CONCAT('unkonw currency=', IFNULL(i_currency,'NULL'));
        LEAVE label;
   END IF;

   if i_dividend_market_id <>  ''  and i_dividend_product_id <> '' and   not EXISTS(select 1 from product where list_market_id=i_dividend_market_id and product_id = i_dividend_product_id) then 
        set o_ret = 1; 
        set o_message = concat('unkonw market-product'); 
        leave label; 
   end if; 

    if i_dividend_market_id = '' then 
        set i_dividend_market_id = '0'; 
    end if; 


   if not EXISTS (select 1 from account_balance where process_date = i_process_date and account_id = i_account_id and account_type = i_account_type and currency = i_currency) then 
     call proCreateAccountBalance(i_process_date, i_account_id,i_account_type,i_currency);
   end if; 

    select id, balance_extract, settle_balance into v_id, v_balance_extract,v_balance from account_balance 
        where process_date = i_process_date and 
              account_id = i_account_id and 
              account_type = i_account_type and 
              currency = i_currency;


    set v_balance = v_balance - i_amount;
    /*
    if v_balance_extract < i_amount  then 
        set o_ret = 1, o_message = concat('amount is not enough:total extractable balance[',v_balance,']');
        leave label; 
    else
        set v_balance = v_balance - i_amount;
    end if; 
    */

   update account_balance a
        set trade_balance = trade_balance - i_amount,
            -- settle_balance = settle_balance - i_amount, -- 在途资金不应该修改这个字段.
            -- settle_balance就是交收后的余额，在手资金，trade_balance就是交收+未交收
            -- 客户权益，代表着如果客户把所有的仓都变现后，可以获取多少钱；（frozen_amount里面之前是包含利息的，现在既然单独了字段，就改成不包含利息）
            a.equity_balance = a.trade_balance  + a.unrealized_pnl + market_value  - accrued_interest + accrued_interest_credit,
            -- 利息如果是负的就不可用
            a.balance_avail =   funMax(a.trade_balance + funMin(accrued_interest_credit- a.accrued_interest,0)  -a.frozen_amount - a.margin_amt,0),
            -- 利息为负不可取，持仓盈亏和市值：如果为负，就不可取，为正就认为是0
            a.balance_extract = funMax(a.settle_balance + /*funMIN(0,a.unrealized_pnl) +*/ + funMIN(a.unsettled_amount,0) + funMin(a.accrued_interest_credit- a.accrued_interest,0) - a.margin_amt  + funMIN(0,a.market_value) - a.frozen_amount,0),
            -- 用这个来算现在总共欠了多少款，需要追加保证金，或者入金
            -- 也就是说客户现在权益在减去冻结的资金（如保证金等，冻结资金等）如果为负，那就代表危险了要入金了
            a.equity = a.equity_balance  - a.margin_amt - a.frozen_amount
        where  id = v_id; 

    update account_position a 
    inner join product b on b.list_market_id = a.market_id and b.product_id = a.product_id 
    set a.position_cost = a.position_cost + i_amount
    where a.process_date = i_process_date and 
          a.market_id = i_dividend_market_id and 
          a.product_id = i_dividend_product_id and 
          a.account_id = i_account_id and 
          a.account_type = i_account_type and 
          a.custodian_code = i_custodian_code and 
          a.custodian_account = i_custodian_account; 

    update account_position a 
    inner join product b on b.list_market_id = a.market_id and b.product_id = a.product_id 
    set a.avg_price1 = round(case when a.net_quantity = 0 then 0 else a.position_cost/a.net_quantity/ifnull(b.price_factor,1) end, 6)
    where a.process_date = i_process_date and 
          a.market_id = i_dividend_market_id and 
          a.product_id = i_dividend_product_id and 
          a.account_id = i_account_id and 
          a.account_type = i_account_type and 
          a.custodian_code = i_custodian_code and 
          a.custodian_account = i_custodian_account; 

   call proRecordCashFlowCIT(
        i_process_date,
        i_account_id,
        i_account_type,
        i_currency,
        i_amount,
        i_way,
        2, 
        i_remark, 
        i_remark2, 
        i_pay_bank_id, 
        i_pay_check_no,
        i_pay_bank_account_name, 
        i_pay_bank_account_id, 
        i_rec_bank_id, 
        i_rec_check_no, 
        i_rec_bank_account_name, 
        i_rec_bank_account_id, 
        v_balance,
        i_dividend_market_id, 
        i_dividend_product_id,
        i_gl_mapping_item_id,
        i_reference,
        i_custodian_code,
        i_custodian_account,
        i_input_user, 
        i_input_time
    );

    set o_ret = '0' ,o_message = 'Cash Out Success' ; 
end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCashOut_cover
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCashOut_cover`;
delimiter ;;
CREATE PROCEDURE `proCashOut_cover`(In i_process_date date,
   In i_account_id char(16),
   In i_account_type int,
   In i_currency int,
   In i_amount decimal(30,10),
   In i_way    int, 
   In i_remark char(128), 
   In i_remark2 varchar(128), 
   In i_pay_bank_id char(32), 
   In i_pay_check_no char(16),
   In i_pay_bank_account_name char(32), 
   In i_pay_bank_account_id char(32), 
   In i_rec_bank_id char(32), 
   In i_rec_check_no char(16), 
   In i_rec_bank_account_name char(32), 
   In i_rec_bank_account_id char(32), 
   In i_dividend_market_id varchar(16), 
   In i_dividend_product_id varchar(16),
   In i_gl_mapping_item_id VARCHAR(64),
   In i_reference          VARCHAR(128),
   In i_custodian_code varchar(16), 
   In i_custodian_account varchar(16),
   In i_input_user char(32), 
   In i_input_time datetime,
   Out o_ret int , 
   Out o_message varchar(128))
label:begin 

    declare v_balance decimal(30,10) default 0.0; 
    declare v_balance_extract decimal(30,10) default 0.0; 
    declare v_id bigint default 0.0;
    declare v_process_date date default NULL;  

    select buss_date into v_process_date from sys_info; 
    if v_process_date is NULL then 
        set o_ret = jcbms.funErrCode('ERR_OTHER_DEFAULT'), o_message = "Bussness date not setting up";
        leave label; 
    end if; 

    if i_process_date is null  then 
        set i_process_date = v_process_date;
    end if; 

    IF NOT EXISTS (SELECT 1 FROM jcbms.dict WHERE class='ACCOUNT' AND sub_class='ACCOUNT_TYPE' AND item=i_account_type)THEN
        SET o_ret = 1;
        SET o_message = CONCAT('unkonw account_type=', IFNULL(i_account_type,'NULL'));
        LEAVE label;
    END IF;
    IF NOT EXISTS(SELECT 1 FROM jcbms.currency WHERE currency=i_currency)THEN
        SET o_ret = 1;
        SET o_message = CONCAT('unkonw currency=', IFNULL(i_currency,'NULL'));
        LEAVE label;
    END IF;

    if i_dividend_market_id <>  ''  and i_dividend_product_id <> '' and   not EXISTS(select 1 from product where list_market_id=i_dividend_market_id and product_id = i_dividend_product_id) then 
        set o_ret = 1; 
        set o_message = concat('unkonw market-product'); 
        leave label; 
    end if; 

    if i_dividend_market_id = '' then 
        set i_dividend_market_id = '0'; 
    end if; 


    if not EXISTS (select 1 from account_balance where process_date = v_process_date and account_id = i_account_id and account_type = i_account_type and currency = i_currency) then 
        call proCreateAccountBalance(v_process_date, i_account_id,i_account_type,i_currency);
    end if; 

    select id, balance_extract, settle_balance into v_id, v_balance_extract,v_balance from account_balance 
        where process_date = v_process_date and 
              account_id = i_account_id and 
              account_type = i_account_type and 
              currency = i_currency;


    set v_balance = v_balance - i_amount;
    

   update account_balance a
        set trade_balance = trade_balance - i_amount,
            settle_balance = settle_balance - (case when i_process_date > v_process_date then 0 else i_amount end),
            
            
            a.equity_balance = a.trade_balance  + a.unrealized_pnl + market_value  - accrued_interest + accrued_interest_credit,
            
            a.balance_avail =   funMax(a.trade_balance + funMin(accrued_interest_credit- a.accrued_interest,0)  -a.frozen_amount - a.margin_amt,0),
            
            a.balance_extract = funMax(a.settle_balance +  + funMIN(a.unsettled_amount,0) + funMin(a.accrued_interest_credit- a.accrued_interest,0) - a.margin_amt  + funMIN(0,a.market_value) - a.frozen_amount,0),
            
            
            a.equity = a.equity_balance  - a.margin_amt - a.frozen_amount
        where  id = v_id; 

    update account_position
    set position_cost = position_cost + i_amount, 
        avg_price1 = round(case when net_quantity = 0 then 0 else position_cost/net_quantity end, 6)
    where process_date = v_process_date and 
          market_id = i_dividend_market_id and 
          product_id = i_dividend_product_id and 
          account_id = i_account_id and 
          account_type = i_account_type and 
          custodian_code = i_custodian_code and 
          custodian_account = i_custodian_account; 

   
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    

    set o_ret = '0' ,o_message = 'Cash Out Success' ; 
end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCashTransfer
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCashTransfer`;
delimiter ;;
CREATE PROCEDURE `proCashTransfer`(In i_process_date date,
   In i_account_id1 char(16),
   In i_account_type1 int,
   In i_currency1 int,
   In i_amount1 decimal(30,10),
   In i_account_id2 char(16),
   In i_account_type2 int,
   In i_currency2 int,
   In i_amount2 decimal(30,10),
   In i_remark char(128),     
   In i_gl_mapping_item_id VARCHAR(64),
   In i_reference          VARCHAR(128),
   In i_input_user char(32), 
   In i_input_time datetime,
   Out o_ret int , 
   Out o_message varchar(128))
label:begin
    declare v_remark2 varchar(128) default '' ; 
    declare v_exchange_rate decimal(30,10) default 0; 
    declare v_currency1 varchar(32) default ''; 
    declare v_currency2 varchar(32) default ''; 

    START TRANSACTION;  


    if(i_currency1 = i_currency2) then 
        set v_exchange_rate = 1; 
    else 
        select IFNULL(rate_molecular/rate_denominator,0) into v_exchange_rate from currency_ratio 
            where currency_from = i_currency1 and 
                  currency_to = i_currency2; 
    end if; 

    if(i_amount2 != v_exchange_rate*i_amount1) then 
        set o_ret =1, o_message = "calculate is not correct";
        ROLLBACK; 
        leave label; 
    end if; 

    select currency_desc into v_currency1 from currency where currency = i_currency1; 
    select currency_desc into v_currency2 from currency where currency = i_currency2; 

    set v_remark2 = concat('Account[from ',i_account_id1,' to ', i_account_id2, '],'); 
    set v_remark2 = concat(v_remark2,'Currency[from ',v_currency1,' to ', v_currency2, ' rate:',v_exchange_rate,']'); 

    call proCashOut(
         i_process_date,
         i_account_id1,
         i_account_type1,
         i_currency1,
         i_amount1,
         '1', 
         i_remark, 
         v_remark2 , 
         '', 
         '',
         '', 
         '', 
         '', 
         '', 
         '', 
         '', 
         i_gl_mapping_item_id,
         i_reference,
         '',
         '',
         i_input_user, 
         i_input_time,
         @r1,
         @r2
    );

    if @r1 <> 0 then 
        set o_ret = @r1, o_message  = @r2;
        ROLLBACK; 
        leave label; 
    end if; 
  
    call proCashIn(
         i_process_date,
         i_account_id2,
         i_account_type2,
         i_currency2,
         i_amount2,
         '1', 
         i_remark, 
         v_remark2 , 
         '', 
         '',
         '', 
         '', 
         '', 
         '', 
         '', 
         '', 
         i_gl_mapping_item_id,
         i_reference,
         '',
         '',
         i_input_user, 
         i_input_time,
         @r1,
         @r2
    );

    if @r1 <> 0 then 
        set o_ret = @r1, o_message  = @r2;
        leave label; 
    end if; 
    
    set o_ret = 0, o_message  = "Success";
    commit; 
end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for procedure_proExportOptionsTrade
-- ----------------------------
DROP PROCEDURE IF EXISTS `procedure_proExportOptionsTrade`;
delimiter ;;
CREATE PROCEDURE `procedure_proExportOptionsTrade`(IN i_process_date   DATE)
label:BEGIN

    call proExportOptionsTrade(i_process_date);

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCheckAccountTradeDetail
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCheckAccountTradeDetail`;
delimiter ;;
CREATE PROCEDURE `proCheckAccountTradeDetail`(IN i_market_id  int,
    IN i_product_type  int, 
    OUT o_ret_code int,
    OUT o_ret_msg char(128))
label: BEGIN

    declare v_process_date date default null;

	truncate table CheckWarnings;  
    
    truncate table generate_exec_id; 

    select buss_date into v_process_date from sys_info;
  
    update tmp_account_trade_detail set code = 1, mark = '账号不存在';

    update tmp_account_trade_detail 
    set code = 0, mark = '账号存在'
    where account_id in (select account_id from capital_account);

    insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 
        1,
        'account_trade_detail',
        0,
        '',
        account_id,
        '账户不存在',
        'JC_clearing',
        now()
    from tmp_account_trade_detail
    where code = 1;

    if EXISTS (select 1 from tmp_account_trade_detail where code = 1) then 
        set o_ret_code = 1; 
        set o_ret_msg = '成交明细校验未完成';
        leave label;
    end if;


    
    update tmp_account_trade_detail set code = 2, mark = '产品不存在';
    update tmp_account_trade_detail 
    set code = 0, mark = '产品存在'
    where  (list_market_id, product_id) in (select list_market_id, product_id  from product);

    delete from CheckWarnings;

    insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 
        1,
        'account_trade_detail',
        list_market_id,
        product_id,
        '',
        '产品代码不存在',
        'JC_clearing',
        now()
    from tmp_account_trade_detail
    where code = 2;

    if EXISTS (select 1 from tmp_account_trade_detail where code = 2) then 
        set o_ret_code = 1; 
        set o_ret_msg = '成交明细校验未完成';
        leave label;
    end if;

    start transaction;

    -- 更新客户类型
    update tmp_account_trade_detail a 
    inner join capital_account b on a.account_id = b.account_id 
    set a.account_type = b.account_type;
      
    update tmp_account_trade_detail a, product b
    set a.product_type = b.product_type,
        a.product_sub_type = b.product_sub_type,
        a.product_description = b.product_description,
        a.quote_currency = b.quote_currency,
        a.clearing_currency = b.currency,
        a.trade_amount = (a.exec_price*a.exec_quantity*b.price_factor),
        a.net_amount = a.exec_price*a.exec_quantity*b.price_factor
    where   a.list_market_id = b.list_market_id and 
            a.product_id = b.product_id; 
            
    
    update tmp_account_trade_detail a
    left join  currency b on a.quote_currency = b.currency
    set a.exchange_rate = ifnull(b.exchange_rate,1);

    -- 更新交易日 
    update tmp_account_trade_detail a
    inner join  market b on a.list_market_id = b.market_id
    set trade_date = case when trade_date is null  or trade_date = '00000000' then b.t0 else trade_date end ; 


    -- 如果交易日是半日市，那么交易日取上一个交易日
    update tmp_account_trade_detail a
    inner join calendar b on a.list_market_id = b.market_id and a.trade_date = b.calendar_day and b.holiday = 'H' 
    set a.trade_date = (select max(calendar_day) from calendar t where t.market_id = a.list_market_id and t.calendar_day<b.calendar_day and t.holiday in('N','T'));


    -- 更新交收日 
    update tmp_account_trade_detail a
    left join market b on a.market_id = b.market_id 
        set a.settle_date = funIntervalSettleDay(
                            a.market_id,
                            a.trade_date, 
                            (case when a.list_market_id in (2,16) and a.product_type = 16 then 1 else b.market_settle_days end)
                        );
    -- set a.settle_date = funIntervalSettleDay(a.market_id,a.trade_date, b.market_settle_days);

    -- process_date, num_of_trades 
    update tmp_account_trade_detail a, sys_info b
    set a.process_date = b.buss_date,
        a.num_of_trades = 1; 

   delete from tmp_account_trade_detail where !(list_market_id = i_market_id and product_type = i_product_type and exec_quantity != 0);

   insert into tmp_account_trae_detail_orginal select * from tmp_account_trade_detail;

    -- 汇总成交
    insert into tmp_account_trade
    (
        process_date,
        trade_date ,
        settle_date,
        trade_id,
        business_department ,
        department_trading_group ,
        account_id,
        account_type ,
        market_id ,
        list_market_id ,
        product_id ,
        product_description ,
        product_type ,
        product_sub_type,
        quote_currency,
        clearing_currency ,
        exchange_rate,
        buy_sell ,
        quantity,
        avg_price,
        trade_amount ,
        net_amount ,
        open_close ,
        hedge_flag,
        call_put ,
        strike_price ,
        contract_date ,
        input_channel,
        remark,
        num_of_trades ,
        order_no,
        order_date ,
        update_time,
        update_user 
    )
    select 
        v_process_date,
        a.trade_date ,
        max(a.settle_date),
         concat(date_format(v_process_date, "%Y%m%d"), right(concat('0000000000',funGenerateID(v_process_date)),10)),
        max(a.business_department) ,
        max(a.department_trading_group) ,
        a.account_id,
        a.account_type ,
        max(a.market_id) ,
        a.list_market_id ,
        a.product_id ,
        max(a.product_description) ,
        max(a.product_type) ,
        max(a.product_sub_type),
        max(a.quote_currency),
        max(a.clearing_currency) ,
        max(a.exchange_rate),
        a.buy_sell ,
        ifnull(sum(exec_quantity), 0),
        ifnull(sum(a.trade_amount) / sum(exec_quantity), 0),
        ifnull(round(sum(a.trade_amount),2),0),
        ifnull(round(sum(a.net_amount),2), 0),
        max(a.open_close),
        max(a.hedge_flag),
        max(a.call_put) ,
        max(a.strike_price) ,
        max(a.contract_date) ,
        max(a.input_channel),
        max(a.remark),
        count(*) ,
        max(a.order_no),
        max(a.order_date) ,
        now(),
        'JC_Clearing'
    from tmp_account_trade_detail a 
         inner join market b on a.list_market_id = b.market_id 
    group by 
        case  b.group_by_order when 'Y' then a.order_no else '0' end,
        trade_date ,
        account_id,
        account_type ,
        list_market_id ,
        product_id ,
        buy_sell ,
        case  b.group_by_order when 'Y' then a.order_date else '' end,
        input_channel;


    /*
    update tmp_account_trade_detail a, tmp_account_trade b
    set a.trade_id = b.trade_id,
        a.trade_exec_id = funGenerateExecID(b.trade_id)
    where a.order_date = b.order_date and
          a.order_no = b.order_no ;
    */

    -- for group by order_no 
    update tmp_account_trade_detail a
    inner join tmp_account_trade b on  a.order_date = b.order_date and a.order_no = b.order_no 
    inner join market c on a.list_market_id = c.market_id and c.group_by_order  = 'Y'
    set a.trade_id = b.trade_id,
        a.trade_exec_id = funGenerateExecID(b.trade_id)
    where a.order_no <> '0'  and a.order_no <> '';

    -- for not group by order_no; 
    update tmp_account_trade_detail a
    inner join tmp_account_trade b on  a.trade_date = b.trade_date and a.account_id = b.account_id and a.account_type = b.account_type and a.list_market_id = b.list_market_id and a.product_id = b.product_id and a.buy_sell = b.buy_sell and a.input_channel = b.input_channel
    inner join market c on a.list_market_id = c.market_id  
    set a.trade_id = b.trade_id,
        a.trade_exec_id = funGenerateExecID(b.trade_id)
    where  a.order_no = '0' or a.order_no = '' or c.group_by_order  <> 'Y';


    -- insert into tmp_account_trade_detail_log select *from tmp_account_trade_detail; 

    -- 交易明细导入到系统中
    insert into account_trade_detail
    select 
        null,
        a.trade_id ,   
        a.trade_exec_id,
        a.order_date,
        a.order_no,
        v_process_date,
        a.trade_date,
        a.settle_date,
        a.exec_time,
        a.exec_no,
        a.market_id,
        a.exchange_ref_no,
        a.exec_broker,
        a.contra_broker,
        a.exec_quantity,
        a.exec_price,
        now(),
        'JC_clearing' ,
        0.0,      -- commission
        0.0,       -- charges 
        1, -- num_of_trades
        trade_amount,
        net_amount
    from 
    tmp_account_trade_detail a ;

    insert into account_order_detail
    select 
        null,
        process_date,
        order_no,
        order_date ,
        order_time ,
        business_department,
        department_trading_group,
        account_id,
        account_type,  
        trade_date,
        settle_date,   
        market_id,
        list_market_id,
        product_type,
        product_sub_type,
        product_id,
        product_description,
        quote_currency,
        clearing_currency,
        exchange_rate,
        buy_sell,
        order_price,
        order_quantity,
        trade_quantity ,
        status,
        open_close ,
        hedge_flag ,
        call_put,
        strike_price,
        contract_date ,
        input_channel,
        remark,
        now(),
        'JC_clearing'
    from tmp_account_trade_detail;  
   

    /*重新整理tmp_account_trade_detail*/
    -- 需要汇总的成交标记为1(如果order no 没有传那么就不进行分组)
    update tmp_account_trade_detail a inner join  market b on a.market_id = b.market_id and b.group_by_price = 'Y'
    set a.code = 1  
    where a.order_no <> '' and  a.order_no <> 0; 

    -- 按照input channel 如果是暗盘也进行分笔计算 
    -- update tmp_account_trade_detail a  set a.code = 1 where a.input_channel = '5';

    drop temporary table if exists tmp_account_trade_detail2; 
    create temporary table tmp_account_trade_detail2 select *from tmp_account_trade_detail where 1=2; 
    insert into 
        tmp_account_trade_detail2
        (
            trade_id,
            trade_exec_id,
            process_date,
            order_no,
            order_date,
            order_time,
            business_department,
            department_trading_group,
            account_id,
            account_type,
            trade_date,
            settle_date,
            market_id,
            list_market_id,
            product_type,
            product_sub_type,
            product_id,
            product_description,
            quote_currency,
            clearing_currency,
            exchange_rate,
            buy_sell,
            order_price,
            order_quantity,
            trade_quantity,
            status,
            open_close,
            hedge_flag,
            call_put,
            strike_price,
            contract_date,
            input_channel,
            remark,
            exec_time,
            exec_no,
            exchange_ref_no,
            exec_broker,
            contra_broker,
            exec_quantity,
            exec_price,
            code,
            mark,
            num_of_trades,
            trade_amount,
            net_amount
        )
        select 
            trade_id,
            max(trade_exec_id),
            max(process_date),
            max(order_no),
            max(order_date),
            max(order_time),
            max(business_department),
            max(department_trading_group),
            max(account_id),
            max(account_type),
            max(trade_date),
            max(settle_date),
            max(market_id),
            max(list_market_id),
            max(product_type),
            max(product_sub_type),
            max(product_id),
            max(product_description),
            max(quote_currency),
            max(clearing_currency),
            max(exchange_rate),
            max(buy_sell),
            max(order_price),
            max(order_quantity),
            max(trade_quantity),
            max(status),
            max(open_close),
            max(hedge_flag),
            max(call_put),
            max(strike_price),
            max(contract_date),
            max(input_channel),
            max(remark),
            max(exec_time),
            max(exec_no),
            max(exchange_ref_no),
            max(exec_broker),
            max(contra_broker),
            sum(exec_quantity),
            ifnull(sum(exec_quantity * exec_price) / sum(exec_quantity), 0),
            '0',
            max(mark),
            count(*) , -- num_of_trades 如果是暗盘，num_of_trades就是1；如果是美股就是真实的num_of_trades; 
            sum(trade_amount), 
            sum(net_amount)
        from tmp_account_trade_detail 
        group by 
            trade_id,
            case code  when 1 then exec_price else trade_exec_id end; 

    delete from tmp_account_trade_detail;
    insert into tmp_account_trade_detail select * from  tmp_account_trade_detail2;



    /* -- 不需要进行汇总；
    group by 
        trade_id,
         case code  when 1 then exec_price else trade_exec_id end; 
    */

       
    insert into account_trade
    select 
        null,
        process_date,
        trade_date ,
        settle_date,
        trade_id,
        business_department ,
        department_trading_group ,
        account_id,
        account_type ,
        market_id ,
        list_market_id ,
        product_id ,
        product_description ,
        product_type ,
        product_sub_type,
        quote_currency,
        clearing_currency ,
        exchange_rate,
        buy_sell ,
        quantity,
        avg_price,
        trade_amount,
        net_amount,
        open_close ,
        hedge_flag,
        call_put ,
        strike_price ,
        contract_date ,
        input_channel,
        remark,
        num_of_trades ,
        order_no,
        order_date ,
        update_time,
        update_user ,
        0.0,
        0.0
    from 
    tmp_account_trade a ;

    set o_ret_code = 0; 
    set o_ret_msg = '成交明细校验完成';

    commit;
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCheckImportData
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCheckImportData`;
delimiter ;;
CREATE PROCEDURE `proCheckImportData`(OUT o_ret_code int,
    OUT o_ret_msg char(128))
label:begin

    declare v_process_date date default null;

    insert into import_account_trade_detail
    select NULL,
	a.trade_id, a.trade_exec_id, a.process_date, a.order_no, a.order_date, a.order_time, 
    a.business_department, a.department_trading_group, 
    b.account_id, b.account_type, a.trade_date, 
    a.settle_date, a.market_id, a.list_market_id, a.product_type, a.product_sub_type, 
    a.product_id, a.product_description, a.quote_currency, a.clearing_currency, a.exchange_rate, 
    case when a.buy_sell = 1 then 2 else 1 end as buy_sell, 
    a.order_price, a.order_quantity, a.trade_quantity, a.status, a.open_close, a.hedge_flag, 
    a.call_put, a.strike_price, a.contract_date, a.input_channel, a.remark, a.exec_time, a.exec_no, 
    a.exchange_ref_no, a.exec_broker, a.contra_broker, a.exec_quantity, a.exec_price, a.code, a.mark, 
    a.num_of_trades, a.trade_amount, a.net_amount, a.update_time, a.update_user, a.ConfirmStatus, a.broker, 
    a.custodian_code, a.custodian_account, a.is_odd_lot
	from import_account_trade_detail a 
	inner join capital_account b on b.account_id = '11111113' 
	where broker = 'VELOX_ODD' and is_odd_lot = 'Y';

    -- 0 == Pending(待确认），1 == Confirmed（确认），2 == Canceled(已取消)
    update import_account_trade_detail 
    set ConfirmStatus = 'Pending' 
	where ifnull(ConfirmStatus,'') <> 'Canceled' and ifnull(ConfirmStatus,'') <> 'Confirmed';

    truncate table CheckWarnings;


    update import_account_trade_detail set code = 1, mark = '账号不存在';


    select buss_date into v_process_date from sys_info; 

    update import_account_trade_detail 
    set code = 0, mark = '账号存在'
    where account_id in (select account_id from capital_account);

    insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 
        1,
        'account_trade_detail',
        0,
        '',
        account_id,
        '账户不存在',
        'JC_clearing',
        now()
    from import_account_trade_detail
    where code = 1;

    if EXISTS (select 1 from import_account_trade_detail where code = 1) then 
        set o_ret_code = 1; 
        set o_ret_msg = '成交明细校验未完成';
        leave label;
    end if;

    
    update import_account_trade_detail set code = 2, mark = '产品不存在';
    update import_account_trade_detail 
    set code = 0, mark = '产品存在'
    where  (list_market_id, product_id) in (select list_market_id, product_id  from product);

    delete from CheckWarnings;

    insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 
        1,
        'account_trade_detail',
        list_market_id,
        product_id,
        '',
        '产品代码不存在',
        'JC_clearing',
        now()
    from import_account_trade_detail
    where code = 2;

    if EXISTS (select 1 from import_account_trade_detail where code = 2) then 
        set o_ret_code = 1; 
        set o_ret_msg = '成交明细校验未完成';
        leave label;
    end if;

    start transaction;

    -- 更新客户类型
    update import_account_trade_detail a 
    inner join capital_account b on a.account_id = b.account_id 
    set a.account_type = b.account_type;
      
    update import_account_trade_detail a, product b
    set a.product_type = b.product_type,
        a.product_sub_type = b.product_sub_type,
        a.product_description = b.product_description,
        a.quote_currency = b.quote_currency,
        a.clearing_currency = b.currency,
        a.trade_amount = (a.exec_price*a.exec_quantity*b.price_factor),
        a.net_amount = a.exec_price*a.exec_quantity*b.price_factor
	where   a.list_market_id = b.list_market_id and 
			a.product_id = b.product_id; 
    
    /*
    update import_account_trade_detail a
    left join  (select currency_from,  currency_to, rate_molecular/rate_denominator as rate from currency_ratio )  c on  a.quote_currency = c.currency_from and  a.clearing_currency = c.currency_to
    set a.exchange_rate = (case when (a.quote_currency = a.clearing_currency) then 1 else c.rate end);
    */

    update import_account_trade_detail a  
    left join currency b on a.clearing_currency = b.currency
    set a.exchange_rate = b.exchange_rate; 

    -- 更新交易日 
    update import_account_trade_detail a
    inner join  market b on a.list_market_id = b.market_id
    set trade_date = case when trade_date is null  or trade_date = '00000000' then 
        (case when v_process_date >b.t0 and v_process_date < b.t1 and a.input_channel <>'5' then b.t0 
        when v_process_date>=b.t0 then t0  else  '00000000' end) else trade_date end;

    /*
    set trade_date = case when trade_date is null  or trade_date = '00000000' then 
        (case when v_process_date >b.t0 and v_process_date < b.t1 and a.input_channel <>'5' then b.t1 
        when v_process_date>=b.t0 then t0  else  '00000000' end) else trade_date end ; 
    */
    -- 如果交易日是半日市，那么交易日取上一个交易日
    update import_account_trade_detail a
    inner join calendar b on a.list_market_id = b.market_id and a.trade_date = b.calendar_day and b.holiday = 'H' 
    set a.trade_date = (select max(calendar_day) from calendar t where t.market_id = a.list_market_id and t.calendar_day<b.calendar_day and t.holiday in('N','T'));

    -- 校验交易日
    -- truncate table CheckWarnings; 
    delete from CheckWarnings; 
    insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 
        1,
        'account_trade_detail',
        list_market_id,
        product_id,
        account_id,
        '非法交易日',
        'JC_clearing',
        now()
    from import_account_trade_detail
    where trade_date = '00000000'; 
    

    if  EXISTS (select 1 from CheckWarnings ) then 
        set o_ret_code = 1; 
        set o_ret_msg = '成交明细校验未完成[非法交易日]';
        leave label;
    end if;


    -- 更新交收日 
    update import_account_trade_detail a
    left join market b on a.market_id = b.market_id 
    set a.settle_date = funIntervalSettleDay(
                            a.market_id,
                            a.trade_date, 
                            (case when a.list_market_id in (2,16) and a.product_type = 16 then 1 else b.market_settle_days end)
                        );
    -- set a.settle_date = funIntervalSettleDay(a.market_id,a.trade_date, b.market_settle_days);

    -- process_date, num_of_trades 
    update import_account_trade_detail a, sys_info b
    set a.process_date = b.buss_date,
        a.num_of_trades = 1; 
    
    -- 更新托管仓库
    update import_account_trade_detail a
    inner join market b on a.market_id = b.market_id
	set 
        a.broker = ifnull(b.broker,''),
        a.custodian_code = b.custodian_code,
		a.custodian_account = b.custodian_account
    where ifnull(a.broker,'') = '' or ifnull(a.broker,'') = '0';

    update import_account_trade_detail a
    inner join broker_market b on a.market_id = b.market_id and a.broker = b.broker
	set a.custodian_code = b.custodian_code,
		 a.custodian_account = b.custodian_account;

    update import_account_trade_detail a
    inner join account_type_custodian b on a.market_id = b.market_id and a.account_type = b.account_type
	set a.custodian_code = b.custodian_code,
		 a.custodian_account = b.custodian_account; 

    set o_ret_code = 0; 
    set o_ret_msg = '校验完成';

    commit;
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCheckProduct
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCheckProduct`;
delimiter ;;
CREATE PROCEDURE `proCheckProduct`(IN i_market_id  int,
    IN i_product_type  int, 
    OUT o_ret_code int,
    OUT o_ret_msg char(128))
label: BEGIN
    
  
    set o_ret_code = 1; 
    set o_ret_msg = '产品校验完成';
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proClientFundBalance
-- ----------------------------
DROP PROCEDURE IF EXISTS `proClientFundBalance`;
delimiter ;;
CREATE PROCEDURE `proClientFundBalance`(in i_process_date date, 
    in i_account_type int)
label:begin

    declare v_buss_date date; 
    declare v_settle_date date; 
    declare v_settle_date2 date; 
    select buss_date into v_buss_date from sys_info; 

    if i_process_date is null then 
        set i_process_date = v_buss_date; 
    end if; 
    
    
    set v_settle_date = funIntervalNotWeekendDay(1,i_process_date, 1);
    set v_settle_date2 =  funIntervalNotWeekendDay(1,v_settle_date, 1);



    
   

    
    drop table if exists tmpproClientFundBalanceUnsettledT1; 
    create temporary table tmpproClientFundBalanceUnsettledT1
    (
        account_id varchar(16), 
        currency int, 
        amount decimal(30,10), 
        index idx1(account_id,currency)
    ); 
    
    
    
    if v_buss_date = i_process_date then 
        insert into tmpproClientFundBalanceUnsettledT1
        (
            account_id,
            currency, 
            amount
        )
        select 
            t1.account_id,
            t1.currency,
            sum(ifnull(t1.amount,0)) AS unsettled_t1 
            FROM 
            unsettled_position t1 
            WHERE 
            t1.settle_date =  v_settle_date   group by t1.account_id, t1.currency; 
    else 
    
        insert into tmpproClientFundBalanceUnsettledT1
        (
            account_id,
            currency, 
            amount
        )
        select 
            t1.account_id,
            t1.currency,
            sum(ifnull(t1.amount,0)) AS unsettled_t1 
            FROM 
            settled_position t1 
            WHERE 
            t1.settle_date =  v_settle_date  group by t1.account_id, t1.currency;
    end if; 



    
    drop table if exists tmpproClientFundBalanceUnsettledT2; 
    create temporary table tmpproClientFundBalanceUnsettledT2
    (
        account_id varchar(16), 
        currency int, 
        amount decimal(30,10), 
        index idx1(account_id,currency)
    ); 

    
    if v_buss_date = i_process_date then 
        insert into tmpproClientFundBalanceUnsettledT2
        (
            account_id,
            currency, 
            amount
        )
        select 
            t1.account_id,
            t1.currency,
            sum(ifnull(t1.amount,0)) AS unsettled_t1 
            FROM 
            unsettled_position t1 
            WHERE 
            t1.settle_date = v_settle_date2  group by t1.account_id, t1.currency;
    else 
    
        insert into tmpproClientFundBalanceUnsettledT2
        (
            account_id,
            currency, 
            amount
        )
        select 
            t1.account_id,
            t1.currency,
            sum(ifnull(t1.amount,0)) AS unsettled_t1 
            FROM 
            settled_position t1 
            WHERE 
            t1.settle_date =  v_settle_date2  group by t1.account_id, t1.currency;
    end if; 


    
    drop table if exists tmpproClientFundBalanceT0MarketValue; 
    create temporary table tmpproClientFundBalanceT0MarketValue
    (
       account_id varchar(16), 
       currency int, 
       t0_market_value decimal(30,10), 
       index idx1(account_id,currency)
    );

    insert into tmpproClientFundBalanceT0MarketValue
    select account_id, 
           currency , 
           sum(closing_price*quantity)
           from account_position
           where process_date = i_process_date
           group by account_id,currency;
          
    
    select 
        a.account_id as AccountID,
        ifnull(b.short_name,'') as AccountName,
        d.currency_desc as Currency, 
        a.settle_balance as 'Balance(T)', 
        ifnull(e.amount,0) as 'Pend.Settle(T+1)', 
        a.settle_balance + ifnull(e.amount,0) as 'Balance(T+1)', 
        ifnull(f.amount,0) as 'Pend.Settle(>=T+2)', 
        a.trade_balance as NetBalance, 
        a.accrued_interest_credit - a.accrued_interest as AccruedInterest, 
        0 as UnClearedAmount, 
        a.trade_balance+a.accrued_interest_credit - a.accrued_interest as NetAvailBalance, 
        ifnull(g.t0_market_value,0) as MarketValue
        from account_balance a 
        left join account_profile b on a.account_id = b.account_id 
        left join currency d on a.currency = d.currency 
        left join tmpproClientFundBalanceUnsettledT1 e on a.account_id = e.account_id and a.currency = e.currency
        left join tmpproClientFundBalanceUnsettledT2 f on a.account_id = f.account_id and a.currency = f.currency
        left join tmpproClientFundBalanceT0MarketValue g on a.account_id = g.account_id and a.currency = g.currency
        where a.process_date = i_process_date and ifnull(a.account_type,'')  = i_account_type  and  (
               a.settle_balance<> 0 or 
               a.settle_balance + ifnull(e.amount,0) <> 0 or 
               ifnull(e.amount,0) <> 0 or 
               ifnull(f.amount,0) <> 0 or 
               a.trade_balance <> 0 or 
               a.accrued_interest_credit - a.accrued_interest  <> 0 or 
               a.trade_balance+a.accrued_interest_credit - a.accrued_interest  <> 0 or 
               ifnull(g.t0_market_value,0) <>0
            )
        order by a.currency,a.account_id; 

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proClientTradeJournalListing
-- ----------------------------
DROP PROCEDURE IF EXISTS `proClientTradeJournalListing`;
delimiter ;;
CREATE PROCEDURE `proClientTradeJournalListing`(in i_process_date date, 
    in i_market_id int)
label:begin
    

    
    drop table if exists tmp_rpt; 
    create temporary table tmp_rpt
    (
        id bigint primary key auto_increment,
        type int, 
        show_id bigint, 
        trade_date date, 
        settle_date date, 
        trade_id varchar(32), 
        account_id varchar(16), 
        buy_sell int, 
        market_id int, 
        product_id varchar(16), 
        currency int,
        price decimal(30,10), 
        quantity decimal(30,10), 
        turnover decimal(30,10), 
        commission decimal(30,10), 
        market_charges decimal(30,10), 
        broker_cost decimal(30,10), 
        net_amount decimal(30,10), 
        index idx(trade_id)
    );

    insert into tmp_rpt
    select 
        NULL,
        1, 
        0,
        trade_date, 
        settle_date, 
        trade_id, 
        account_id, 
        buy_sell,
        market_id, 
        product_id, 
        clearing_currency,
        avg_price, 
        quantity, 
        trade_amount, 
        commission, 
        charges, 
        0,
        case when buy_sell = 1 then -1 else 1 end *net_amount
    from account_trade a
    where a.process_date = i_process_date 
    and a.market_id = i_market_id
    order by buy_sell,market_id,product_id,account_id,trade_id; 

    update tmp_rpt 
    set show_id = id; 

    
    drop table if exists tmp_rpt_id;
    create temporary table tmp_rpt_id 
    (
        show_id bigint, 
        trade_id varchar(64), 
        index idx1(trade_id)
    ); 
    insert into tmp_rpt_id
    select show_id, 
           trade_id 
        from tmp_rpt
        group by show_id,trade_id;

    insert into tmp_rpt 
    (
        type,
        trade_id, 
        show_id, 
        quantity, 
        price
    )
    select 
        2, 
        a.trade_id, 
        b.show_id, 
        a.exec_quantity, 
        a.exec_price
    from account_trade_detail a 
    inner join tmp_rpt_id b on a.trade_id = b.trade_id
    where a.process_date = i_process_date 
    and a.market_id = i_market_id;

    select * 
    from tmp_rpt 
    order by show_id,type; 
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proComparePosition
-- ----------------------------
DROP PROCEDURE IF EXISTS `proComparePosition`;
delimiter ;;
CREATE PROCEDURE `proComparePosition`(in  i_process_date date,
    OUT o_ret_code int,
    OUT o_ret_msg varchar(32))
label:BEGIN
    DECLARE v_process_date date;
    DECLARE v_last_process_date date;
    DECLARE v_day_end_performed varchar(1);
    DECLARE v_hk_1t date;
    DECLARE v_csc_1t date;

    SET o_ret_code = 0, o_ret_msg = "Success";

    TRUNCATE TABLE custodian_position_compare;

    start transaction;

    SELECT last_buss_date, buss_date,day_end_performed INTO v_last_process_date,v_process_date,v_day_end_performed FROM sys_info;

    
    if v_process_date is NULL then 
        set o_ret_code = 1, o_ret_msg = "Bussness date not setting up"; 
        rollback; 
        leave label; 
    end if;

    IF i_process_date > v_process_date THEN
        set o_ret_code = 1, o_ret_msg = "Compare date wrong"; 
        rollback; 
        leave label; 
    end if;

    if (i_process_date is NULL or i_process_date = v_process_date) and v_day_end_performed = 'Y' then
        set i_process_date = v_process_date;
        set v_hk_1t  = NULL; 
        select max(calendar_day) into v_hk_1t from calendar where market_id = 1 and calendar_day<i_process_date and holiday <> 'Y'; 
        set v_csc_1t  = NULL; 
        select max(calendar_day) into v_csc_1t from calendar where market_id in (4,8) and calendar_day<i_process_date and holiday <> 'Y'; 
    elseif (i_process_date is NULL or i_process_date = v_process_date) and v_day_end_performed = 'N' THEN
        set i_process_date = v_last_process_date;
        set v_hk_1t  = NULL; 
        select max(calendar_day) into v_hk_1t from calendar where market_id = 1 and calendar_day<=i_process_date and holiday <> 'Y'; 
        set v_csc_1t  = NULL; 
        select max(calendar_day) into v_csc_1t from calendar where market_id in (4,8) and calendar_day<=i_process_date and holiday <> 'Y'; 
    elseif  i_process_date < v_process_date then 
        set v_hk_1t  = NULL; 
        select max(calendar_day) into v_hk_1t from calendar where market_id = 1 and calendar_day<=i_process_date and holiday <> 'Y'; 
        set v_csc_1t  = NULL; 
        select max(calendar_day) into v_csc_1t from calendar where market_id in (4,8) and calendar_day<=i_process_date and holiday <> 'Y'; 
    end if;

    if NOT EXISTS (select 1 from custodian_account_position where process_date = v_hk_1t and market_id = 1) THEN 
        set o_ret_code = 1; 
        set o_ret_msg = concat(date_format(v_hk_1t,'%Y-%m-%d'),'港交所持仓文件未导入');
        rollback;
        leave label;
    end if; 

    if NOT EXISTS (select 1 from custodian_account_position where process_date = v_csc_1t and market_id in (4,8)) THEN 
        set o_ret_code = 1; 
        set o_ret_msg = concat(date_format(v_hk_1t,'%Y-%m-%d'),'中华通持仓文件未导入');
        rollback; 
        leave label;
    end if; 

    INSERT INTO custodian_position_compare(`process_date`,`market_id`,`product_id`,`qty_ap`)
    SELECT * FROM(
        SELECT`process_date`,`market_id`,`product_id`, SUM(quantity)AS qty_ap 
        FROM account_position 
        WHERE process_date=i_process_date AND quantity<>0 AND market_id=1 and product_id not like 'XS%'
        GROUP BY process_date,market_id, product_id) ap
    ON DUPLICATE KEY UPDATE `qty_ap`=ap.qty_ap;

    INSERT INTO custodian_position_compare(`process_date`,`market_id`,`product_id`,`qty_ap`)
    SELECT * FROM(
        SELECT`process_date`,`market_id`,`product_id`, SUM(net_quantity)AS qty_ap 
        FROM account_position 
        WHERE process_date=i_process_date AND net_quantity<>0 AND market_id IN(4,8) and product_id not like 'XS%'
        GROUP BY process_date,market_id, product_id) ap
    ON DUPLICATE KEY UPDATE `qty_ap`=ap.qty_ap;

    INSERT INTO custodian_position_compare(`process_date`,`market_id`,`product_id`,`qty_cap`)
    SELECT * FROM(
        SELECT i_process_date,`market_id`,`product_id`, SUM(quantity) AS qty_cap 
        FROM custodian_account_position 
        WHERE process_date=v_hk_1t AND quantity<>0 and market_id = 1
        GROUP BY process_date,market_id, product_id) ap
    ON DUPLICATE KEY UPDATE `qty_cap`=ap.qty_cap;

    INSERT INTO custodian_position_compare(`process_date`,`market_id`,`product_id`,`qty_cap`)
    SELECT * FROM(
        SELECT i_process_date,`market_id`,`product_id`, SUM(quantity) AS qty_cap 
        FROM custodian_account_position 
        WHERE process_date=v_csc_1t AND quantity<>0 and market_id in (4,8)
        GROUP BY process_date,market_id, product_id) ap
    ON DUPLICATE KEY UPDATE `qty_cap`=ap.qty_cap;

    UPDATE custodian_position_compare SET `qty_delta`=IFNULL(`qty_ap`,0)-IFNULL(`qty_cap`,0);

    update custodian_position_compare a
    left join product b on b.list_market_id = a.market_id and b.product_id = a.product_id
    left join dict c on c.sub_class = 'PRODUCT_TYPE' and c.item = b.product_type
    set a.description = c.description 
    where a.process_date = i_process_date;

    

COMMIT;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCompareTrade
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCompareTrade`;
delimiter ;;
CREATE PROCEDURE `proCompareTrade`(OUT o_ret_code int,
    OUT o_ret_msg varchar(32))
label:begin
    declare v_process_date  date;

    select buss_date into v_process_date from sys_info; 

    truncate table trade_compare;

    start transaction;

    drop temporary table  if EXISTS tmp_account_trade_detail;
    CREATE  temporary TABLE `tmp_account_trade_detail` (
    	`id` BIGINT(11) NOT NULL AUTO_INCREMENT,
        `trade_date` DATE NULL DEFAULT NULL,
        `exec_broker` CHAR(16) NULL DEFAULT NULL,
        `market_id` INT NULL DEFAULT NULL,
        `product_id` varchar(32) NULL DEFAULT NULL,
        `buy_sell` INT NULL DEFAULT NULL,
        `exec_quantity` DECIMAL(30,10) NULL DEFAULT '0.000000',
        `exec_price` DECIMAL(30,10) NULL DEFAULT '0.000000',
        `times` int NULL DEFAULT 0,
        `code`  CHAR(1) NULL DEFAULT NULL, 
        PRIMARY KEY (`id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    create index Index1 on tmp_account_trade_detail (`trade_date`,`market_id`,`product_id`,`buy_sell`,`exec_quantity`,`exec_price`);

    drop temporary table  if EXISTS tmp_exchange_trade;
    CREATE  temporary TABLE `tmp_exchange_trade` (
        `id` BIGINT(11) NOT NULL AUTO_INCREMENT,
        `trade_date` DATE NULL DEFAULT NULL,
        `exec_broker` CHAR(16) NULL DEFAULT NULL,
        `market_id` INT NULL DEFAULT NULL,
        `product_id` varchar(32) NULL DEFAULT NULL,
        `buy_sell` INT NULL DEFAULT NULL,
        `exec_quantity` DECIMAL(30,10) NULL DEFAULT '0.000000',
        `exec_price` DECIMAL(30,10) NULL DEFAULT '0.000000',
        `times` int NULL DEFAULT 0,
        PRIMARY KEY (`id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    create index Index1 on tmp_exchange_trade (`trade_date`,`market_id`,`product_id`,`buy_sell`,`exec_quantity`,`exec_price`);

    drop temporary table  if EXISTS tmp_trade_detail;
    CREATE  temporary TABLE `tmp_trade_detail` (
        `trade_date` DATE NULL DEFAULT NULL,
        `exec_broker` CHAR(16) NULL DEFAULT NULL,
        `market_id` INT NULL DEFAULT NULL,
        `product_id` varchar(32) NULL DEFAULT NULL,
        `buy_sell` INT NULL DEFAULT NULL,
        `exec_quantity` DECIMAL(30,10) NULL DEFAULT '0.000000',
        `exec_price` DECIMAL(30,10) NULL DEFAULT '0.000000',
        INDEX `idx1` (`trade_date`,`market_id`,`product_id`,`buy_sell`,`exec_quantity`,`exec_price`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;

    insert into tmp_trade_detail
    select 
        a.trade_date as trade_date,
        a.exec_broker as exec_broker,
        a.market_id as market_id,
        a.product_id as product_id,
        a.buy_sell as buy_sell,
        round(a.exec_quantity,6) as exec_quantity,
        round(a.exec_price,6) as exec_price
    from import_account_trade_detail a
    
    where a.process_date = v_process_date and a.input_channel <> 5 and (a.market_id not in (2,16)) and ifnull(ConfirmStatus,'') <> 'Canceled';

    insert into tmp_account_trade_detail
    (
        trade_date,
        exec_broker,
        market_id,
        product_id,
        buy_sell,
        exec_quantity,
        exec_price,
        times,
        code
    )
    select 
        trade_date,
        exec_broker,
        market_id,
        product_id,
        buy_sell,
        exec_quantity,
        exec_price,
        ifnull(count(1),0) as times,
        'N'
        from (
            select 
            a.trade_date as trade_date,
            a.exec_broker as exec_broker,
            a.market_id as market_id,
            a.product_id as product_id,
            a.buy_sell as buy_sell,
            round(a.exec_quantity,6) as exec_quantity,
            round(a.exec_price,6) as exec_price
            from import_account_trade_detail a
            
            where a.process_date = v_process_date and a.input_channel <> 5 and (a.market_id not in (2,16)) and ifnull(ConfirmStatus,'') <> 'Canceled'
        ) t 
        group by t.trade_date,t.exec_broker,t.market_id,t.product_id,t.buy_sell,t.exec_quantity,t.exec_price
        order by trade_date,exec_broker,market_id,product_id,buy_sell,exec_quantity,exec_price,times;

    insert into tmp_exchange_trade
    (
        trade_date,
        exec_broker,
        market_id,
        product_id,
        buy_sell,
        exec_quantity,
        exec_price,
        times
    )
    select 
        trade_date,
        exec_broker,
        market_id,
        product_id,
        buy_sell,
        round(exec_quantity,6) as quantity,
        round(exec_price,6) as price,
        ifnull(count(1),0) as times
    from exchange_trade where trade_date = v_process_date
    group by trade_date,exec_broker,market_id,product_id,buy_sell,quantity,price 
    order by trade_date,exec_broker,market_id,product_id,buy_sell,quantity,price,times;

    
    insert into trade_compare
    (
        process_date,
        exchange_trade_date,
        exchange_exec_broker,
        exchange_market_id,
        exchange_product_id,
        exchange_buy_sell,
        exchange_exec_quantity,
        exchange_exec_price,
        exchange_times
    )
    select 
        v_process_date,
        trade_date,
        exec_broker,
        market_id,
        product_id,
        buy_sell,
        exec_quantity,
        exec_price,
        ifnull(times,0)
    from tmp_exchange_trade a;


    update trade_compare a
    left join tmp_account_trade_detail b 
    on  b.trade_date = a.exchange_trade_date and
		b.exec_broker = a.exchange_exec_broker and
		b.market_id = a.exchange_market_id and
		b.product_id = a.exchange_product_id and
		b.buy_sell = a.exchange_buy_sell and
		b.exec_quantity = a.exchange_exec_quantity and
		b.exec_price = a.exchange_exec_price
    set     
        a.comp_times = ABS(ifnull(b.times,0) - ifnull(a.exchange_times,0)),
        a.trade_date = b.trade_date,
        a.exec_broker = b.exec_broker,
        a.market_id = b.market_id,
        a.product_id = b.product_id,
        a.buy_sell = b.buy_sell,
        a.exec_quantity = b.exec_quantity,
        a.exec_price = b.exec_price,
        a.times = ifnull(b.times,0),
        b.code = 'Y'
    where a.process_date = v_process_date;

    insert into trade_compare
    (
        comp_times,
        trade_date,
        exec_broker,
        market_id,
        product_id,
        buy_sell,
        exec_quantity,
        exec_price,
        times
    )
    select 
        ifnull(times,0),
        trade_date,
        exec_broker,
        market_id,
        product_id,
        buy_sell,
        exec_quantity,
        exec_price,
        ifnull(times,0)
    from tmp_account_trade_detail a where a.code <> 'Y';

    set o_ret_code = 0; 
    set o_ret_msg = "成交对比完成"; 
    commit;
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCountingDayTrade
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCountingDayTrade`;
delimiter ;;
CREATE PROCEDURE `proCountingDayTrade`(IN i_trade_date date, 
    IN i_last_process_date date,  
    IN i_market_id int,   
    IN  i_user varchar(32),
    OUT o_ret_code int,  
    OUT o_ret_msg varchar(255))
label: BEGIN

    
    declare v_done int default 0 ;
    declare v_pd date;  
    declare v_lpd date; 

    declare v_trade_account_id varchar(16); 
    declare v_trade_product_id varchar(32); 
    declare v_trade_order_no varchar(32); 
    declare v_trade_buy_sell int; 
    declare v_trade_open_close int; 
    declare v_trade_quantity decimal(30,10); 

    declare v_cur_quantity decimal(30,10); 
    declare v_cur_quantity_left decimal(30,10);
    declare v_cur_buy_sell int; 
    
    
    declare v_p_id bigint; 
    declare v_p_quantity decimal(30,10); 

    
    declare cur_t_trade cursor for 
        select
            b.account_id, 
            b.product_id, 
            a.exec_quantity, 
            a.order_no, 
            b.buy_sell, 
            '2'  
        from account_trade_detail a  
        inner join account_trade b on a.trade_id = b.trade_id and b.trade_date = i_trade_date and b.market_id in(2,16)
        where a.is_odd_lot <> 'Y'
        order by b.account_id, 
                 b.product_id, 
                 a.exec_time, 
                 a.order_date, 
                 a.order_no; 
    declare continue HANDLER FOR NOT FOUND SET v_done=1;

    set o_ret_code=0, o_ret_msg="Success"; 
    
    
    if i_market_id <> '2' then 
        leave label; 
    end if; 

    
    select buss_date, last_buss_date into v_pd, v_lpd from sys_info; 

    if i_trade_date is null then 
        select t0 into i_trade_date from market where market_id = i_market_id limit 1; 
    end if; 

    if i_last_process_date is null then 
        set i_last_process_date = v_lpd; 
    end if; 

    
    drop temporary table if exists tmp_co_his; 
    create temporary table tmp_co_his
    (
        id bigint auto_increment primary key, 
        account_id varchar(16),
        op_id bigint, 
        ct_order_no varchar(32), 
        index idx1(op_id,ct_order_no), 
        index idx2(account_id)
    );
  
    
    drop temporary table if exists tmp_hp; 
    create temporary table tmp_hp
    (
        id bigint auto_increment primary key, 
        product_id varchar(32), 
        account_id varchar(16), 
        buy_sell  int, 
        quantity decimal(30,10) default 0 , 
        unclosed_quantity decimal(30,10) default 0,
        total_closed varchar(1) default 'N',
        index idx1(product_id,account_id,buy_sell,total_closed)
    );

    
    drop temporary table if exists tmp_op; 
    create temporary table tmp_op
    (
        id bigint auto_increment primary key , 
        product_id varchar(32), 
        account_id varchar(16),
        buy_sell int, 
        quantity decimal(30,10) default 0, 
        unclosed_quantity decimal(30,10) default 0, 
        closed varchar(1) default 'N', 
        total_closed varchar(1) default 'N', 
        order_no   varchar(32), 
        index idx1(product_id,account_id,buy_sell,total_closed), 
        index idx2(account_id,closed), 
        index idx3(product_id,account_id,buy_sell,order_no) 
    ); 

    
    insert into tmp_hp
        (
            product_id, 
            account_id, 
            buy_sell, 
            quantity, 
            unclosed_quantity
        )
    select 
        a.product_id, 
        a.account_id, 
        case when a.net_quantity>0 then 1 else 2 end, 
        sum(a.net_quantity), 
        sum(a.net_quantity)         
    from account_position a 
    where a.process_date = i_last_process_date
    group by product_id, 
             account_id
    having sum(a.net_quantity) <> 0 ; 
    

    

    
    
    open cur_t_trade; 
    set v_done=0; 
    fetch cur_t_trade into v_trade_account_id,v_trade_product_id,v_trade_quantity,v_trade_order_no,v_trade_buy_sell,v_trade_open_close; 
    while v_done <> 1 do 

        
        if v_trade_open_close = 1 then 
            set v_cur_buy_sell = v_trade_buy_sell; 
        else 
            set v_cur_buy_sell = 3 - v_trade_buy_sell; 
        end if; 
       
        if v_trade_open_close = 1 then 
            
            set v_p_id = null; 
            select id into v_p_id from tmp_op where product_id = v_trade_product_id and account_id = v_trade_account_id and buy_sell = v_cur_buy_sell and  order_no = v_trade_order_no; 
            if v_p_id is not null  then 
                update tmp_op
                set quantity = quantity + v_trade_quantity, 
                    unclosed_quantity = unclosed_quantity + v_trade_quantity,
                    total_closed = 'N'
                where id = v_p_id; 
            else 
                
                insert into tmp_op
                (
                    product_id, 
                    account_id, 
                    buy_sell, 
                    quantity, 
                    unclosed_quantity,
                    order_no
                )
                select v_trade_product_id, 
                    v_trade_account_id, 
                    v_trade_buy_sell, 
                    v_trade_quantity, 
                    v_trade_quantity,
                    v_trade_order_no; 
            end if; 
        else
         
            
            set v_cur_quantity_left = v_trade_quantity; 
            loop_close_t: LOOP 
                set v_p_id  = null; 
                select id, unclosed_quantity into v_p_id,v_p_quantity from tmp_op where product_id = v_trade_product_id and account_id = v_trade_account_id and buy_sell = v_cur_buy_sell and total_closed = 'N' order by id limit 1 ;
                
                
                if v_p_id is null  or v_cur_quantity_left = 0 then 
                    leave loop_close_t; 
                    
                end if; 

                
                if v_p_quantity <= v_cur_quantity_left then 
                    set v_cur_quantity =  v_p_quantity; 
                else  
                
                    set v_cur_quantity =  v_cur_quantity_left;
                end if; 
                set v_cur_quantity_left = v_cur_quantity_left - v_cur_quantity; 


                
                update tmp_op 
                    set 
                        total_closed = case when unclosed_quantity - v_cur_quantity = 0 then 'Y' else 'N' end,
                        unclosed_quantity = unclosed_quantity - v_cur_quantity, 
                        closed = 'Y'
                    where id = v_p_id; 

                
                if not exists (select 1 from tmp_co_his where op_id = v_p_id and ct_order_no = v_trade_order_no) then 
                    insert into tmp_co_his(account_id,op_id,ct_order_no)
                    select v_trade_account_id,v_p_id,v_trade_order_no; 
                end if; 
            End LOOP;
            
            
            loop_close_h: LOOP 
                set v_p_id  = null; 
                select id, unclosed_quantity into v_p_id,v_p_quantity from tmp_hp where product_id = v_trade_product_id and account_id = v_trade_account_id and buy_sell = v_cur_buy_sell and total_closed = 'N';
                
                
                if v_p_id is null  or v_cur_quantity_left = 0 then 
                    leave loop_close_h; 
                    
                end if; 

                
                if v_p_quantity <= v_cur_quantity_left then 
                    set v_cur_quantity =  v_p_quantity; 
                else  
                
                    set v_cur_quantity =  v_cur_quantity_left;
                end if; 
                set v_cur_quantity_left = v_cur_quantity_left - v_cur_quantity; 
                
                update tmp_hp 
                    set 
                        total_closed = case when unclosed_quantity - v_cur_quantity = 0 then 'Y' else 'N' end,
                        unclosed_quantity = unclosed_quantity - v_cur_quantity
                    where id = v_p_id; 
            End LOOP;
            set v_p_id =1 ; 
        end if; 

        

        
        if v_trade_open_close = 2 and v_cur_quantity_left > 0   then 
            set v_trade_open_close = 1; 
            set v_trade_quantity = v_cur_quantity_left;
            
            
            set v_done=0; 
        else 
            set v_done=0; 
            fetch cur_t_trade into v_trade_account_id,v_trade_product_id,v_trade_quantity,v_trade_order_no,v_trade_buy_sell,v_trade_open_close; 
        end if; 


    end while; 
    close cur_t_trade; 

    
    delete from daily_day_trade_counts where market_id = i_market_id and trade_date = i_trade_date; 
    insert into daily_day_trade_counts
    (
        market_id,
        process_date,
        trade_date,
        account_id,
        day_trade_count,
        update_user, 
        update_time
    )
    select 
        i_market_id, 
        v_pd,
        i_trade_date,
        account_id,
        funMin(count(distinct(op_id)),count(distinct(ct_order_no))),
        i_user, 
        now()
    from tmp_co_his
    group by account_id
    having count(1)>0; 

    

    
    delete from day_trade_counts_summary where market_id in (2,16) and  process_date = v_pd;
    set @max_day_trade_times = 3; 

    
    insert into day_trade_counts_summary
    (
        process_date, 
        market_id, 
        account_id, 
        t0,t1,t2,t3,t4, 
        update_time, 
        update_user
    )
    select v_pd,
           i_market_id, 
           account_id, 
           @max_day_trade_times,  
           @max_day_trade_times,  
           @max_day_trade_times,  
           @max_day_trade_times,  
           @max_day_trade_times,  
           now(), 
           i_user
    from capital_account; 

    drop temporary table if exists tmp_last; 
    create temporary table tmp_last
    (
        account_id varchar(16), 
        t0 int, 
        t1 int, 
        t2 int, 
        t3 int,
        t4 int, 
        index idx1(account_id)
    );

    insert into tmp_last
    select account_id, 
           t0, t1, t2, t3, t4 
        from day_trade_counts_summary 
        where market_id =i_market_id and process_date = i_last_process_date; 

    
    update day_trade_counts_summary a 
    left join tmp_last b on  a.account_id = b.account_id
    set  a.t0 = ifnull(b.t1, a.t0),
         a.t1 = ifnull(b.t2, a.t1),
         a.t2 = ifnull(b.t3, a.t2),
         a.t3 = ifnull(b.t4, a.t3)
    where a.market_id = i_market_id and 
          a.process_date = v_pd ;  
          

    
    update day_trade_counts_summary a 
    left join daily_day_trade_counts b on b.market_id = i_market_id and b.trade_date = i_trade_date and a.account_id = b.account_id
    set a.t0 = (funMin(@max_day_trade_times, a.t0 - ifnull(b.day_trade_count,0))),
        a.t1 = case when a.t0 < 0 then 0 else (funMin(@max_day_trade_times, a.t1 - ifnull(b.day_trade_count,0))) end,
        a.t2 = case when a.t0 < 0 then 0 else (funMin(@max_day_trade_times, a.t2 - ifnull(b.day_trade_count,0))) end,
        a.t3 = case when a.t0 < 0 then 0 else (funMin(@max_day_trade_times, a.t3 - ifnull(b.day_trade_count,0))) end,
        a.t4 = case when a.t0 < 0 then 0 else (funMin(@max_day_trade_times, a.t4 - ifnull(b.day_trade_count,0))) end
    where a.market_id = i_market_id and 
          a.process_date = v_pd; 

    update day_trade_counts_summary a 
    inner join day_trade_counts_summary b on b.process_date = i_last_process_date and a.market_id = b.market_id and a.account_id = b.account_id
    set 
        a.t0 = case when b.t0 < 0 and a.t0 = 0 then 0 else a.t0 end,
        a.t1 = case when b.t0 < 0 then 0 else a.t1 end,
        a.t2 = case when b.t0 < 0 then 0 else a.t2 end,
        a.t3 = case when b.t0 < 0 then 0 else a.t3 end,
        a.t4 = case when b.t0 < 0 then 0 else a.t4 end
    where a.market_id = i_market_id and 
          a.process_date = v_pd; 

    

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCreateAccountBalance
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCreateAccountBalance`;
delimiter ;;
CREATE PROCEDURE `proCreateAccountBalance`(IN  i_process_date date,
   IN  i_account_id char(16),
   IN  i_account_type int,
   IN  i_currency int)
label:begin 

    insert into account_balance(
        process_date,
        account_id,
        account_type,
        currency,
        trade_balance,
        settle_balance,
        balance_avail,
        balance_extract,
        market_value,
        long_market_value,
        short_market_value,
        equity,
        frozen_amount,
        uncleared_amount,
        unsettled_amount
        )
    values (
        i_process_date,
        i_account_id,
        i_account_type,
        i_currency,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0,
        0.0
        ); 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCreateBalance
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCreateBalance`;
delimiter ;;
CREATE PROCEDURE `proCreateBalance`(in  i_process_date date, 
    in  i_account_id varchar(16), 
    in  i_account_type int, 
    in  i_currency int,
    OUT o_ret_code int,
    OUT o_ret_msg varchar(64))
label: BEGIN
    set o_ret_code = 0; 
    set o_ret_msg = 'Success';
    start transaction; 

    
    INSERT
    INTO account_balance
    (
    process_date,
    account_id,
    account_type,
    currency
    )
    SELECT
    i_process_date,
    i_account_id, 
    i_account_type, 
    i_currency;
  commit; 
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCreateIndex
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCreateIndex`;
delimiter ;;
CREATE PROCEDURE `proCreateIndex`(In  i_table varchar(64), 
   In  i_indexName varchar(64), 
   In  i_column varchar(255))
label:begin
  
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET @r1 = 1;

    set @str = concat('Create Index ', i_indexName, ' on ', i_table ,'(',i_column,')'); 
    prepare stmt from @str; 
    execute stmt; 
end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCreateProductTmpTable
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCreateProductTmpTable`;
delimiter ;;
CREATE PROCEDURE `proCreateProductTmpTable`(OUT o_ret_code int,
   OUT o_ret_msg char(128))
label:begin

    CREATE TEMPORARY TABLE `tmp_product` (
        `id` bigint(11) NOT NULL AUTO_INCREMENT,
        `list_market_id` int DEFAULT 0,
        `product_type` int DEFAULT 0,
        `product_sub_type` int DEFAULT 0,
        `isin_code` char(32) DEFAULT NULL,
        `product_id` varchar(32) DEFAULT NULL,
        `product_description` VARCHAR(255) DEFAULT NULL,
        `lot_size` decimal(21,6) DEFAULT '0.000000',
        `status` char(1) DEFAULT NULL,
        `contract_size` decimal(21,6) DEFAULT '0.000000',
        `currency` int(11) DEFAULT NULL,
        `price_factor` decimal(21,6) DEFAULT '0.000000',
        `par_value` decimal(21,6) DEFAULT '0.000000',
        `coupon` decimal(21,6) DEFAULT '0.000000',
        `listing_date` date DEFAULT NULL,
        `last_trading_date` date DEFAULT NULL,
        `settle_date` date DEFAULT NULL,
        `underlying_list_market` char(16) DEFAULT NULL,
        `underlying_product_id` varchar(32) DEFAULT NULL,
        `strike_price` decimal(21,6) DEFAULT '0.000000',
        `call_put` char(1) DEFAULT NULL,
        `entitlement_ratio` decimal(21,6) DEFAULT '0.000000',
        `call_price` decimal(21,6) DEFAULT '0.000000',
        `settle_days` int(11) DEFAULT NULL,
        `settle_type` int(11) DEFAULT NULL,
        `update_time` datetime DEFAULT NULL,
        `update_user` char(16) DEFAULT NULL,
        PRIMARY KEY (`id`),
        KEY `idx1` (`list_market_id`,`product_id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;

    set o_ret_code = 1; 
    set o_ret_msg = '创建产品临时表';
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCreateTempAccInfo
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCreateTempAccInfo`;
delimiter ;;
CREATE PROCEDURE `proCreateTempAccInfo`(OUT o_ret_code INT,
    OUT o_ret_msg TEXT)
label: BEGIN

START TRANSACTION;

SET o_ret_code = 1, o_ret_msg ="CREATE_TEMPORARY_TABLE_fail";

CREATE TEMPORARY TABLE `tmp_account_info` (
  `account_id` varchar(16) NOT NULL,
  `password` varchar(256) DEFAULT NULL,
  `account_type` int(11) DEFAULT NULL,
  `account_class` int(11) DEFAULT NULL,
  `auth_markets` int(11) DEFAULT NULL,
  `first_name` varchar(32) DEFAULT NULL,
  `middle_name` varchar(32) DEFAULT NULL,
  `last_name` varchar(32) DEFAULT NULL,
  `short_name` varchar(96) DEFAULT NULL,
  `first_name_eng` varchar(32) DEFAULT NULL,
  `last_name_eng` varchar(32) DEFAULT NULL,
  `gender` int(11) DEFAULT NULL,
  `birth_day` date DEFAULT NULL,
  `photoid_type` int(11) DEFAULT NULL,
  `photoid` varchar(32) DEFAULT NULL,
  `photo_country` varchar(8) DEFAULT NULL,
  `photo_effective_date` date DEFAULT NULL,
  `photo_expiration_date` date DEFAULT NULL,
  `partyid_type` int(11) DEFAULT NULL,
  `partyid` varchar(32) DEFAULT NULL,
  `party_country` varchar(8) DEFAULT NULL,
  `party_effective_date` date DEFAULT NULL,
  `party_expiration_date` date DEFAULT NULL,
  `city` varchar(32) DEFAULT NULL,
  `state` varchar(32) DEFAULT NULL,
  `zip` varchar(32) DEFAULT NULL,
  `country` varchar(8) DEFAULT NULL,
  `email_address` varchar(64) DEFAULT NULL,
  `mailing_address` varchar(512) DEFAULT NULL,
  `daily_statement_email_address` int(11) DEFAULT NULL,
  `monthly_statement_email_address` int(11) DEFAULT NULL,
  `phone1` varchar(32) DEFAULT NULL,
  `phone2` varchar(32) DEFAULT NULL,
  `phone3` varchar(32) DEFAULT NULL,
  `address1` varchar(512) DEFAULT NULL,
  `address2` varchar(512) DEFAULT NULL,
  `address3` varchar(512) DEFAULT NULL,
  `address4` varchar(512) DEFAULT NULL,
  `bank` varchar(32) DEFAULT NULL,
  `bank_account_id` varchar(32) DEFAULT NULL,
  `bank_account_name` varchar(32) DEFAULT NULL,
  `employment` varchar(32) DEFAULT NULL,
  `employer_name` varchar(32) DEFAULT NULL,
  `employer_address1` varchar(512) DEFAULT NULL,
  `employer_address2` varchar(512) DEFAULT NULL,
  `employer_address3` varchar(512) DEFAULT NULL,
  `employer_address4` varchar(512) DEFAULT NULL,
  `employer_city` varchar(32) DEFAULT NULL,
  `employer_state` varchar(32) DEFAULT NULL,
  `employer_zip` varchar(32) DEFAULT NULL,
  `employer_country` varchar(8) DEFAULT NULL,
  `employer_phone1` varchar(32) DEFAULT NULL,
  `employer_phone2` varchar(32) DEFAULT NULL,
  `employer_phone3` varchar(32) DEFAULT NULL,
  `is_government_official` char(1) DEFAULT NULL,
  `is_terrorist` char(1) DEFAULT NULL,
  `famaliy_income` int(11) DEFAULT NULL,
  `famaliy_equity` int(11) DEFAULT NULL,
  `risk_tolerance` int(11) DEFAULT NULL,
  `invest_target` int(11) DEFAULT NULL,
  `security_experience` int(11) DEFAULT NULL,
  `fund_experience` int(11) DEFAULT NULL,
  `forien_exchange_experience` int(11) DEFAULT NULL,
  `fixed_income_experience` int(11) DEFAULT NULL,
  `others_incom_experience` int(11) DEFAULT NULL,
  `loan_limit` decimal(30,10) DEFAULT NULL,
  `app_usable` decimal(30,10) DEFAULT NULL,
  `client_group_code` varchar(8) DEFAULT NULL,
  `bos_uuid` varchar(32) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `remark` varchar(256) DEFAULT NULL,
  PRIMARY KEY (`account_id`),
  KEY (`account_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

SET o_ret_code = 0, o_ret_msg ="Success";

COMMIT;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proCreateTradeTmpTable
-- ----------------------------
DROP PROCEDURE IF EXISTS `proCreateTradeTmpTable`;
delimiter ;;
CREATE PROCEDURE `proCreateTradeTmpTable`(OUT o_ret_code int,
   OUT o_ret_msg char(128))
label:begin

    start transaction;
    drop temporary table  if EXISTS tmp_account_trade_detail;
    CREATE  temporary TABLE `tmp_account_trade_detail` (
        `id` bigint(11) NOT NULL AUTO_INCREMENT,
        `trade_id` char(32) DEFAULT NULL,   
        `trade_exec_id` char(32) DEFAULT NULL,
        `process_date` date DEFAULT NULL,
        `order_no` char(32) DEFAULT NULL,
        `order_date` date DEFAULT NULL,
        `order_time` time DEFAULT NULL,
        `business_department` char(16) DEFAULT NULL,
        `department_trading_group` char(16) DEFAULT NULL,
        `account_id` char(16) DEFAULT NULL,
        `account_type` int(11) DEFAULT NULL,
        `trade_date` date DEFAULT NULL,
        `settle_date` date DEFAULT NULL,
        `market_id` int DEFAULT 0,
        `list_market_id` int DEFAULT 0,
        `product_type` int DEFAULT 0,
        `product_sub_type` varchar(16),
        `product_id` varchar(32) DEFAULT NULL,
        `product_description` varchar(255) DEFAULT NULL,
        `quote_currency` char(3) DEFAULT NULL,
        `clearing_currency` char(3) DEFAULT NULL,
        `exchange_rate` decimal(30,10) DEFAULT NULL,
        `buy_sell` int(11) DEFAULT NULL,
        `order_price` decimal(30,10) DEFAULT NULL,
        `order_quantity` decimal(30,10) DEFAULT NULL,
        `trade_quantity` decimal(30,10) DEFAULT NULL,
        `status` int(11) DEFAULT NULL,
        `open_close` int(11) DEFAULT NULL,
        `hedge_flag` int(11) DEFAULT NULL,
        `call_put` int(11) DEFAULT NULL,
        `strike_price` decimal(30,10) DEFAULT NULL,
        `contract_date` date DEFAULT NULL,
        `input_channel` int(11) DEFAULT NULL,
        `remark` text,
        `exec_time` datetime(3) DEFAULT NULL,
        `exec_no` char(128) DEFAULT NULL,
        `exchange_ref_no` char(32) DEFAULT NULL,
        `exec_broker` char(16) DEFAULT NULL,
        `contra_broker` char(16) DEFAULT NULL,
        `exec_quantity` decimal(30,10) DEFAULT NULL,
        `exec_price` decimal(30,10) DEFAULT NULL,
        `code` int  DEFAULT 0,
        `mark` char(16) DEFAULT NULL,
        num_of_trades int DEFAULT 0,
        trade_amount decimal(30,10) default 0.0, 
        net_amount decimal(30,10) default 0.0,
        `custodian_code` char(16) DEFAULT NULL,
        `custodian_account` char(16) DEFAULT NULL,
        `broker` char(16) DEFAULT NULL,
        is_odd_lot varchar(1) default '',
        PRIMARY KEY (`id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;

    create index Index1 on tmp_account_trade_detail (trade_id,trade_exec_id);
    create index Index2 on tmp_account_trade_detail (trade_date);
    create index Index3 on tmp_account_trade_detail (order_no);
    create index Index4 on tmp_account_trade_detail (input_channel);
    create index Index5 on tmp_account_trade_detail (trade_date,account_id,account_type,list_market_id,product_id,buy_sell,input_channel,broker,custodian_code,custodian_account);
    create index Index6 on tmp_account_trade_detail (list_market_id,product_id);
    -- 客户原始成交数据
    drop temporary table if exists tmp_account_trae_detail_orginal; 
    create temporary table tmp_account_trae_detail_orginal select * from tmp_account_trade_detail where 1 = 2; 
    create index Index1 on tmp_account_trae_detail_orginal (trade_id,trade_exec_id);
    create index Index2 on tmp_account_trae_detail_orginal (trade_date);
    create index Index3 on tmp_account_trae_detail_orginal (order_no);
    create index Index4 on tmp_account_trae_detail_orginal (input_channel);


    drop temporary table  if EXISTS tmp_account_trade;
    CREATE  temporary TABLE `tmp_account_trade` (
        `id` bigint(11) NOT NULL AUTO_INCREMENT,
        `process_date` date DEFAULT NULL,
        `trade_date` date DEFAULT NULL,
        `settle_date` date DEFAULT NULL,
        `trade_id` char(32) DEFAULT NULL,
        `business_department` char(16) DEFAULT NULL,
        `department_trading_group` char(16) DEFAULT NULL,
        `account_id` char(16) DEFAULT NULL,
        `account_type` int(11) DEFAULT NULL,
        `market_id` int DEFAULT 0,
        `list_market_id` int DEFAULT 0,
        `product_id` varchar(32) DEFAULT NULL,
        `product_description` VARCHAR(255) DEFAULT NULL,
        `product_type` int(11) DEFAULT NULL,
        `product_sub_type` char(16) DEFAULT NULL,
        `quote_currency` char(3) DEFAULT NULL,
        `clearing_currency` char(3) DEFAULT NULL,
        `exchange_rate` decimal(30,10) DEFAULT NULL,
        `buy_sell` int(11) DEFAULT NULL,
        `quantity` decimal(21,6) DEFAULT '0.000000',
        `avg_price` decimal(21,6) DEFAULT '0.000000',
        `trade_amount` decimal(30,10) DEFAULT '0.0000000000',
        `net_amount` decimal(30,10) DEFAULT '0.0000000000',
        `open_close` int(11) DEFAULT NULL,
        `hedge_flag` int(11) DEFAULT NULL,
        `call_put` int(11) DEFAULT NULL,
        `strike_price` decimal(30,10) DEFAULT NULL,
        `contract_date` date DEFAULT NULL,
        `input_channel` int(11) DEFAULT NULL,
        `remark` text,
        `num_of_trades` int(11) DEFAULT NULL,
        `order_no` char(32) DEFAULT NULL,
        `order_date`  date DEFAULT NULL,
        `update_time` varchar(30) DEFAULT NULL,
        `update_user` char(16) DEFAULT NULL,
        commission decimal(30,10),
        charges   decimal(30,10),
        `custodian_code` char(16) DEFAULT NULL,
        `custodian_account` char(16) DEFAULT NULL,
        `broker` char(16) DEFAULT NULL,
        is_odd_lot varchar(1) default '',
        PRIMARY KEY (`id`)
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
        create index Index1 on tmp_account_trade (trade_id);
        create index Index2 on tmp_account_trade (order_date,order_no);
        create index Index3 on tmp_account_trade (trade_date,account_id,account_type,list_market_id,product_id,buy_sell,input_channel,broker,custodian_code,custodian_account);
        create index Index4 on tmp_account_trade (process_date,market_id,product_id,account_id,account_type,buy_sell,input_channel);
        create index Index5 on tmp_account_trade (trade_date);
        create index Index6 on tmp_account_trade (list_market_id);
    set o_ret_code = 0; 
    set o_ret_msg = '创建交易临时表完成';

    commit;
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proDayPortfolioFee
-- ----------------------------
DROP PROCEDURE IF EXISTS `proDayPortfolioFee`;
delimiter ;;
CREATE PROCEDURE `proDayPortfolioFee`(IN  i_process_date date,  
  OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin
    declare v_process_date date; 
    declare v_last_process_date  date; 
    declare v_formula varchar(255) default '0';
    declare v_exchange_rate decimal(30,10) default 0.0000;
    declare v_id bigint;  
    declare v_done int; 

    DECLARE cur_charge CURSOR FOR
    SELECT
      a.id
    FROM
      account_portfolio_fee a
    where a.process_date = i_process_date; 

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1; 
    set o_ret_code = 0, o_ret_msg ="Success";
    
    select buss_date,last_buss_date  into v_process_date,v_last_process_date from sys_info; 

    if i_process_date is  NULL then 
        set i_process_date = v_process_date;
    end if; 

    select round(exchange_rate,6) into v_exchange_rate from currency where currency = 1;

    delete from account_portfolio_fee where process_date  = i_process_date; 

    insert into account_portfolio_fee(
                process_date,
                account_id,
                market_id,
                currency,
                account_type,
                portfolio_value,
                base_portfolio_value,
                formula_code,
                formula_value,
                charge_rate,
                charge_amount,
                base_charge_amount,
                portfolio_value_t0,
                base_portfolio_value_t0
        )
    select      i_process_date,
                a.account_id,
                a.market_id,
                '2',
                a.account_type,
                sum(a.market_value),
                round(sum(a.market_value)*v_exchange_rate,2),
                c.formula_code,
                c.formula_value,
                0,
                0,
                0,
                0,
                0
                from account_position a
                inner join currency b on b.currency = a.currency
                inner join formula c on c.formula_code = 'PORTFOLIO_FEE_SHA'
                where a.process_date = v_process_date and a.market_id in (4,8)
                group by a.account_id,a.market_id 
                order by a.account_id,a.market_id;
    

        
    drop temporary table if EXISTS cal1; 
    create temporary table cal1
    (
        id bigint primary key,   
        mv decimal(30,10),   
        charge_amount decimal(30,10)
    );

    drop temporary table if EXISTS cal2; 
    create temporary table cal2
    (
        id bigint primary key,   
        mv decimal(30,10),   
        base_charge_amount decimal(30,10)
    );

    
    insert into cal1 
    (
        id,
        mv
    )
    select 
        a.id,
        a.portfolio_value
    from 
    account_portfolio_fee a
    where a.process_date = i_process_date;

    insert into cal2
    (
        id, 
        mv
    )
    select 
        a.id,
        a.base_portfolio_value
    from 
    account_portfolio_fee a
    where a.process_date = i_process_date;

    select 
            formula_value
        into 
            v_formula
    from formula 
    where formula_code = 'PORTFOLIO_FEE_SHA';

    
    open cur_charge; 
    set v_done = 0; 
    fetch cur_charge into v_id; 
    while v_done <> 1 do 

        SET @sql = CONCAT('update cal1 ',
                          'set charge_amount = ', v_formula, ' '
                          'where id =', v_id, ';');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        SET @sql = CONCAT('update cal2 ',
                          'set base_charge_amount = ', v_formula, ' '
                          'where id =', v_id, ';');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;

        set v_done = 0; 
        fetch cur_charge into v_id; 
    end while; 
    close cur_charge; 

    UPDATE
      account_portfolio_fee a
      LEFT JOIN cal1 b ON a.id = b.id
      LEFT JOIN cal2 c ON a.id = c.id
    SET
        a.charge_amount = b.charge_amount,
        a.base_charge_amount = c.base_charge_amount
    where a.process_date = i_process_date;

    update account_portfolio_fee a
    left join cancel_product_flow b on a.process_date = b.process_date and a.account_id = b.account_id and a.account_type = b.account_type and a.market_id = b.market_id
    set a.base_charge_amount = a.base_charge_amount + ifnull(b.portfolio_fee,0)
    where a.process_date = i_process_date;    

    drop temporary table if EXISTS tmp_account_portfolio_fee; 
    create temporary table tmp_account_portfolio_fee
    (
        account_id varchar(16), 
        account_type int,
        currency int , 
        charge_amount decimal(30,10) default 0 , 
        base_charge_amount decimal(30,10) default 0,
        index idx1(account_id,account_type,currency)  
    );

    insert into tmp_account_portfolio_fee
    (
        account_id,
        account_type,
        currency,
        charge_amount,
        base_charge_amount
    )
    select 
        account_id,
        account_type,
        currency,
        sum(charge_amount),
        sum(base_charge_amount)
    from account_portfolio_fee
    where process_date = i_process_date
    group by account_id,account_type,currency
    order by account_id,account_type,currency;

    UPDATE account_balance a
    inner join tmp_account_portfolio_fee b on a.account_id = b.account_id and a.account_type = b.account_type and a.currency =b.currency
    set a.portfolio_fee = a.portfolio_fee + b.base_charge_amount
    where a.process_date = v_process_date;

    set o_ret_code = 0; 
    set o_ret_msg = "托管费计算完成";

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proDeleteExpiredOptionPosition
-- ----------------------------
DROP PROCEDURE IF EXISTS `proDeleteExpiredOptionPosition`;
delimiter ;;
CREATE PROCEDURE `proDeleteExpiredOptionPosition`(out o_ret_code int, 
    out o_ret_msg varchar(128))
label:BEGIN

    declare v_process_date date;
    declare v_done int; 

    declare v_account_id varchar(32) ; 
    declare v_account_type int;
    declare v_market_id int; 
    declare v_product_id varchar(32); 
    declare v_net_quantity decimal(30,10);
    declare v_quantity decimal(30,10); 
    declare v_custodian_code varchar(16); 
    declare v_custodian_account varchar(16); 
    declare v_nominee_quantity decimal(30,10); 
    declare v_avg_price decimal(30,10); 
    declare v_avg_price2 decimal(30,10); 
    declare v_remark varchar(128); 
    declare v_update_user varchar(32); 
    declare v_update_time datetime; 

    declare v_t0 date; 
    declare v_t1 date; 
    declare v_next_settle_date date; 
    declare v_r_date date; -- 真实日期
    declare v_r_quantity decimal(30,10);  -- 真实数量


    DECLARE cur_data CURSOR FOR
    SELECT 
        a.account_id , 
        a.account_type, 
        a.market_id, 
        a.product_id, 
        a.net_quantity, 
        a.quantity,
        a.custodian_code, 
        a.custodian_account, 
        0, 
        0, 
        0, 
        'AUTO OPTION EXERCISE' as remark, 
        'Auto' as update_user, 
        now() as update_time
    from account_position a 
    inner join product b on b.list_market_id = a.market_id and b.product_id = a.product_id and b.product_type = 16 and b.exercise_date <= v_t0
    where a.process_date = v_process_date and a.net_quantity>0;
      

    DECLARE CONTINUE HANDLER FOR NOT FOUND
    SET
      v_done = 1; 


    set o_ret_code =0; 
    set o_ret_msg = "";

    select buss_date into v_process_date from sys_info;

    -- 获取美股交易日T0, T1. 
    select t0, t1 into v_t0, v_t1 from market where market_id = 2; 

    -- 获取下一个交收日 
    set v_next_settle_date =  funIntervalSettleDay(2, v_t0, 1);

    open cur_data; 
    set v_done  =0; 
    fetch cur_data into v_account_id, v_account_type, v_market_id,v_product_id,v_net_quantity, v_quantity, v_custodian_code, v_custodian_account, v_nominee_quantity, v_avg_price, v_avg_price2,v_remark, v_update_user, v_update_time; 
    while v_done <> 1 do

        if v_quantity > 0  then 
        -- 转出真实在手股票
            set v_r_date = v_process_date; 
            set v_r_quantity = v_quantity; 
            
            call proProductOut(v_r_date, v_account_id,v_account_type, v_market_id,v_product_id, v_r_quantity, v_custodian_code, v_custodian_account, v_nominee_quantity, v_avg_price, v_avg_price2,v_remark, v_update_user, v_update_time, o_ret_code, o_ret_msg);
            if o_ret_code then 
                leave label;
            end if; 
        end if; 
        

        if v_net_quantity > v_quantity then 
        -- 有待收取的股票: quantity 1, net_quantity 100.  我们会在上边转出1 股，net_quantity 变成99.quantity变成0. 在交收日我们会转入 99股， 所以我们现在settle day要转出99股.
        -- 转出待交收部分的股票，在交收日进行交割 
            set v_r_date  = v_next_settle_date; 
            set v_r_quantity =  v_net_quantity  - v_quantity;
            call proProductOut(v_r_date, v_account_id,v_account_type, v_market_id,v_product_id, v_r_quantity, v_custodian_code, v_custodian_account, v_nominee_quantity, v_avg_price, v_avg_price2,v_remark, v_update_user, v_update_time, o_ret_code, o_ret_msg);
            if o_ret_code then 
                leave label;
            end if;
        end if; 

        if v_net_quantity < v_quantity then 
        -- 待转出的股票: quantity 100. net_quantity 1. 我们会在上边转出100股，net_quantity 变成-99. quantiyt 变成0.  在交收日我们会转出99股股票， 所以我们要在交收日转入99股
            set v_r_date  = v_next_settle_date; 
            set v_r_quantity =  v_quantity - v_net_quantity; 
            call proProductIn(v_r_date, v_account_id,v_account_type, v_market_id,v_product_id, v_r_quantity, v_custodian_code, v_custodian_account, v_nominee_quantity, v_avg_price, v_avg_price2,v_remark, v_update_user, v_update_time, o_ret_code, o_ret_msg);
            if o_ret_code then 
                leave label;
            end if;
        end if; 

        set v_done  =0; 
        fetch cur_data into v_account_id, v_account_type, v_market_id,v_product_id,v_net_quantity, v_quantity, v_custodian_code, v_custodian_account, v_nominee_quantity, v_avg_price, v_avg_price2,v_remark, v_update_user, v_update_time; 
    end while; 
    close cur_data; 

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExerciseOptionImpl
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExerciseOptionImpl`;
delimiter ;;
CREATE PROCEDURE `proExerciseOptionImpl`(in  i_user varchar(32),
    in  i_market_id int, 
    in  i_product_type int,
    out o_ret_code int, 
    out o_ret_msg varchar(64))
label:begin

    declare  v_process_date date; 
    set o_ret_code = 0;
    set o_ret_msg = '';
    
    -- 创建临时表
call proCreateTradeTmpTable(o_ret_code, o_ret_msg);
if o_ret_code then 
    leave label; 
end if; 

-- 导入交易明细
call proImportTradeToTmpTable(i_market_id, i_product_type,o_ret_code, o_ret_msg);
if o_ret_code then 
    leave label; 
end if; 

-- 导入数据 
call proProductTmpAccountTradeDetail(o_ret_code, o_ret_msg);
if o_ret_code then 
    leave label; 
end if; 

-- 费用 
call proMarketCharge(o_ret_code, o_ret_msg); 
if o_ret_code then 
    leave label; 
end if; 

-- 新建持仓
call proOpenPosition(i_market_id, i_product_type,o_ret_code, o_ret_msg);
if o_ret_code then 
    leave label; 
end if; 

-- 交收处理
call proSettle(i_market_id, i_product_type,'N',o_ret_code, o_ret_msg);
if o_ret_code then 
    leave label; 
end if;

-- 持仓处理
call proPosition(i_market_id, i_product_type,o_ret_code, o_ret_msg);
if o_ret_code <> 0 then 
    rollback;
    leave label; 
end if; 

-- 余额处理
call proBalance(i_market_id, i_product_type, o_ret_code,o_ret_msg); 
if o_ret_code <> 0 then 
    leave label; 
end if; 

update import_account_trade_detail 
        set ConfirmStatus = "Confirmed"
    where ConfirmStatus = 'Pending'  and market_id = i_market_id and product_type  =i_product_type; 

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExpiringPosition
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExpiringPosition`;
delimiter ;;
CREATE PROCEDURE `proExpiringPosition`(IN  i_market_id int, 
    IN  i_product_id varchar(32), 
    IN  i_last_trading_date date,
    In  i_update_user varchar(32), 
    OUT o_ret_code int,
    OUT o_ret_msg char(128))
label:begin
    declare v_process_date date default NULL;
    declare v_account_id varchar(16) default NULL; 
    declare v_account_type int default 0;
    DECLARE v_custodian_code varchar(16);
    DECLARE v_custodian_account varchar(16);
    DECLARE v_remark varchar(128);
    declare v_quantity decimal(30,10); 
    declare v_done int default 0; 

    DECLARE cur_account CURSOR FOR
        select 
            account_id,account_type,quantity,custodian_code,custodian_account
        from account_position 
        where process_date = v_process_date and 
              market_id = i_market_id and 
              product_id = i_product_id and 
              quantity <> 0;

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1;

    set o_ret_code = '0'; 
    set o_ret_msg = 'Success';
    
    start transaction; 
    
    select buss_date into v_process_date from sys_info; 
    
    if v_process_date is NULL then 
        set o_ret_code = 1, o_ret_msg = "Bussness date not setting up"; 
        rollback; 
        leave label; 
    end if;

    
    if not EXISTS(select 1 from product where list_market_id  = i_market_id and product_id = i_product_id) then 
        set o_ret_code = 1, o_ret_msg = "Product not exists"; 
        leave label; 
    end if; 

    set v_remark = concat('Product Expired At ',i_last_trading_date);

    OPEN cur_account;
        SET v_done = 0;
        FETCH cur_account INTO v_account_id,v_account_type,v_quantity,v_custodian_code,v_custodian_account;
        WHILE v_done <> 1 DO
            
            call proProductOut(v_process_date,v_account_id,v_account_type,i_market_id,i_product_id,v_quantity,v_custodian_code,v_custodian_account,
                0,0,0,v_remark,i_update_user,now(),o_ret_code,o_ret_msg);
            if o_ret_code then 
                rollback; 
                leave label; 
            end if; 

            SET v_done = 0;
            FETCH cur_account INTO v_account_id,v_account_type,v_quantity,v_custodian_code,v_custodian_account;
        END WHILE;
    CLOSE cur_account;

COMMIT;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportASharesMarketBoughtSoldJournal
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportASharesMarketBoughtSoldJournal`;
delimiter ;;
CREATE PROCEDURE `proExportASharesMarketBoughtSoldJournal`(IN i_process_date DATE)
label:BEGIN

drop temporary table IF EXISTS tmp_rpt;
CREATE TEMPORARY TABLE tmp_rpt
(
    process_date DATE,
    trade_date DATE,
    settle_date DATE,
    memo VARCHAR(64),
    buy_sell INT,
    clearing_currency INT,
    trade_id VARCHAR(32),
    ae_code VARCHAR(32),
    account_id VARCHAR(32),
    account_type INT,
    broker VARCHAR(32),
    input_channel INT,
    list_market_id INT,
    product_id VARCHAR(32),
    product_description VARCHAR(256),
    price DECIMAL(30,10),
    quantity INT,
    trade_amount DECIMAL(30,10),
    stamp DECIMAL(30,10),
    handling_fee DECIMAL(30,10),
    management_fee DECIMAL(30,10),
    transfer_fee DECIMAL(30,10),
    others DECIMAL(30,10),
    commission DECIMAL(30,10),
    net_amount DECIMAL(30,10),
    data_type INT,
    INDEX idx1(memo,product_id,list_market_id,account_id,trade_id,data_type), 
    index idx2(data_type)
);

drop temporary table if exists tmp1; 
create temporary table tmp1
 SELECT 
    external_id,
    SUM(IF(charge_code IN('STAMP DUTY:SHA','STAMP DUTY:SZA','STAMP_HK:HK'),charges,0))AS stamp,
    SUM(IF(charge_code IN('HANDLING_FEE_SHA:SHA','HANDLING_FEE_SZA:SZA','HANDLING FEE_HK:HK'),charges,0))AS handling_fee,
    SUM(IF(charge_code IN('SMF_FEE_SHA:SHA','SMF_FEE_SZA:SZA'),charges,0))AS management_fee,
    SUM(IF(charge_code IN('TRANSFER_FEE:SHA','TRANSFER_FEE:SZA'),charges,0))AS transfer_fee,
    SUM(IF(charge_code IN('HK_DEFAULT_COMMISSION','US_DEFAULT_COMMISSION','SSE_DEFAULT_COMMISSION','SZSE_DEFAULT_COMMISSION'),charges,0))AS commission,
    SUM(IF(charge_code NOT IN('STAMP DUTY:SHA','STAMP DUTY:SZA','STAMP_HK:HK','HANDLING_FEE_SHA:SHA','HANDLING_FEE_SZA:SZA','HANDLING FEE_HK:HK','SMF_FEE_SHA:SHA','SMF_FEE_SZA:SZA','TRANSFER_FEE:SHA','TRANSFER_FEE:SZA','HK_DEFAULT_COMMISSION','US_DEFAULT_COMMISSION','SSE_DEFAULT_COMMISSION','SZSE_DEFAULT_COMMISSION'),charges,0))AS others
FROM account_charge WHERE process_date=i_process_date GROUP BY external_id;
create index idx1 on tmp1(external_id);


INSERT INTO tmp_rpt 
SELECT 
process_date,
trade_date,
a.settle_date,
''AS memo,
buy_sell,
clearing_currency,
trade_id,
''AS ae_code,
account_id,
account_type,
broker,
input_channel,
a.list_market_id,
a.product_id,
replace(c.product_description,',',' '),
NULL, 
NULL, 
trade_amount,
stamp,
handling_fee,
management_fee,
transfer_fee,
others,
b.commission,
net_amount*IF(buy_sell=1,-1,1),
1 
FROM jcbms.account_trade a 
LEFT JOIN tmp1 b ON a.trade_id=b.external_id
LEFT JOIN product c ON a.list_market_id=c.list_market_id AND a.product_id=c.product_id 
WHERE  process_date=i_process_date AND a.list_market_id IN (4,8) and a.status = 'Confirmed' ORDER BY buy_sell,product_id,a.list_market_id,account_id,trade_id;

INSERT INTO tmp_rpt(memo,  buy_sell,  product_id,  list_market_id,  account_id,  trade_id,       price,         quantity,  data_type) 
SELECT            '',b.buy_sell,b.product_id,b.list_market_id,b.account_id,a.trade_id,a.exec_price,SUM(exec_quantity), 2
FROM account_trade_detail a 
INNER JOIN account_trade b ON  a.trade_id=b.trade_id
WHERE a.process_date=i_process_date AND b.list_market_id IN (4,8) GROUP BY a.trade_id,a.exec_price;

drop temporary table IF EXISTS tmp_rpt_2;
CREATE TEMPORARY TABLE tmp_rpt_2 
SELECT * FROM tmp_rpt WHERE 1=2;

INSERT INTO tmp_rpt_2(                                                               memo,clearing_currency,buy_sell,account_type,    trade_amount,     stamp,     handling_fee,     management_fee,     transfer_fee,     others,     commission,     net_amount,  data_type)
SELECT CONCAT('1_Total',IF(buy_sell=1,'Buy','Sell'),IF(account_type=1,'Cash','Margin')),clearing_currency,buy_sell,account_type,SUM(trade_amount),SUM(stamp),SUM(handling_fee),SUM(management_fee),SUM(transfer_fee),SUM(others),SUM(commission),SUM(net_amount), 3
FROM tmp_rpt 
WHERE data_type=1 
GROUP BY clearing_currency,buy_sell,account_type;


INSERT INTO tmp_rpt_2(                                                               memo,clearing_currency,buy_sell,                 trade_amount,     stamp,     handling_fee,     management_fee,     transfer_fee,     others,     commission,     net_amount,  data_type)
SELECT CONCAT('2_Total',IF(buy_sell=1,'Buy','Sell')),clearing_currency,buy_sell,             SUM(trade_amount),SUM(stamp),SUM(handling_fee),SUM(management_fee),SUM(transfer_fee),SUM(others),SUM(commission),SUM(net_amount), 3
FROM tmp_rpt WHERE data_type=1 GROUP BY clearing_currency,buy_sell;

INSERT INTO tmp_rpt_2(                                                               memo,clearing_currency,         account_type,    trade_amount,     stamp,     handling_fee,     management_fee,     transfer_fee,     others,     commission,     net_amount,  data_type)
SELECT CONCAT('3_Total',IF(account_type=1,'Cash','Margin')),clearing_currency,         account_type,SUM(trade_amount),SUM(stamp),SUM(handling_fee),SUM(management_fee),SUM(transfer_fee),SUM(others),SUM(commission),SUM(net_amount), 3
FROM tmp_rpt 
WHERE data_type=1 
GROUP BY clearing_currency,account_type;


INSERT INTO tmp_rpt_2(                                                               memo,clearing_currency,                          trade_amount,     stamp,     handling_fee,     management_fee,     transfer_fee,     others,     commission,     net_amount,  data_type)
SELECT                                                                      '4_Total',clearing_currency,                      SUM(trade_amount),SUM(stamp),SUM(handling_fee),SUM(management_fee),SUM(transfer_fee),SUM(others),SUM(commission),SUM(net_amount), 3
FROM tmp_rpt 
WHERE data_type=1 
GROUP BY clearing_currency;

INSERT INTO tmp_rpt_2(                                                               memo,clearing_currency,                          trade_amount,     stamp,     handling_fee,     management_fee,     transfer_fee,     others,     commission,     net_amount,  data_type)
                         SELECT CONCAT('5_Trade',IF(input_channel=5,'Indirect','Direct')),clearing_currency,                      SUM(trade_amount),SUM(stamp),SUM(handling_fee),SUM(management_fee),SUM(transfer_fee),SUM(others),SUM(commission),SUM(net_amount), 3
FROM tmp_rpt 
WHERE data_type=1 
GROUP BY clearing_currency,IF(input_channel=5,5,0); 

INSERT INTO tmp_rpt_2(                                                               memo,clearing_currency,                          trade_amount)
SELECT                                                       '6_StampPayableTurnover',clearing_currency,         SUM(IF(stamp=0,0,trade_amount)) 
FROM tmp_rpt 
WHERE data_type=1 
GROUP BY clearing_currency;

INSERT INTO tmp_rpt_2(                                                               memo,clearing_currency,                          trade_amount)
SELECT                                                            '7_TotalMktCharges',clearing_currency,SUM(stamp+handling_fee+management_fee+transfer_fee+others)
FROM tmp_rpt 
WHERE data_type=1 
GROUP BY clearing_currency;

INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_2;
SELECT * FROM tmp_rpt ORDER BY memo,buy_sell,product_id,list_market_id,account_id,price;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportASharesMarketTradeSummary
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportASharesMarketTradeSummary`;
delimiter ;;
CREATE PROCEDURE `proExportASharesMarketTradeSummary`(in i_process_date date)
label:begin
DECLARE v_note_17 DECIMAL(30,10);
DECLARE v_note_18 DECIMAL(30,10);
DECLARE v_note_19 DECIMAL(30,10);
DECLARE v_note_20 DECIMAL(30,10);
DECLARE v_note_21 DECIMAL(30,10);
    

    
    drop temporary table if exists tmp_charges; 
    create temporary table tmp_charges
    (
        account_type int, 
        buy_sell int, 
        currency int,
        seller_stamp decimal(30,10),
        handling_fee decimal(30,10), 
        securities_management_fee decimal(30,10), 
        transfer_fee decimal(30,10), 
        others decimal(30,10), 
        seller_stamp_hkd decimal(30,10),
        handling_fee_hkd decimal(30,10), 
        securities_management_fee_hkd decimal(30,10), 
        transfer_fee_hkd decimal(30,10), 
        others_hkd decimal(30,10), 
        index idx1(account_type, buy_sell,currency)
    ); 

    insert into tmp_charges
    (
        account_type, 
        buy_sell, 
        currency, 
        seller_stamp, 
        handling_fee,
        securities_management_fee, 
        transfer_fee, 
        others
    )
    select 
        a.account_type,
        a.buy_sell,
        b.currency,
        sum(round(case when b.charge_code in('STAMP DUTY:SHA','STAMP DUTY:SZA') then b.charges else 0 end  ,2)) as seller_stamp,
        sum(round(case when b.charge_code in('HANDLING_FEE_SHA:SHA','HANDLING_FEE_SZA:SZA') then b.charges else 0 end  ,2)) as handling_fee,
        sum(round(case when b.charge_code in('SMF_FEE_SHA:SHA','SMF_FEE_SZA:SZA') then b.charges else 0 end  ,2)) as management_fee,
        sum(round(case when b.charge_code in('TRANSFER_FEE:SHA','TRANSFER_FEE:SZA') then b.charges else 0 end  ,2)) as transfer_fee,
        sum(round(case when b.charge_code not in ('STAMP DUTY:SHA','STAMP DUTY:SZA','HANDLING_FEE_SHA:SHA','HANDLING_FEE_SZA:SZA','SMF_FEE_SHA:SHA','SMF_FEE_SZA:SZA','TRANSFER_FEE:SHA','TRANSFER_FEE:SZA','SSE_DEFAULT_COMMISSION','SZSE_DEFAULT_COMMISSION') then b.charges else 0 end  ,2)) as others
    from account_trade a 
    inner join account_charge b on a.trade_id = b.external_id
    where a.process_date = i_process_date and a.market_id in('4','8') and a.status = 'Confirmed'
    group by a.account_type,a.buy_sell, b.currency;

    
    update tmp_charges a
    left join currency b on a.currency = b.currency 
    left join currency_history c on i_process_date = c.process_date and a.currency = c.currency
    set a.seller_stamp_hkd = round(ifnull(c.exchange_rate,b.exchange_rate)*a.seller_stamp,2),
        a.handling_fee_hkd = round(ifnull(c.exchange_rate,b.exchange_rate)*a.handling_fee,2),
        a.securities_management_fee_hkd = round(ifnull(c.exchange_rate,b.exchange_rate)*a.securities_management_fee,2),
        a.transfer_fee_hkd = round(ifnull(c.exchange_rate,b.exchange_rate)*a.transfer_fee,2),
        a.others_hkd = round(ifnull(c.exchange_rate,b.exchange_rate)*a.others,2);

    drop temporary table if exists tmp_rpt; 
    create temporary table tmp_rpt
    (
        process_date DATE,
        memo VARCHAR(256),
        account_type int, 
        buy_sell int,
        currency int,
        broker_payable_receivable decimal(30,10), 
        commission_income decimal(30,10), 
        ae_commission decimal(30,10), 
        net_income decimal(30,10),
        seller_stamp decimal(30,10),
        handling_fee decimal(30,10), 
        securities_management_fee decimal(30,10), 
        transfer_fee decimal(30,10), 
        others decimal(30,10), 
        client_receivable_payable decimal(30,10), 
        broker_payable_receivable_hkd decimal(30,10), 
        commission_income_hkd decimal(30,10), 
        ae_commission_hkd decimal(30,10), 
        net_income_hkd decimal(30,10),
        seller_stamp_hkd decimal(30,10),
        handling_fee_hkd decimal(30,10), 
        securities_management_fee_hkd decimal(30,10), 
        transfer_fee_hkd decimal(30,10), 
        others_hkd decimal(30,10), 
        client_receivable_payable_hkd decimal(30,10), 
        summary_receivable     DECIMAL(30,10), 
        summary_payable        DECIMAL(30,10), 
        summary_total          DECIMAL(30,10), 
        summary_net_receivable DECIMAL(30,10), 
        summary_net_payable    DECIMAL(30,10), 
        summary_net_total      DECIMAL(30,10), 
        index idx(account_type, buy_sell,currency)
    );

    insert into tmp_rpt
    (
        account_type, 
        buy_sell, 
        currency,
        broker_payable_receivable, 
        commission_income, 
        ae_commission, 
        client_receivable_payable
    )
    select 
        a.account_type,
        buy_sell,
        b.currency,
        sum(round(a.trade_amount,2)) as broker_payable_receivable, 
        sum(round(a.commission,2)) as commission_income,
        0 as ae_income, 
        sum(round(a.net_amount,2)) as client_receivable_payable
    from account_trade a 
    left join currency b on a.clearing_currency = b.currency 
    left join currency_history c on a.process_date = c.process_date and a.clearing_currency = c.currency
    where a.process_date = i_process_date
    and a.market_id in ('4','8') and a.status = 'Confirmed'
    group by a.account_type, buy_sell,b.currency;

    update tmp_rpt a  
    left join tmp_charges b on a.account_type = b.account_type and a.buy_sell = b.buy_sell and a.currency = b.currency
    left join currency c on a.currency = c.currency 
    left join currency_history d on i_process_date = d.process_date and a.currency = d.currency
    set a.net_income = a.commission_income+ a.ae_commission, 
        a.seller_stamp = ifnull(b.seller_stamp,0), 
        a.handling_fee = ifnull(b.handling_fee,0), 
        a.securities_management_fee = ifnull(b.securities_management_fee,0), 
        a.transfer_fee = ifnull(b.transfer_fee,0),
        a.others = ifnull(b.others,0),
        a.seller_stamp_hkd = ifnull(b.seller_stamp_hkd,0), 
        a.handling_fee_hkd = ifnull(b.handling_fee_hkd,0), 
        a.securities_management_fee_hkd = ifnull(b.securities_management_fee_hkd,0), 
        a.transfer_fee_hkd = ifnull(b.transfer_fee_hkd,0),
        a.others_hkd = ifnull(b.others_hkd,0), 
        a.broker_payable_receivable_hkd = round(ifnull(d.exchange_rate,c.exchange_rate)*a.broker_payable_receivable,2),
        a.commission_income_hkd = round(ifnull(d.exchange_rate,c.exchange_rate)*a.commission_income,2),
        a.ae_commission_hkd = round(ifnull(d.exchange_rate,c.exchange_rate)*a.ae_commission,2),
        a.client_receivable_payable_hkd = round(ifnull(d.exchange_rate,c.exchange_rate)*a.client_receivable_payable,2);

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, voucher_value, update_time)
SELECT i_process_date, 'note_16', 'CCASS rece - China A - RMB', SUM((account_type*2-3)*broker_payable_receivable), NOW() FROM tmp_rpt WHERE NOT (account_type=1 AND buy_sell=2);


SELECT SUM(seller_stamp),SUM(handling_fee),SUM(securities_management_fee),SUM(transfer_fee),SUM(others)
INTO           v_note_17,        v_note_18,                     v_note_19,        v_note_20,  v_note_21
FROM tmp_rpt WHERE NOT (account_type=1 AND buy_sell=2);
REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, voucher_value, update_time)VALUES
(i_process_date, 'note_17', 'Stamp Duty - China A (Seller)', v_note_17, NOW()),
(i_process_date, 'note_18', 'Handling fee - China A - RMB' , v_note_18, NOW()),
(i_process_date, 'note_19', 'Sec Mgt fee - China A - RMB'  , v_note_19, NOW()),
(i_process_date, 'note_20', 'Transfer fee - China A - RMB' , v_note_20, NOW()),
(i_process_date, 'note_21', 'Partform fee - China A - RMB' , v_note_21, NOW());

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, voucher_value, update_time)
SELECT i_process_date, 'note_14', 'Cash Rece-SEHK-China A-RMB', (3-buy_sell*2)+client_receivable_payable_hkd, NOW() FROM tmp_rpt WHERE account_type=1;
REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, voucher_value, update_time)
SELECT i_process_date, 'note_15', 'MarginRec-SEHK-China A-RMB', (3-buy_sell*2)+client_receivable_payable_hkd, NOW() FROM tmp_rpt WHERE account_type=2;

drop temporary table IF EXISTS tmp_rpt_2;
CREATE TEMPORARY TABLE tmp_rpt_2 SELECT * FROM tmp_rpt WHERE 1=2;
INSERT INTO tmp_rpt_2(process_date,                                   memo,account_type,buy_sell,currency,    broker_payable_receivable,     commission_income,     ae_commission,     net_income,     seller_stamp,     handling_fee,     securities_management_fee,     transfer_fee,     others,     client_receivable_payable,     broker_payable_receivable_hkd,     commission_income_hkd,     ae_commission_hkd,     net_income_hkd,     seller_stamp_hkd,     handling_fee_hkd,     securities_management_fee_hkd,     transfer_fee_hkd,     others_hkd,     client_receivable_payable_hkd)
             SELECT i_process_date,IF(buy_sell=1,'total_buy','total_sell'),        NULL,buy_sell,       1,SUM(broker_payable_receivable),SUM(commission_income),SUM(ae_commission),SUM(net_income),SUM(seller_stamp),SUM(handling_fee),SUM(securities_management_fee),SUM(transfer_fee),SUM(others),SUM(client_receivable_payable),SUM(broker_payable_receivable_hkd),SUM(commission_income_hkd),SUM(ae_commission_hkd),SUM(net_income_hkd),SUM(seller_stamp_hkd),SUM(handling_fee_hkd),SUM(securities_management_fee_hkd),SUM(transfer_fee_hkd),SUM(others_hkd),SUM(client_receivable_payable_hkd) FROM tmp_rpt GROUP BY buy_sell;
INSERT INTO tmp_rpt_2(process_date,                                   memo,account_type,buy_sell,currency,    broker_payable_receivable,     commission_income,     ae_commission,     net_income,     seller_stamp,     handling_fee,     securities_management_fee,     transfer_fee,     others,     client_receivable_payable,     broker_payable_receivable_hkd,     commission_income_hkd,     ae_commission_hkd,     net_income_hkd,     seller_stamp_hkd,     handling_fee_hkd,     securities_management_fee_hkd,     transfer_fee_hkd,     others_hkd,     client_receivable_payable_hkd)
             SELECT i_process_date,                       'net_buy_sell',        NULL,    NULL,       1,SUM(broker_payable_receivable),SUM(commission_income),SUM(ae_commission),SUM(net_income),SUM(seller_stamp),SUM(handling_fee),SUM(securities_management_fee),SUM(transfer_fee),SUM(others),SUM(client_receivable_payable),SUM(broker_payable_receivable_hkd),SUM(commission_income_hkd),SUM(ae_commission_hkd),SUM(net_income_hkd),SUM(seller_stamp_hkd),SUM(handling_fee_hkd),SUM(securities_management_fee_hkd),SUM(transfer_fee_hkd),SUM(others_hkd),SUM(client_receivable_payable_hkd) FROM tmp_rpt;
INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_2;
delete from tmp_rpt_2;
INSERT INTO tmp_rpt_2(  process_date,            memo,account_type,currency)
               VALUES(i_process_date,  'summary_cash',           1,       1),
                     (i_process_date,'summary_margin',           2,       1);
UPDATE tmp_rpt_2 t2
left join tmp_rpt t on t2.account_type=t.account_type and t.buy_sell=1
SET t2.summary_receivable = ifnull(t.client_receivable_payable,0);

UPDATE tmp_rpt_2 t2
left join tmp_rpt t on t2.account_type=t.account_type AND t.buy_sell=2
SET t2.summary_payable=ifnull(t.client_receivable_payable,0);

drop temporary table IF EXISTS tmp_rpt_3;
CREATE TEMPORARY TABLE tmp_rpt_3 SELECT * FROM tmp_rpt WHERE 1=2;
INSERT INTO tmp_rpt_3(  process_date,           memo,account_type,currency,     summary_receivable,     summary_payable)
               SELECT i_process_date,'summary_total',          -1,       1, SUM(summary_receivable),SUM(summary_payable) FROM tmp_rpt_2;
INSERT INTO tmp_rpt_2 SELECT * FROM tmp_rpt_3;
delete from tmp_rpt_3;
INSERT INTO tmp_rpt_3(process_date,memo,account_type,buy_sell,currency,summary_receivable,summary_payable,summary_total,summary_net_total)
SELECT i_process_date,'summary_total_hkd',-2,NULL,2,
    ROUND(IFNULL(ch.exchange_rate,c.exchange_rate)*t2.summary_receivable,2),
    ROUND(IFNULL(ch.exchange_rate,c.exchange_rate)*t2.summary_payable,2),
    ROUND(IFNULL(ch.exchange_rate,c.exchange_rate)*t2.summary_total,2),
    ROUND(IFNULL(ch.exchange_rate,c.exchange_rate)*t2.summary_net_total,2)
    FROM tmp_rpt_2 t2 LEFT JOIN currency c ON t2.currency= c.currency
    LEFT JOIN currency_history ch ON ch.process_date=i_process_date AND t2.currency=ch.currency
    WHERE t2.memo='summary_total';
INSERT INTO tmp_rpt_2 SELECT * FROM tmp_rpt_3;
drop temporary table IF EXISTS tmp_rpt_3;

UPDATE tmp_rpt_2 SET summary_total=summary_receivable+summary_payable, summary_net_total=summary_payable-summary_receivable;
INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_2;

    select *from tmp_rpt;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportAuditTrailListing
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportAuditTrailListing`;
delimiter ;;
CREATE PROCEDURE `proExportAuditTrailListing`(IN i_process_date DATE)
label:BEGIN

SELECT table_id,table_key_value,`action`,`column_name`,old_value,new_value,update_user,update_time FROM audit_trail 
WHERE process_date=i_process_date;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportBalanceAll
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportBalanceAll`;
delimiter ;;
CREATE PROCEDURE `proExportBalanceAll`(IN i_process_date DATE,
    IN i_account_type INT)
label:BEGIN
    DECLARE v_date_cn_t1 DATE;
    DECLARE v_date_hk_t1 DATE;
    DECLARE v_date_us_t1 DATE;
    DECLARE v_process_date DATE;

    SELECT buss_date INTO v_process_date FROM sys_info;

    IF i_process_date IS NULL THEN
        SELECT buss_date INTO i_process_date FROM sys_info;
    END IF;

    SELECT funIntervalSettleDay(4,i_process_date,1) INTO v_date_cn_t1;
    SELECT funIntervalSettleDay(1,i_process_date,1) INTO v_date_hk_t1;
    SELECT funIntervalSettleDay(2,i_process_date,1) INTO v_date_us_t1;

    -- 固定汇率
    set @rate_cny = 1.19;
    set @rate_usd = 7.75;

    drop temporary table IF EXISTS tmp_rpt;
    CREATE TEMPORARY TABLE tmp_rpt
    (
        process_date     DATE,
        account_id       VARCHAR(32),
        account_name     VARCHAR(256),
        account_type     varchar(16),
        t0_hkd           DECIMAL(30,10) DEFAULT 0,
        t0_cny           DECIMAL(30,10) DEFAULT 0,
        t0_usd           DECIMAL(30,10) DEFAULT 0,
        t0_total         DECIMAL(30,10) DEFAULT 0,
        t1_hkd           DECIMAL(30,10) DEFAULT 0,
        t1_cny           DECIMAL(30,10) DEFAULT 0,
        t1_usd           DECIMAL(30,10) DEFAULT 0,
        t1_total         DECIMAL(30,10) DEFAULT 0,
        t2_hkd           DECIMAL(30,10) DEFAULT 0,
        t2_cny           DECIMAL(30,10) DEFAULT 0,
        t2_usd           DECIMAL(30,10) DEFAULT 0,
        t2_total         DECIMAL(30,10) DEFAULT 0,
        INDEX idx1(process_date,account_id,account_type),
        index idx2(account_type),
        index idx3(account_id)
    );
    drop temporary table IF EXISTS tmp_rpt_set;
    CREATE TEMPORARY TABLE tmp_rpt_set SELECT * FROM tmp_rpt WHERE 1=2; -- 集合.

    create INDEX idx1 on tmp_rpt_set(process_date,account_id,account_type);
    create INDEX idx2 on tmp_rpt_set(account_type);

    drop temporary table IF EXISTS tmp_rpt_sum;
    CREATE TEMPORARY TABLE tmp_rpt_sum select * from tmp_rpt where 1=2;

    INSERT INTO tmp_rpt_set(process_date,account_id,account_name,account_type) 
    SELECT  
        a.process_date,a.account_id,replace(b.short_name,',',' '),a.account_type
    FROM account_balance a 
    inner join account_profile b on a.account_id = b.account_id
    where i_process_date=a.process_date group by a.account_id;

    -- CNY.
    drop temporary table if exists tmp1; 
    create temporary table tmp1 
    SELECT account_id, SUM(IF(purpose=1,amount,0)-IF(purpose=2,amount,0))AS amt 
    FROM cash_flow_cit 
    WHERE process_date<=i_process_date AND currency=1 
    GROUP BY account_id; 

    create index idx1 on tmp1(account_id);
    INSERT INTO tmp_rpt(  process_date,   account_id, account_name,   account_type,      t0_cny,t1_cny,t2_cny)
    SELECT a.process_date, a.account_id, replace(b.short_name,',',' '), a.account_type,a.settle_balance,a.settle_balance,a.trade_balance-IFNULL(c.amt,0)
    FROM account_balance a 
    LEFT JOIN account_profile b ON a.account_id=b.account_id
    LEFT JOIN tmp1 c ON a.account_id=c.account_id 
    WHERE i_process_date=a.process_date AND 
        a.account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND 
        a.currency=1;

    drop temporary table if exists tmp3;
    create temporary table tmp3 
    SELECT account_id, SUM(IF(buy_sell = 1, -1, 1) * net_amount) AS net_amount 
    FROM account_trade 
    WHERE if(v_process_date = i_process_date, 
                (settle_date>=i_process_date AND settle_date<=v_date_cn_t1),
                settle_date=v_date_cn_t1) AND 
        account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND 
        clearing_currency=1 and status = 'Confirmed' 
    GROUP BY account_id;
    create index idx3 on tmp3(account_id);

    UPDATE tmp_rpt a
    inner join tmp3 b on a.account_id = b.account_id 
    SET a.t1_cny = a.t1_cny + ifnull(b.net_amount,0);

    update tmp_rpt_set a 
    inner join tmp_rpt b on a.process_date = b.process_date and a.account_id = b.account_id and a.account_type = b.account_type
    set a.t0_cny = b.t0_cny,
        a.t1_cny = b.t1_cny,
        a.t2_cny = b.t2_cny;
    -- cny end

    -- HKD.
    drop temporary table if exists tmp1; 
    create temporary table tmp1 
    SELECT account_id, SUM(IF(purpose=1,amount,0)-IF(purpose=2,amount,0))AS amt 
    FROM cash_flow_cit 
    WHERE process_date<=i_process_date AND currency=2 GROUP BY account_id;
    create index idx on tmp1(account_id);

    delete from tmp_rpt;
    INSERT INTO tmp_rpt(  process_date,   account_id, account_name,   account_type,      t0_hkd,t1_hkd,    t2_hkd)
    SELECT a.process_date, a.account_id, replace(b.short_name,',',' '), a.account_type,a.settle_balance,a.settle_balance,a.trade_balance-IFNULL(c.amt,0)
    FROM account_balance a LEFT JOIN account_profile b ON a.account_id=b.account_id 
    LEFT JOIN tmp1 c ON a.account_id=c.account_id
    WHERE i_process_date=a.process_date AND 
        a.account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND 
        a.currency=2;

    drop temporary table if exists tmp; 
    create temporary table tmp 
    SELECT account_id, SUM(IF(buy_sell = 1, -1, 1) * net_amount) AS net_amount 
    FROM account_trade 
    WHERE if(v_process_date = i_process_date,
            (settle_date >= i_process_date AND settle_date <= v_date_hk_t1),
            settle_date = v_date_hk_t1) AND 
        account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND 
        clearing_currency=2 and status = 'Confirmed' GROUP BY account_id;
    create index idx on tmp(account_id);

    UPDATE tmp_rpt a
    inner join tmp b  on a.account_id=b.account_id
    SET a.t1_hkd= a.t1_hkd + b.net_amount;

    update tmp_rpt_set a 
    inner join tmp_rpt b on a.process_date = b.process_date and a.account_id = b.account_id and a.account_type = b.account_type
    set a.t0_hkd = b.t0_hkd,
        a.t1_hkd = b.t1_hkd,
        a.t2_hkd = b.t2_hkd;
    
    -- hkd end

    -- USD.
    drop temporary table if exists tmp1; 
    create temporary table tmp1 
    SELECT account_id, SUM(IF(purpose=1,amount,0)-IF(purpose=2,amount,0))AS amt 
    FROM cash_flow_cit 
    WHERE process_date <= i_process_date AND currency = 4 
    GROUP BY account_id;
    create index idx on tmp1(account_id);

    delete from tmp_rpt;
    INSERT INTO tmp_rpt(  process_date,   account_id, account_name,   account_type,      t0_usd,t1_usd,    t2_usd)
    SELECT a.process_date, a.account_id, replace(b.short_name,',',' '), a.account_type,a.settle_balance,a.settle_balance,a.trade_balance-IFNULL(c.amt,0)
    FROM account_balance a LEFT JOIN account_profile b ON a.account_id=b.account_id 
    LEFT JOIN tmp1 c ON a.account_id=c.account_id 
    WHERE i_process_date=a.process_date AND 
        a.account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND 
        a.currency=4;

    drop temporary table if exists tmp; 
    create temporary table tmp 
    SELECT account_id, SUM(IF(buy_sell = 1, -1, 1) * net_amount) AS net_amount 
    FROM account_trade 
    WHERE if(v_process_date = i_process_date,
            (settle_date>=i_process_date AND settle_date<=v_date_us_t1),
            settle_date = v_date_us_t1) AND 
            account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND 
            clearing_currency=4 and status = 'Confirmed' 
    GROUP BY account_id;

    create index idx on tmp(account_id);

    UPDATE tmp_rpt a
    inner join tmp b on a.account_id = b.account_id
    SET a.t1_usd=a.t1_usd + b.net_amount;

    update tmp_rpt_set a 
    inner join tmp_rpt b on a.process_date = b.process_date and a.account_id = b.account_id and a.account_type = b.account_type
    set a.t0_usd = b.t0_usd,
        a.t1_usd = b.t1_usd,
        a.t2_usd = b.t2_usd;

    -- usd end
    
    -- 汇总
    update tmp_rpt_set
    set t0_total = round((t0_cny * @rate_cny),2) + t0_hkd + round((t0_usd * @rate_usd),2),
        t1_total = round((t1_cny * @rate_cny),2) + t1_hkd + round((t1_usd * @rate_usd),2),
        t2_total = round((t2_cny * @rate_cny),2) + t2_hkd + round((t2_usd * @rate_usd),2);

    -- total summery
    insert into tmp_rpt_sum(account_name,account_type,t0_hkd,t0_cny,t0_usd,t0_total,t1_hkd,t1_cny,t1_usd,t1_total,t2_hkd,t2_cny,t2_usd,t2_total)
    select 
        'Total',
        'Credit',
        sum(if(a.t0_hkd > 0,a.t0_hkd,0)) as t0_hkd,
        sum(if(a.t0_cny > 0,a.t0_cny,0)) as t0_cny,
        sum(if(a.t0_usd > 0,a.t0_usd,0)) as t0_usd,
        sum(if(a.t0_total > 0,a.t0_total,0)) as t0_total,
        sum(if(a.t1_hkd > 0,a.t1_hkd,0)) as t1_hkd,
        sum(if(a.t1_cny > 0,a.t1_cny,0)) as t1_cny,
        sum(if(a.t1_usd > 0,a.t1_usd,0)) as t1_usd,
        sum(if(a.t1_total > 0,a.t1_total,0)) as t1_total,
        sum(if(a.t2_hkd > 0,a.t2_hkd,0)) as t2_hkd,
        sum(if(a.t2_cny > 0,a.t2_cny,0)) as t2_cny,
        sum(if(a.t2_usd > 0,a.t2_usd,0)) as t2_usd,
        sum(if(a.t2_total > 0,a.t2_total,0)) as t2_total
    from tmp_rpt_set a;

    insert into tmp_rpt_sum(account_type,t0_hkd,t0_cny,t0_usd,t0_total,t1_hkd,t1_cny,t1_usd,t1_total,t2_hkd,t2_cny,t2_usd,t2_total)
    select 
        'Debit',
        sum(if(a.t0_hkd < 0,a.t0_hkd,0)) as t0_hkd,
        sum(if(a.t0_cny < 0,a.t0_cny,0)) as t0_cny,
        sum(if(a.t0_usd < 0,a.t0_usd,0)) as t0_usd,
        sum(if(a.t0_total < 0,a.t0_total,0)) as t0_total,
        sum(if(a.t1_hkd < 0,a.t1_hkd,0)) as t1_hkd,
        sum(if(a.t1_cny < 0,a.t1_cny,0)) as t1_cny,
        sum(if(a.t1_usd < 0,a.t1_usd,0)) as t1_usd,
        sum(if(a.t1_total < 0,a.t1_total,0)) as t1_total,
        sum(if(a.t2_hkd < 0,a.t2_hkd,0)) as t2_hkd,
        sum(if(a.t2_cny < 0,a.t2_cny,0)) as t2_cny,
        sum(if(a.t2_usd < 0,a.t2_usd,0)) as t2_usd,
        sum(if(a.t2_total < 0,a.t2_total,0)) as t2_total
    from tmp_rpt_set a;

    insert into tmp_rpt_sum(account_type,t0_hkd,t0_cny,t0_usd,t0_total,t1_hkd,t1_cny,t1_usd,t1_total,t2_hkd,t2_cny,t2_usd,t2_total)
    select 
        'Total',
        sum(a.t0_hkd) as t0_hkd,
        sum(a.t0_cny) as t0_cny,
        sum(a.t0_usd) as t0_usd,
        sum(a.t0_total) as t0_total,
        sum(a.t1_hkd) as t1_hkd,
        sum(a.t1_cny) as t1_cny,
        sum(a.t1_usd) as t1_usd,
        sum(a.t1_total) as t1_total,
        sum(a.t2_hkd) as t2_hkd,
        sum(a.t2_cny) as t2_cny,
        sum(a.t2_usd) as t2_usd,
        sum(a.t2_total) as t2_total
    from tmp_rpt_set a;

    -- total summery end

    -- house summery
    insert into tmp_rpt_sum(account_name,account_type,t0_hkd,t0_cny,t0_usd,t0_total,t1_hkd,t1_cny,t1_usd,t1_total,t2_hkd,t2_cny,t2_usd,t2_total)
    select 
        'House',
        'Credit',
        sum(if(a.t0_hkd > 0,a.t0_hkd,0)) as t0_hkd,
        sum(if(a.t0_cny > 0,a.t0_cny,0)) as t0_cny,
        sum(if(a.t0_usd > 0,a.t0_usd,0)) as t0_usd,
        sum(if(a.t0_total > 0,a.t0_total,0)) as t0_total,
        sum(if(a.t1_hkd > 0,a.t1_hkd,0)) as t1_hkd,
        sum(if(a.t1_cny > 0,a.t1_cny,0)) as t1_cny,
        sum(if(a.t1_usd > 0,a.t1_usd,0)) as t1_usd,
        sum(if(a.t1_total > 0,a.t1_total,0)) as t1_total,
        sum(if(a.t2_hkd > 0,a.t2_hkd,0)) as t2_hkd,
        sum(if(a.t2_cny > 0,a.t2_cny,0)) as t2_cny,
        sum(if(a.t2_usd > 0,a.t2_usd,0)) as t2_usd,
        sum(if(a.t2_total > 0,a.t2_total,0)) as t2_total
    from tmp_rpt_set a where a.account_type = 0;

    insert into tmp_rpt_sum(account_type,t0_hkd,t0_cny,t0_usd,t0_total,t1_hkd,t1_cny,t1_usd,t1_total,t2_hkd,t2_cny,t2_usd,t2_total)
    select 
        'Debit',
        sum(if(a.t0_hkd < 0,a.t0_hkd,0)) as t0_hkd,
        sum(if(a.t0_cny < 0,a.t0_cny,0)) as t0_cny,
        sum(if(a.t0_usd < 0,a.t0_usd,0)) as t0_usd,
        sum(if(a.t0_total < 0,a.t0_total,0)) as t0_total,
        sum(if(a.t1_hkd < 0,a.t1_hkd,0)) as t1_hkd,
        sum(if(a.t1_cny < 0,a.t1_cny,0)) as t1_cny,
        sum(if(a.t1_usd < 0,a.t1_usd,0)) as t1_usd,
        sum(if(a.t1_total < 0,a.t1_total,0)) as t1_total,
        sum(if(a.t2_hkd < 0,a.t2_hkd,0)) as t2_hkd,
        sum(if(a.t2_cny < 0,a.t2_cny,0)) as t2_cny,
        sum(if(a.t2_usd < 0,a.t2_usd,0)) as t2_usd,
        sum(if(a.t2_total < 0,a.t2_total,0)) as t2_total
    from tmp_rpt_set a where a.account_type = 0;

    insert into tmp_rpt_sum(account_type,t0_hkd,t0_cny,t0_usd,t0_total,t1_hkd,t1_cny,t1_usd,t1_total,t2_hkd,t2_cny,t2_usd,t2_total)
    select 
        'Total',
        sum(a.t0_hkd) as t0_hkd,
        sum(a.t0_cny) as t0_cny,
        sum(a.t0_usd) as t0_usd,
        sum(a.t0_total) as t0_total,
        sum(a.t1_hkd) as t1_hkd,
        sum(a.t1_cny) as t1_cny,
        sum(a.t1_usd) as t1_usd,
        sum(a.t1_total) as t1_total,
        sum(a.t2_hkd) as t2_hkd,
        sum(a.t2_cny) as t2_cny,
        sum(a.t2_usd) as t2_usd,
        sum(a.t2_total) as t2_total
    from tmp_rpt_set a where a.account_type = 0;

    -- house summery end

    -- cash summery
    insert into tmp_rpt_sum(account_name,account_type,t0_hkd,t0_cny,t0_usd,t0_total,t1_hkd,t1_cny,t1_usd,t1_total,t2_hkd,t2_cny,t2_usd,t2_total)
    select 
        'Cash',
        'Credit',
        sum(if(a.t0_hkd > 0,a.t0_hkd,0)) as t0_hkd,
        sum(if(a.t0_cny > 0,a.t0_cny,0)) as t0_cny,
        sum(if(a.t0_usd > 0,a.t0_usd,0)) as t0_usd,
        sum(if(a.t0_total > 0,a.t0_total,0)) as t0_total,
        sum(if(a.t1_hkd > 0,a.t1_hkd,0)) as t1_hkd,
        sum(if(a.t1_cny > 0,a.t1_cny,0)) as t1_cny,
        sum(if(a.t1_usd > 0,a.t1_usd,0)) as t1_usd,
        sum(if(a.t1_total > 0,a.t1_total,0)) as t1_total,
        sum(if(a.t2_hkd > 0,a.t2_hkd,0)) as t2_hkd,
        sum(if(a.t2_cny > 0,a.t2_cny,0)) as t2_cny,
        sum(if(a.t2_usd > 0,a.t2_usd,0)) as t2_usd,
        sum(if(a.t2_total > 0,a.t2_total,0)) as t2_total
    from tmp_rpt_set a where a.account_type = 1;

    insert into tmp_rpt_sum(account_type,t0_hkd,t0_cny,t0_usd,t0_total,t1_hkd,t1_cny,t1_usd,t1_total,t2_hkd,t2_cny,t2_usd,t2_total)
    select 
        'Debit',
        sum(if(a.t0_hkd < 0,a.t0_hkd,0)) as t0_hkd,
        sum(if(a.t0_cny < 0,a.t0_cny,0)) as t0_cny,
        sum(if(a.t0_usd < 0,a.t0_usd,0)) as t0_usd,
        sum(if(a.t0_total < 0,a.t0_total,0)) as t0_total,
        sum(if(a.t1_hkd < 0,a.t1_hkd,0)) as t1_hkd,
        sum(if(a.t1_cny < 0,a.t1_cny,0)) as t1_cny,
        sum(if(a.t1_usd < 0,a.t1_usd,0)) as t1_usd,
        sum(if(a.t1_total < 0,a.t1_total,0)) as t1_total,
        sum(if(a.t2_hkd < 0,a.t2_hkd,0)) as t2_hkd,
        sum(if(a.t2_cny < 0,a.t2_cny,0)) as t2_cny,
        sum(if(a.t2_usd < 0,a.t2_usd,0)) as t2_usd,
        sum(if(a.t2_total < 0,a.t2_total,0)) as t2_total
    from tmp_rpt_set a where a.account_type = 1;

    insert into tmp_rpt_sum(account_type,t0_hkd,t0_cny,t0_usd,t0_total,t1_hkd,t1_cny,t1_usd,t1_total,t2_hkd,t2_cny,t2_usd,t2_total)
    select 
        'Total',
        sum(a.t0_hkd) as t0_hkd,
        sum(a.t0_cny) as t0_cny,
        sum(a.t0_usd) as t0_usd,
        sum(a.t0_total) as t0_total,
        sum(a.t1_hkd) as t1_hkd,
        sum(a.t1_cny) as t1_cny,
        sum(a.t1_usd) as t1_usd,
        sum(a.t1_total) as t1_total,
        sum(a.t2_hkd) as t2_hkd,
        sum(a.t2_cny) as t2_cny,
        sum(a.t2_usd) as t2_usd,
        sum(a.t2_total) as t2_total
    from tmp_rpt_set a where a.account_type = 1;

    -- cash summery end

    -- margin summery
    insert into tmp_rpt_sum(account_name,account_type,t0_hkd,t0_cny,t0_usd,t0_total,t1_hkd,t1_cny,t1_usd,t1_total,t2_hkd,t2_cny,t2_usd,t2_total)
    select 
        'Margin',
        'Credit',
        sum(if(a.t0_hkd > 0,a.t0_hkd,0)) as t0_hkd,
        sum(if(a.t0_cny > 0,a.t0_cny,0)) as t0_cny,
        sum(if(a.t0_usd > 0,a.t0_usd,0)) as t0_usd,
        sum(if(a.t0_total > 0,a.t0_total,0)) as t0_total,
        sum(if(a.t1_hkd > 0,a.t1_hkd,0)) as t1_hkd,
        sum(if(a.t1_cny > 0,a.t1_cny,0)) as t1_cny,
        sum(if(a.t1_usd > 0,a.t1_usd,0)) as t1_usd,
        sum(if(a.t1_total > 0,a.t1_total,0)) as t1_total,
        sum(if(a.t2_hkd > 0,a.t2_hkd,0)) as t2_hkd,
        sum(if(a.t2_cny > 0,a.t2_cny,0)) as t2_cny,
        sum(if(a.t2_usd > 0,a.t2_usd,0)) as t2_usd,
        sum(if(a.t2_total > 0,a.t2_total,0)) as t2_total
    from tmp_rpt_set a where a.account_type = 2;

    insert into tmp_rpt_sum(account_type,t0_hkd,t0_cny,t0_usd,t0_total,t1_hkd,t1_cny,t1_usd,t1_total,t2_hkd,t2_cny,t2_usd,t2_total)
    select 
        'Debit',
        sum(if(a.t0_hkd < 0,a.t0_hkd,0)) as t0_hkd,
        sum(if(a.t0_cny < 0,a.t0_cny,0)) as t0_cny,
        sum(if(a.t0_usd < 0,a.t0_usd,0)) as t0_usd,
        sum(if(a.t0_total < 0,a.t0_total,0)) as t0_total,
        sum(if(a.t1_hkd < 0,a.t1_hkd,0)) as t1_hkd,
        sum(if(a.t1_cny < 0,a.t1_cny,0)) as t1_cny,
        sum(if(a.t1_usd < 0,a.t1_usd,0)) as t1_usd,
        sum(if(a.t1_total < 0,a.t1_total,0)) as t1_total,
        sum(if(a.t2_hkd < 0,a.t2_hkd,0)) as t2_hkd,
        sum(if(a.t2_cny < 0,a.t2_cny,0)) as t2_cny,
        sum(if(a.t2_usd < 0,a.t2_usd,0)) as t2_usd,
        sum(if(a.t2_total < 0,a.t2_total,0)) as t2_total
    from tmp_rpt_set a where a.account_type = 2;

    insert into tmp_rpt_sum(account_type,t0_hkd,t0_cny,t0_usd,t0_total,t1_hkd,t1_cny,t1_usd,t1_total,t2_hkd,t2_cny,t2_usd,t2_total)
    select 
        'Total',
        sum(a.t0_hkd) as t0_hkd,
        sum(a.t0_cny) as t0_cny,
        sum(a.t0_usd) as t0_usd,
        sum(a.t0_total) as t0_total,
        sum(a.t1_hkd) as t1_hkd,
        sum(a.t1_cny) as t1_cny,
        sum(a.t1_usd) as t1_usd,
        sum(a.t1_total) as t1_total,
        sum(a.t2_hkd) as t2_hkd,
        sum(a.t2_cny) as t2_cny,
        sum(a.t2_usd) as t2_usd,
        sum(a.t2_total) as t2_total
    from tmp_rpt_set a where a.account_type = 2;

    -- margin summery end 

    insert into tmp_rpt_set select * from tmp_rpt_sum;

    SELECT * FROM tmp_rpt_set;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportCashClientUnsettledBalanceAgingReport
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportCashClientUnsettledBalanceAgingReport`;
delimiter ;;
CREATE PROCEDURE `proExportCashClientUnsettledBalanceAgingReport`(in i_process_date date)
label:begin

    declare v_last_day date; 
    declare v_first_day date; 
    declare v_last_day1 date; 
    declare v_first_day1 date; 
    declare v_5t date; 
    declare v_1m date; 
    declare v_currency varchar(1);
    
    declare v_done int; 

    DECLARE cur_balance CURSOR FOR
    SELECT
      currency
    FROM
      account_balance a
    where a.process_date = i_process_date group by currency; 
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1; 
    
    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    
    select DATE_ADD(i_process_date,interval -day(i_process_date)+1 day) into v_first_day; 
    select last_day(i_process_date) into v_last_day;

    
    select date_sub(date_sub(date_format(i_process_date,'%y-%m-%d'),interval extract(day from i_process_date)-1 day),interval 1 month) into v_first_day1;
    select date_sub(date_sub(date_format(i_process_date,'%y-%m-%d'),interval extract(day from i_process_date) day),interval 0 month) into v_last_day1;

    
    select max(calendar_day) into v_5t from calendar where market_id = 2 and calendar_day<DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 5 DAY),'%Y%m%d') and holiday <> 'Y'; 

    
    select max(calendar_day) into v_1m from calendar where market_id = 2 and calendar_day<DATE_FORMAT(DATE_SUB(v_last_day1,INTERVAL 0 DAY),'%Y%m%d') and holiday <> 'Y'; 

    drop temporary table if exists tmp_aging_report; 
    create temporary table tmp_aging_report
    ( 
        account_id varchar(32),
        short_name VARCHAR(16),
        account_type varchar(32), 
        currency varchar(32), 
        debit_balance varchar(32), 
        `0d-5d` varchar(32),
        `6d-1M` varchar(32), 
        `>1M` varchar(32), 
        `Total` varchar(32),
        `MV` varchar(32), 
        `MV_Haircut` varchar(32), 
        index idx1(account_id,currency)
    ); 
    
    drop temporary table if exists tmp_haircut; 
    create temporary table tmp_haircut
    ( 
        account_id varchar(32),
        currency varchar(32), 
        `MV` varchar(32), 
        `MV_Haircut` varchar(32), 
        index idx1(account_id,currency)
    ); 

    insert into tmp_haircut
    select 
	`a`.`account_id` AS `account_id`,
	case `a`.`currency` when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end AS `currency`,
	sum(round((`a`.`quantity` * a.closing_price),6) * round(ifnull(`jcbms`.`currency_history`.`exchange_rate`,`jcbms`.`currency`.`exchange_rate`),6)) AS `market_value`,
	sum(((round((`a`.`net_quantity` * a.closing_price),6) * round(ifnull(`jcbms`.`currency_history`.`exchange_rate`,`jcbms`.`currency`.`exchange_rate`),6)) * 
			(1 - ifnull(`haircut`.`haircut_percent`,1)))) AS `market_value_after_haircut`
    from 
    (
        (	
        (
            (
            `jcbms`.`account_position` `a` 
                left join `jcbms`.`v_product_haircut_percent` `haircut` on(((`a`.`market_id` = `haircut`.`list_market_id`) and (`a`.`product_id` = `haircut`.`product_id`)))
            ) 
            left join `jcbms`.`currency` on((`a`.`currency` = `jcbms`.`currency`.`currency`))
        ) 
        left join `jcbms`.`currency_history` on(((`a`.`process_date` = `jcbms`.`currency_history`.`process_date`) and (`a`.`currency` = `jcbms`.`currency_history`.`currency`)))
        ) join `jcbms`.`product` on((`jcbms`.`product`.`product_id` = `a`.`product_id`))
    )
    where a.process_date= i_process_date 
    group by a.account_id,a.currency
    order by a.account_id,a.currency;

    insert into tmp_aging_report
    select 'Custodian a/c','','Type','','Debit Balance','0d-5d','6d-1M','> 1M','Total','Market Value','Market Value After HairCut';

    open cur_balance; 
    set v_done = 0; 
    fetch cur_balance into v_currency; 
    while v_done <> 1 do 

            drop temporary table if exists tmp_table; 
            create temporary table tmp_table
            ( 
                account_id varchar(32),
                short_name VARCHAR(16),
                account_type varchar(32), 
                currency varchar(32), 
                debit_balance DECIMAL(30,10), 
                d0_5 DECIMAL(30,10),
                d6_1M DECIMAL(30,10), 
                MV DECIMAL(30,10),
                MV_Haircut DECIMAL(30,10),
                index idx1(account_id,currency)
            ); 

        insert into tmp_table
        select a.account_id,replace(c.short_name,',',' '),
            'C',
            case a.currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end,
            a.settle_balance,
            if((a.settle_balance - if(ifnull(b.settle_balance,0) > 0,0, ifnull(b.settle_balance,0)) - ifnull(d.credit_interest,0)) > 0,
                a.settle_balance,
                (a.settle_balance - if(ifnull(b.settle_balance,0) > 0,0, ifnull(b.settle_balance,0)))) as '0d-5d' ,
            if((if(ifnull(b.settle_balance,0)>0,0,ifnull(b.settle_balance,0)) - if(ifnull(f.settle_balance,0)>0,0,ifnull(f.settle_balance,0))) > 0,
                if(ifnull(b.settle_balance,0)>0,0,ifnull(b.settle_balance,0)),
                (if(ifnull(b.settle_balance,0)>0,0,ifnull(b.settle_balance,0)) - if(ifnull(f.settle_balance,0)>0,0,ifnull(f.settle_balance,0))) - ifnull(e.credit_interest,0) ) as '6d-1M',
            0.00,0.00
        from account_balance a 	
        left join(
        select account_id,currency,settle_balance from account_balance where process_date = v_5t
        ) b on a.account_id = b.account_id and a.currency = b.currency
        inner join account_profile c on c.account_id = a.account_id
        left join (
            select account_id,currency,sum(debit_interest) as debit_interest,sum(credit_interest) as credit_interest from account_interest where process_date >= v_first_day and process_date <= v_last_day group by account_id,currency
        ) d on d.account_id = a.account_id and d.currency = a.currency
        left join (
            select account_id,currency,sum(debit_interest) as debit_interest,sum(credit_interest) as credit_interest from account_interest where process_date >= v_first_day1 and process_date <= v_last_day1 group by account_id,currency
        ) e on e.account_id = a.account_id and e.currency = a.currency
        left join(
        select account_id,currency,settle_balance from account_balance where process_date = v_1m
        ) f on a.account_id = f.account_id and a.currency = f.currency
        where a.process_date = i_process_date and a.settle_balance < 0 and a.account_type = 1 and a.currency = v_currency order by a.currency,a.account_id;

        if EXISTS(select 1 from tmp_table) then
            
            update tmp_table a
            left join tmp_haircut b on b.account_id = a.account_id and b.currency = a.currency
            set a.MV = b.MV,
                a.MV_Haircut = b.MV_Haircut;

            insert into tmp_aging_report
            select 
                account_id,
                short_name,
                account_type,
                currency,
                round(debit_balance,2),
                round(d0_5,2),
                round(d6_1M,2),
                round(debit_balance - d0_5 - d6_1M,2),
                round(debit_balance,2),
                round(MV,2),
                round(MV_Haircut,2)
            from tmp_table;

            insert into tmp_aging_report
            select '','','',
                currency,
                round(sum(debit_balance),2),
                round(sum(d0_5),2),
                round(sum(d6_1M),2),
                round(sum(debit_balance - d0_5 - d6_1M),2),
                round(sum(debit_balance),2),
                '',
                ''
            from tmp_table;
        end if;

        set v_done = 0; 
        fetch cur_balance into v_currency; 
    end while; 
    close cur_balance; 

    select * from tmp_aging_report a;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientFundAndProductBalance
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientFundAndProductBalance`;
delimiter ;;
CREATE PROCEDURE `proExportClientFundAndProductBalance`(IN i_process_date DATE)
label:BEGIN
 
    declare v_done int; 
    DECLARE v_currency varchar(16);
    DECLARE v_ccy varchar(16);

    DECLARE cur_balance CURSOR FOR 
    select currency
    from account_balance 
    where process_date = i_process_date
    group by currency;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1; 
    
    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    drop temporary table IF EXISTS tmp_export;
    CREATE TEMPORARY TABLE tmp_export 
    (
        `Client_AC` VARCHAR(16) NULL DEFAULT NULL,
        `Client_Name` VARCHAR(128) NULL DEFAULT NULL,
        `Type` VARCHAR(32) NULL DEFAULT NULL,
        `AE` varchar(32) NULL DEFAULT NULL,
        `Cash_bal` varchar(32) NULL DEFAULT NULL,
        `Product_MV` CHAR(128) NULL DEFAULT NULL,
        `Total_bal` varchar(32) NULL DEFAULT NULL,
        `Loan_limit` VARCHAR(32) NULL DEFAULT NULL
    );

    insert into tmp_export
        select
            'Client A/C',
            'Client Name',
            'Account Type',
            'AE',
            'Cash Balance',
            'Product Market Value',
            'Total Balance',
            'Loan Limit';

    open cur_balance; 
    set v_done = 0; 
    fetch cur_balance into v_currency; 
    while v_done <> 1 do 

        set v_ccy = case v_currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end;
        
        insert into tmp_export
        select 
            '','','','',
            v_ccy,v_ccy,v_ccy,v_ccy;


        drop temporary table IF EXISTS tmp_balance;
        CREATE TEMPORARY TABLE tmp_balance 
        (
            `Client_AC` VARCHAR(16) NULL DEFAULT NULL,
            `Client_Name` VARCHAR(128) NULL DEFAULT NULL,
            `Type` VARCHAR(32) NULL DEFAULT NULL,
            `AE` varchar(32) NULL DEFAULT NULL,
            `Cash_bal` DECIMAL(30,10) NULL DEFAULT NULL,
            `Product_MV` DECIMAL(30,10) NULL DEFAULT NULL,
            `Total_bal` DECIMAL(30,10) NULL DEFAULT NULL,
            `Loan_limit` DECIMAL(30,10) NULL DEFAULT NULL
        );

        insert into tmp_balance
        select 
            a.account_id,
            replace(b.short_name,',',' '),
            case c.account_type when 1 then 'C' when 2 then 'M' when 0 then 'H' end as type,
            c.ae_id,
            round(a.trade_balance - ifnull(d.amt,0),2) as trade_balance,
            round(ifnull(e.market_value,0),2),
            round(round(a.trade_balance - ifnull(d.amt,0),2) + ifnull(e.market_value,0),2),
            ifnull(c.loan_limit,0)
        from account_balance a 
        inner join account_profile b on a.account_id = b.account_id
        inner join capital_account c on c.account_id = a.account_id
        left join(
            select account_id,currency,sum(case purpose when 1 then 1 else -1 end * amount) as amt from cash_flow_cit where process_date <= i_process_date group by account_id,currency having(amt<>0)
        ) d on d.account_id = a.account_id and d.currency = a.currency
        left join (
            select 
                po.account_id,
                po.currency,
                sum(po.net_quantity * po.closing_price) as market_value
            from account_position po
            inner join product pr on pr.product_id = po.product_id
            where po.process_date = i_process_date group by po.account_id,po.currency
        ) e on e.account_id = a.account_id and e.currency = a.currency
        where a.process_date = i_process_date and 
            a.currency = v_currency
        order by a.account_id;


        insert into tmp_export
        select 
            Client_AC,
            Client_Name,
            Type,
            AE,
            round(Cash_bal,2),
            round(Product_MV,2),
            round(Total_bal,2),
            case v_currency when 2 then round(Loan_limit,2) else '' end
        from tmp_balance 
        where (Cash_bal <> 0 or Product_MV <> 0)
        order by Client_AC;

        insert into tmp_export
        select 
            '','','',
            'Total:',
            round(sum(Cash_bal),2),
            round(sum(Product_MV),2),
            round(sum(Total_bal),2),
            case v_currency when 2 then round(sum(Loan_limit),2) else '0.00' end
        from tmp_balance;

        set v_done = 0; 
        fetch cur_balance into v_currency; 
    end while; 
    close cur_balance;

    select * from tmp_export a;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientFundBalance
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientFundBalance`;
delimiter ;;
CREATE PROCEDURE `proExportClientFundBalance`(IN i_process_date DATE,
    IN i_account_type varchar(16))
label:BEGIN
DECLARE v_date_cn_t1 DATE;
DECLARE v_date_hk_t1 DATE;
DECLARE v_date_hk_t2 DATE;
DECLARE v_date_us_t1 DATE;
DECLARE v_date_us_t2 DATE;
IF i_process_date IS NULL THEN
    SELECT buss_date INTO i_process_date FROM sys_info;
END IF;
SELECT funIntervalSettleDay(4,i_process_date,1) INTO v_date_cn_t1;
SELECT funIntervalSettleDay(1,i_process_date,1) INTO v_date_hk_t1;
SELECT funIntervalSettleDay(1,i_process_date,2) INTO v_date_hk_t2;
SELECT funIntervalSettleDay(2,i_process_date,1) INTO v_date_us_t1;
SELECT funIntervalSettleDay(2,i_process_date,2) INTO v_date_us_t2;

drop temporary table IF EXISTS tmp_rpt;
CREATE TEMPORARY TABLE tmp_rpt
(
    process_date     DATE,
    ae_code          VARCHAR(32),
    account_id       VARCHAR(32),
    account_name     VARCHAR(256),
    account_type     INT,
    currency         INT,
    balance_t0       DECIMAL(30,10),
    pend_settle_t1   DECIMAL(30,10),
    balance_t1       DECIMAL(30,10),
    pend_settle_t2   DECIMAL(30,10),
    net_balance      DECIMAL(30,10),
    accrued_interest DECIMAL(30,10),
    uncleared_amount DECIMAL(30,10),
    net_avail_bal    DECIMAL(30,10),
    mkt_value_t0     DECIMAL(30,10),
    data_type        INT,
    INDEX idx1(process_date,account_id,account_type,currency,data_type),
    index idx2(account_type)
);
drop temporary table IF EXISTS tmp_rpt_set;
CREATE TEMPORARY TABLE tmp_rpt_set SELECT * FROM tmp_rpt WHERE 1=2; -- 集合.

create INDEX idx1 on tmp_rpt_set(process_date,account_id,account_type,currency,data_type);

drop temporary table if exists tmp1; 
create temporary table tmp1 
SELECT account_id, SUM(IF(purpose=1,amount,0)-IF(purpose=2,amount,0))AS amt 
FROM cash_flow_cit 
WHERE process_date<=i_process_date AND currency=1 
GROUP BY account_id; 
create index idx1 on tmp1(account_id);

drop temporary table if exists tmp2; 
create temporary table tmp2 
 select 
    po.account_id,
    po.currency,
    sum(po.quantity * po.closing_price) as market_value
from account_position po
inner join product pr on pr.product_id = po.product_id
where po.process_date = i_process_date 
group by po.account_id,po.currency; 
create index idx1 on tmp2(account_id, currency);

-- CNY.
INSERT INTO tmp_rpt(  process_date,   account_id, account_name,   account_type,   currency,      balance_t0,    net_balance,                                            accrued_interest, uncleared_amount,   mkt_value_t0)
SELECT a.process_date, a.account_id, replace(b.short_name,',',' '), a.account_type, a.currency,a.settle_balance,a.trade_balance-IFNULL(c.amt,0),a.accrued_interest_credit-a.accrued_interest,                0, ifnull(e.market_value,0)
FROM account_balance a 
LEFT JOIN account_profile b ON a.account_id=b.account_id
LEFT JOIN tmp1 c ON a.account_id=c.account_id 
left join tmp2 e on e.account_id = a.account_id and e.currency = a.currency
WHERE i_process_date=a.process_date AND a.account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND a.currency=1;

drop temporary table if exists tmp3; 
create temporary table tmp3 
SELECT account_id, SUM(IF(buy_sell = 1, -1, 1) * net_amount) AS net_amount 
FROM account_trade 
WHERE settle_date=v_date_cn_t1 AND 
account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND 
clearing_currency=1 and status = 'Confirmed' 
GROUP BY account_id;
create index idx3 on tmp3(account_id);

UPDATE tmp_rpt a
inner join tmp3 b on a.account_id = b.account_id 
SET a.pend_settle_t1=b.net_amount;


UPDATE tmp_rpt 
SET pend_settle_t1 = IFNULL(pend_settle_t1,0), 
    pend_settle_t2 = IFNULL(pend_settle_t2,0),
    balance_t1 = balance_t0 + IFNULL(pend_settle_t1,0),
    net_avail_bal = net_balance + accrued_interest;

drop temporary table IF EXISTS tmp_rpt_2;
CREATE TEMPORARY TABLE tmp_rpt_2 
SELECT * FROM tmp_rpt WHERE 1=2;

create INDEX idx1 on tmp_rpt_2(process_date,account_id,account_type,currency,data_type);

INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest, data_type)
SELECT  'Debit',        1, SUM(IF(balance_t0<0,balance_t0,0)),SUM(IF(pend_settle_t1<0,pend_settle_t1,0)),SUM(IF(balance_t1<0,balance_t1,0)),SUM(IF(pend_settle_t2<0,pend_settle_t2,0)),SUM(IF(net_balance<0,net_balance,0)),SUM(IF(accrued_interest<0,accrued_interest,0)),2 FROM tmp_rpt;

INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest, data_type)
SELECT 'Credit',        1, SUM(IF(balance_t0>0,balance_t0,0)),SUM(IF(pend_settle_t1>0,pend_settle_t1,0)),SUM(IF(balance_t1>0,balance_t1,0)),SUM(IF(pend_settle_t2>0,pend_settle_t2,0)),SUM(IF(net_balance>0,net_balance,0)),SUM(IF(accrued_interest>0,accrued_interest,0)),2 FROM tmp_rpt;

drop temporary table if exists tmp4; 
create temporary table tmp4 
SELECT IF(buy_sell=1,'Debit','Credit')AS memo, SUM(IF(buy_sell=1,-1,1)*net_amount)AS net_amount 
FROM account_trade 
WHERE STATUS='Confirmed' AND settle_date=v_date_cn_t1 AND account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND clearing_currency=1 
GROUP BY buy_sell;
create index idx1 on tmp4(memo);

UPDATE tmp_rpt_2 dst
inner join tmp4 src on dst.ae_code=src.memo
SET dst.pend_settle_t1=net_amount;

UPDATE tmp_rpt_2 dst SET dst.pend_settle_t2=0;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
            SELECT 'SubTotal',        1,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
       SELECT 'SubTotal_Cash',        1,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=1;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
     SELECT 'SubTotal_Margin',        1,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=2;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
     SELECT  'SubTotal_House',        1,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=0;
INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_2;
INSERT INTO tmp_rpt_set SELECT * FROM tmp_rpt;

drop temporary table if exists tmp1; 
create temporary table tmp1 
SELECT account_id, SUM(IF(purpose=1,amount,0)-IF(purpose=2,amount,0))AS amt FROM cash_flow_cit WHERE process_date<=i_process_date AND currency=2 GROUP BY account_id; 
create index idx1 on tmp1(account_id);

drop temporary table if exists tmp2; 
create temporary table tmp2 
select 
    po.account_id,
    po.currency,
    sum(po.quantity * po.closing_price) as market_value
from account_position po
inner join product pr on pr.product_id = po.product_id
where po.process_date = i_process_date 
group by po.account_id,po.currency;
create index idx on tmp2(account_id, currency);

-- HKD.
delete from tmp_rpt;
INSERT INTO tmp_rpt(  process_date,   account_id, account_name,   account_type,   currency,      balance_t0,    net_balance,                                            accrued_interest, uncleared_amount,   mkt_value_t0)
SELECT a.process_date, a.account_id, replace(b.short_name,',',' '), a.account_type, a.currency,a.settle_balance,a.trade_balance-IFNULL(c.amt,0),a.accrued_interest_credit-a.accrued_interest,                0, ifnull(e.market_value,0)
FROM account_balance a LEFT JOIN account_profile b ON a.account_id=b.account_id 
LEFT JOIN tmp1 c ON a.account_id=c.account_id
left join tmp2 e on e.account_id = a.account_id and e.currency = a.currency 
WHERE i_process_date=a.process_date AND a.account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND a.currency=2;

drop temporary table if exists tmp; 
create temporary table tmp 
SELECT account_id, SUM(IF(buy_sell = 1, -1, 1) * net_amount) AS net_amount 
FROM account_trade 
WHERE settle_date=v_date_hk_t1 AND 
account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND 
clearing_currency=2 and status = 'Confirmed' GROUP BY account_id;
create index idx on tmp(account_id);

UPDATE tmp_rpt a
inner join tmp b  on a.account_id=b.account_id
SET a.pend_settle_t1=b.net_amount;

drop temporary table if exists tmp; 
create temporary table tmp 
SELECT account_id, SUM(IF(buy_sell = 1, -1, 1) * net_amount) AS net_amount 
FROM account_trade WHERE settle_date=v_date_hk_t2 AND account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND clearing_currency=2 and status = 'Confirmed' GROUP BY account_id;
create index idx on tmp(account_id);

UPDATE tmp_rpt a
inner join tmp b on a.account_id=b.account_id
SET a.pend_settle_t2=b.net_amount ;

UPDATE tmp_rpt SET pend_settle_t1 = IFNULL(pend_settle_t1,0), 
                   pend_settle_t2 = IFNULL(pend_settle_t2,0),
                       balance_t1 = balance_t0 + IFNULL(pend_settle_t1,0),
                    net_avail_bal = net_balance + accrued_interest;

-- drop temporary table IF EXISTS tmp_rpt_2;
-- CREATE TEMPORARY TABLE tmp_rpt_2 SELECT * FROM tmp_rpt WHERE 1=2;


delete from tmp_rpt_2;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest, data_type)
              SELECT  'Debit',        2, SUM(IF(balance_t0<0,balance_t0,0)),SUM(IF(pend_settle_t1<0,pend_settle_t1,0)),SUM(IF(balance_t1<0,balance_t1,0)),SUM(IF(pend_settle_t2<0,pend_settle_t2,0)),SUM(IF(net_balance<0,net_balance,0)),SUM(IF(accrued_interest<0,accrued_interest,0)),2 FROM tmp_rpt;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest, data_type)
              SELECT 'Credit',        2, SUM(IF(balance_t0>0,balance_t0,0)),SUM(IF(pend_settle_t1>0,pend_settle_t1,0)),SUM(IF(balance_t1>0,balance_t1,0)),SUM(IF(pend_settle_t2>0,pend_settle_t2,0)),SUM(IF(net_balance>0,net_balance,0)),SUM(IF(accrued_interest>0,accrued_interest,0)),2 FROM tmp_rpt;

drop temporary table if exists tmp; 
create temporary table tmp 
 SELECT IF(buy_sell=1,'Debit','Credit')AS memo, SUM(IF(buy_sell=1,-1,1)*net_amount)AS net_amount FROM account_trade 
        WHERE STATUS='Confirmed' AND settle_date=v_date_hk_t1 AND account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND clearing_currency=2 GROUP BY buy_sell;
create index idx on tmp(memo);

UPDATE tmp_rpt_2 dst 
inner join tmp src on dst.ae_code=src.memo
SET dst.pend_settle_t1=net_amount ;


drop temporary table if exists tmp; 
create temporary table tmp 
 SELECT IF(buy_sell=1,'Debit','Credit')AS memo, SUM(IF(buy_sell=1,-1,1)*net_amount)AS net_amount FROM account_trade 
        WHERE STATUS='Confirmed' AND settle_date=v_date_hk_t2 AND account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND clearing_currency=2 GROUP BY buy_sell;
create index idx on tmp(memo);

UPDATE tmp_rpt_2 dst
inner join tmp src on dst.ae_code=src.memo
SET dst.pend_settle_t2=net_amount ;

INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
            SELECT 'SubTotal',        2,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
       SELECT 'SubTotal_Cash',        2,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=1;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
     SELECT 'SubTotal_Margin',        2,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=2;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
     SELECT  'SubTotal_House',        2,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=0;
INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_2;
INSERT INTO tmp_rpt_set SELECT * FROM tmp_rpt;

-- USD.
drop temporary table if exists tmp1; 
create temporary table tmp1 
SELECT account_id, SUM(IF(purpose=1,amount,0)-IF(purpose=2,amount,0))AS amt FROM cash_flow_cit WHERE process_date<=i_process_date AND currency=4 GROUP BY account_id;
create index idx on tmp1(account_id);

drop temporary table if exists tmp2; 
create temporary table tmp2 
select 
po.account_id,
po.currency,
sum(po.quantity * po.closing_price) as market_value
from account_position po
inner join product pr on pr.product_id = po.product_id
where po.process_date = i_process_date group by po.account_id,po.currency;
create index idx on tmp2(account_id);

delete from tmp_rpt;
INSERT INTO tmp_rpt(  process_date,   account_id, account_name,   account_type,   currency,      balance_t0,    net_balance,                                            accrued_interest, uncleared_amount,   mkt_value_t0)
             SELECT a.process_date, a.account_id, replace(b.short_name,',',' '), a.account_type, a.currency,a.settle_balance,a.trade_balance-IFNULL(c.amt,0),a.accrued_interest_credit-a.accrued_interest,                0, ifnull(e.market_value,0)
                FROM account_balance a LEFT JOIN account_profile b ON a.account_id=b.account_id 
                    LEFT JOIN tmp1 c ON a.account_id=c.account_id 
                    left join tmp2 e on e.account_id = a.account_id and e.currency = a.currency
                    WHERE i_process_date=a.process_date AND a.account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND a.currency=4;

drop temporary table if exists tmp; 
create temporary table tmp 
SELECT account_id, SUM(IF(buy_sell = 1, -1, 1) * net_amount) AS net_amount 
FROM account_trade WHERE settle_date=v_date_us_t1 AND account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND clearing_currency=4 and status = 'Confirmed' GROUP BY account_id;
create index idx on tmp(account_id);


UPDATE tmp_rpt a
inner join tmp b on a.account_id=b.account_id
SET a.pend_settle_t1=b.net_amount ;

UPDATE tmp_rpt SET pend_settle_t1 = IFNULL(pend_settle_t1,0), 
                   pend_settle_t2 = IFNULL(pend_settle_t2,0),
                       balance_t1 = balance_t0 + IFNULL(pend_settle_t1,0),
                    net_avail_bal = net_balance + accrued_interest;

delete from tmp_rpt_2;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest, data_type)
              SELECT  'Debit',        4, SUM(IF(balance_t0<0,balance_t0,0)),SUM(IF(pend_settle_t1<0,pend_settle_t1,0)),SUM(IF(balance_t1<0,balance_t1,0)),SUM(IF(pend_settle_t2<0,pend_settle_t2,0)),SUM(IF(net_balance<0,net_balance,0)),SUM(IF(accrued_interest<0,accrued_interest,0)),2 FROM tmp_rpt;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest, data_type)
              SELECT 'Credit',        4, SUM(IF(balance_t0>0,balance_t0,0)),SUM(IF(pend_settle_t1>0,pend_settle_t1,0)),SUM(IF(balance_t1>0,balance_t1,0)),SUM(IF(pend_settle_t2>0,pend_settle_t2,0)),SUM(IF(net_balance>0,net_balance,0)),SUM(IF(accrued_interest>0,accrued_interest,0)),2 FROM tmp_rpt;

drop temporary table if exists tmp; 
create temporary table tmp
SELECT IF(buy_sell=1,'Debit','Credit')AS memo, SUM(IF(buy_sell=1,-1,1)*net_amount)AS net_amount 
FROM account_trade 
WHERE STATUS='Confirmed' AND settle_date=v_date_us_t1 AND account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND clearing_currency=4 
GROUP BY buy_sell;
create index idx1 on tmp(memo);

UPDATE tmp_rpt_2 dst
inner join tmp src on dst.ae_code=src.memo
SET dst.pend_settle_t1=net_amount ;

UPDATE tmp_rpt_2 dst SET dst.pend_settle_t2=0;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
            SELECT 'SubTotal',        4,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
       SELECT 'SubTotal_Cash',        4,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=1;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
     SELECT 'SubTotal_Margin',        4,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=2;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
     SELECT  'SubTotal_House',        4,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=0;
INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_2;
INSERT INTO tmp_rpt_set SELECT * FROM tmp_rpt;


SELECT * FROM tmp_rpt_set;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientFundBalanceCSV
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientFundBalanceCSV`;
delimiter ;;
CREATE PROCEDURE `proExportClientFundBalanceCSV`(IN i_process_date DATE,
    IN i_account_type INT)
label:BEGIN
DECLARE v_date_cn_t1 DATE;
DECLARE v_date_hk_t1 DATE;
DECLARE v_date_hk_t2 DATE;
DECLARE v_date_us_t1 DATE;
DECLARE v_date_us_t2 DATE;
IF i_process_date IS NULL THEN
    SELECT buss_date INTO i_process_date FROM sys_info;
END IF;
SELECT funIntervalSettleDay(4,i_process_date,1) INTO v_date_cn_t1;
SELECT funIntervalSettleDay(1,i_process_date,1) INTO v_date_hk_t1;
SELECT funIntervalSettleDay(1,i_process_date,2) INTO v_date_hk_t2;
SELECT funIntervalSettleDay(2,i_process_date,1) INTO v_date_us_t1;
SELECT funIntervalSettleDay(2,i_process_date,2) INTO v_date_us_t2;

drop temporary table IF EXISTS tmp_rpt;
CREATE TEMPORARY TABLE tmp_rpt
(
    process_date     DATE,
    ae_code          VARCHAR(32),
    account_id       VARCHAR(32),
    account_name     VARCHAR(256),
    account_type     INT,
    currency         INT,
    balance_t0       DECIMAL(30,10),
    pend_settle_t1   DECIMAL(30,10),
    balance_t1       DECIMAL(30,10),
    pend_settle_t2   DECIMAL(30,10),
    net_balance      DECIMAL(30,10),
    accrued_interest DECIMAL(30,10),
    uncleared_amount DECIMAL(30,10),
    net_avail_bal    DECIMAL(30,10),
    mkt_value_t0     DECIMAL(30,10),
    data_type        INT,
    INDEX idx1(process_date,account_id,account_type,currency,data_type)
);
drop temporary table IF EXISTS tmp_rpt_set;
CREATE TEMPORARY TABLE tmp_rpt_set SELECT * FROM tmp_rpt WHERE 1=2; -- 集合.

-- CNY.
INSERT INTO tmp_rpt(  process_date,   account_id, account_name,   account_type,   currency,      balance_t0,    net_balance,                                            accrued_interest, uncleared_amount,   mkt_value_t0,data_type)
             SELECT a.process_date, a.account_id, concat('"',b.short_name,'"'), a.account_type, a.currency,a.settle_balance,a.trade_balance-IFNULL(c.amt,0),a.accrued_interest_credit-a.accrued_interest,                0, ifnull(e.market_value,0),1
                 FROM account_balance a LEFT JOIN account_profile b ON a.account_id=b.account_id
                    LEFT JOIN(
                        SELECT account_id, SUM(IF(purpose=1,amount,0)-IF(purpose=2,amount,0))AS amt FROM cash_flow_cit WHERE process_date<=i_process_date AND currency=1 GROUP BY account_id
                    )c ON a.account_id=c.account_id 
                    left join (
                        select 
                            po.account_id,
                            po.currency,
                            sum(po.quantity * po.closing_price) as market_value
                        from account_position po
                        inner join product pr on pr.product_id = po.product_id
                        where po.process_date = i_process_date and po.currency = 1 group by po.account_id,po.currency
                    ) e on e.account_id = a.account_id and e.currency = a.currency 
                    WHERE i_process_date=a.process_date AND a.account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND a.currency=1;

UPDATE tmp_rpt a, (SELECT account_id, SUM(IF(buy_sell = 1, -1, 1) * net_amount) AS net_amount 
                       FROM account_trade WHERE settle_date=v_date_cn_t1 AND account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND clearing_currency=1 and status = 'Confirmed' GROUP BY account_id
                  )b SET a.pend_settle_t1=b.net_amount WHERE a.account_id=b.account_id;
UPDATE tmp_rpt SET pend_settle_t1 = IFNULL(pend_settle_t1,0), 
                   pend_settle_t2 = IFNULL(pend_settle_t2,0),
                       balance_t1 = balance_t0 + IFNULL(pend_settle_t1,0),
                    net_avail_bal = net_balance + accrued_interest;

drop temporary table IF EXISTS tmp_rpt_2;
CREATE TEMPORARY TABLE tmp_rpt_2 SELECT * FROM tmp_rpt WHERE 1=2;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest, data_type)
              SELECT  'Debit',        1, SUM(IF(balance_t0<0,balance_t0,0)),SUM(IF(pend_settle_t1<0,pend_settle_t1,0)),SUM(IF(balance_t1<0,balance_t1,0)),SUM(IF(pend_settle_t2<0,pend_settle_t2,0)),SUM(IF(net_balance<0,net_balance,0)),SUM(IF(accrued_interest<0,accrued_interest,0)),2 FROM tmp_rpt;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest, data_type)
              SELECT 'Credit',        1, SUM(IF(balance_t0>0,balance_t0,0)),SUM(IF(pend_settle_t1>0,pend_settle_t1,0)),SUM(IF(balance_t1>0,balance_t1,0)),SUM(IF(pend_settle_t2>0,pend_settle_t2,0)),SUM(IF(net_balance>0,net_balance,0)),SUM(IF(accrued_interest>0,accrued_interest,0)),2 FROM tmp_rpt;
UPDATE tmp_rpt_2 dst,(
    SELECT IF(buy_sell=1,'Debit','Credit')AS memo, SUM(IF(buy_sell=1,-1,1)*net_amount)AS net_amount FROM account_trade 
        WHERE STATUS='Confirmed' AND settle_date=v_date_cn_t1 AND account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND clearing_currency=1 GROUP BY buy_sell
    )src SET dst.pend_settle_t1=net_amount WHERE dst.ae_code=src.memo;
UPDATE tmp_rpt_2 dst SET dst.pend_settle_t2=0;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
            SELECT 'SubTotal',        1,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
       SELECT 'SubTotal_Cash',        1,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=1;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
     SELECT 'SubTotal_Margin',        1,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=2;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
     SELECT  'SubTotal_House',        1,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=0;
INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_2;
INSERT INTO tmp_rpt_set SELECT * FROM tmp_rpt;

-- HKD.
delete from tmp_rpt;
INSERT INTO tmp_rpt(  process_date,   account_id, account_name,   account_type,   currency,      balance_t0,    net_balance,                                            accrued_interest, uncleared_amount,   mkt_value_t0,data_type)
             SELECT a.process_date, a.account_id,concat('"',b.short_name,'"'), a.account_type, a.currency,a.settle_balance,a.trade_balance-IFNULL(c.amt,0),a.accrued_interest_credit-a.accrued_interest,                0, ifnull(e.market_value,0),1
                 FROM account_balance a LEFT JOIN account_profile b ON a.account_id=b.account_id 
                 LEFT JOIN(
                        SELECT account_id, SUM(IF(purpose=1,amount,0)-IF(purpose=2,amount,0))AS amt FROM cash_flow_cit WHERE process_date<=i_process_date AND currency=2 GROUP BY account_id
                    )c ON a.account_id=c.account_id 
                    left join (
                        select 
                            po.account_id,
                            po.currency,
                            sum(po.quantity * po.closing_price) as market_value
                        from account_position po
                        inner join product pr on pr.product_id = po.product_id
                        where po.process_date = i_process_date and po.currency = 2 group by po.account_id,po.currency
                    ) e on e.account_id = a.account_id and e.currency = a.currency 
                 WHERE i_process_date=a.process_date AND a.account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND a.currency=2;

UPDATE tmp_rpt a, (SELECT account_id, SUM(IF(buy_sell = 1, -1, 1) * net_amount) AS net_amount 
                       FROM account_trade WHERE settle_date=v_date_hk_t1 AND account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND clearing_currency=2 and status = 'Confirmed' GROUP BY account_id
                  )b SET a.pend_settle_t1=b.net_amount WHERE a.account_id=b.account_id;
UPDATE tmp_rpt a, (SELECT account_id, SUM(IF(buy_sell = 1, -1, 1) * net_amount) AS net_amount 
                       FROM account_trade WHERE settle_date=v_date_hk_t2 AND account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND clearing_currency=2 and status = 'Confirmed' GROUP BY account_id
                  )b SET a.pend_settle_t2=b.net_amount WHERE a.account_id=b.account_id;
UPDATE tmp_rpt SET pend_settle_t1 = IFNULL(pend_settle_t1,0), 
                   pend_settle_t2 = IFNULL(pend_settle_t2,0),
                       balance_t1 = balance_t0 + IFNULL(pend_settle_t1,0),
                    net_avail_bal = net_balance + accrued_interest;

-- drop temporary table IF EXISTS tmp_rpt_2;
-- CREATE TEMPORARY TABLE tmp_rpt_2 SELECT * FROM tmp_rpt WHERE 1=2;
delete from tmp_rpt_2;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest, data_type)
              SELECT  'Debit',        2, SUM(IF(balance_t0<0,balance_t0,0)),SUM(IF(pend_settle_t1<0,pend_settle_t1,0)),SUM(IF(balance_t1<0,balance_t1,0)),SUM(IF(pend_settle_t2<0,pend_settle_t2,0)),SUM(IF(net_balance<0,net_balance,0)),SUM(IF(accrued_interest<0,accrued_interest,0)),2 FROM tmp_rpt;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest, data_type)
              SELECT 'Credit',        2, SUM(IF(balance_t0>0,balance_t0,0)),SUM(IF(pend_settle_t1>0,pend_settle_t1,0)),SUM(IF(balance_t1>0,balance_t1,0)),SUM(IF(pend_settle_t2>0,pend_settle_t2,0)),SUM(IF(net_balance>0,net_balance,0)),SUM(IF(accrued_interest>0,accrued_interest,0)),2 FROM tmp_rpt;
UPDATE tmp_rpt_2 dst,(
    SELECT IF(buy_sell=1,'Debit','Credit')AS memo, SUM(IF(buy_sell=1,-1,1)*net_amount)AS net_amount FROM account_trade 
        WHERE STATUS='Confirmed' AND settle_date=v_date_hk_t1 AND account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND clearing_currency=2 GROUP BY buy_sell
    )src SET dst.pend_settle_t1=net_amount WHERE dst.ae_code=src.memo;
UPDATE tmp_rpt_2 dst,(
    SELECT IF(buy_sell=1,'Debit','Credit')AS memo, SUM(IF(buy_sell=1,-1,1)*net_amount)AS net_amount FROM account_trade 
        WHERE STATUS='Confirmed' AND settle_date=v_date_hk_t2 AND account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND clearing_currency=2 GROUP BY buy_sell
    )src SET dst.pend_settle_t2=net_amount WHERE dst.ae_code=src.memo;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
            SELECT 'SubTotal',        2,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
       SELECT 'SubTotal_Cash',        2,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=1;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
     SELECT 'SubTotal_Margin',        2,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=2;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
     SELECT  'SubTotal_House',        2,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=0;
INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_2;
INSERT INTO tmp_rpt_set SELECT * FROM tmp_rpt;

-- USD.
delete from tmp_rpt;
INSERT INTO tmp_rpt(  process_date,   account_id, account_name,   account_type,   currency,      balance_t0,    net_balance,                                            accrued_interest, uncleared_amount,   mkt_value_t0,data_type)
             SELECT a.process_date, a.account_id, concat('"',b.short_name,'"'), a.account_type, a.currency,a.settle_balance,a.trade_balance-IFNULL(c.amt,0),a.accrued_interest_credit-a.accrued_interest,                0, ifnull(e.market_value,0),1
                 FROM account_balance a LEFT JOIN account_profile b ON a.account_id=b.account_id 
                 LEFT JOIN(
                        SELECT account_id, SUM(IF(purpose=1,amount,0)-IF(purpose=2,amount,0))AS amt FROM cash_flow_cit WHERE process_date<=i_process_date AND currency=4 GROUP BY account_id
                    )c ON a.account_id=c.account_id 
                    left join (
                        select 
                            po.account_id,
                            po.currency,
                            sum(po.quantity * po.closing_price) as market_value
                        from account_position po
                        inner join product pr on pr.product_id = po.product_id
                        where po.process_date = i_process_date and po.currency = 4 group by po.account_id,po.currency
                    ) e on e.account_id = a.account_id and e.currency = a.currency 
                 WHERE i_process_date=a.process_date AND a.account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND a.currency=4;

UPDATE tmp_rpt a, (SELECT account_id, SUM(IF(buy_sell = 1, -1, 1) * net_amount) AS net_amount 
                       FROM account_trade WHERE settle_date=v_date_hk_t1 AND account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND clearing_currency=4 and status = 'Confirmed' GROUP BY account_id
                  )b SET a.pend_settle_t1=b.net_amount WHERE a.account_id=b.account_id;
UPDATE tmp_rpt a, (SELECT account_id, SUM(IF(buy_sell = 1, -1, 1) * net_amount) AS net_amount 
                       FROM account_trade WHERE settle_date=v_date_hk_t2 AND account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND clearing_currency=4 and status = 'Confirmed' GROUP BY account_id
                  )b SET a.pend_settle_t2=b.net_amount WHERE a.account_id=b.account_id;
UPDATE tmp_rpt SET pend_settle_t1 = IFNULL(pend_settle_t1,0), 
                   pend_settle_t2 = IFNULL(pend_settle_t2,0),
                       balance_t1 = balance_t0 + IFNULL(pend_settle_t1,0),
                    net_avail_bal = net_balance + accrued_interest;

delete from tmp_rpt_2;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest, data_type)
              SELECT  'Debit',        4, SUM(IF(balance_t0<0,balance_t0,0)),SUM(IF(pend_settle_t1<0,pend_settle_t1,0)),SUM(IF(balance_t1<0,balance_t1,0)),SUM(IF(pend_settle_t2<0,pend_settle_t2,0)),SUM(IF(net_balance<0,net_balance,0)),SUM(IF(accrued_interest<0,accrued_interest,0)),2 FROM tmp_rpt;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest, data_type)
              SELECT 'Credit',        4, SUM(IF(balance_t0>0,balance_t0,0)),SUM(IF(pend_settle_t1>0,pend_settle_t1,0)),SUM(IF(balance_t1>0,balance_t1,0)),SUM(IF(pend_settle_t2>0,pend_settle_t2,0)),SUM(IF(net_balance>0,net_balance,0)),SUM(IF(accrued_interest>0,accrued_interest,0)),2 FROM tmp_rpt;
UPDATE tmp_rpt_2 dst,(
    SELECT IF(buy_sell=1,'Debit','Credit')AS memo, SUM(IF(buy_sell=1,-1,1)*net_amount)AS net_amount FROM account_trade 
        WHERE STATUS='Confirmed' AND settle_date=v_date_hk_t1 AND account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND clearing_currency=4 GROUP BY buy_sell
    )src SET dst.pend_settle_t1=net_amount WHERE dst.ae_code=src.memo;
UPDATE tmp_rpt_2 dst,(
    SELECT IF(buy_sell=1,'Debit','Credit')AS memo, SUM(IF(buy_sell=1,-1,1)*net_amount)AS net_amount FROM account_trade 
        WHERE STATUS='Confirmed' AND settle_date=v_date_hk_t2 AND account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type)) AND clearing_currency=4 GROUP BY buy_sell
    )src SET dst.pend_settle_t2=net_amount WHERE dst.ae_code=src.memo;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
            SELECT 'SubTotal',        4,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
       SELECT 'SubTotal_Cash',        4,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=1;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
     SELECT 'SubTotal_Margin',        4,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=2;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
     SELECT  'SubTotal_House',        4,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=0;
INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_2;
INSERT INTO tmp_rpt_set SELECT * FROM tmp_rpt;


SELECT * FROM tmp_rpt_set WHERE data_type=1 ORDER BY account_type,currency,account_id;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientFundBalanceIgnore
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientFundBalanceIgnore`;
delimiter ;;
CREATE PROCEDURE `proExportClientFundBalanceIgnore`(IN i_process_date DATE,
    IN i_account_type varchar(16))
label:BEGIN
DECLARE v_date_cn_t1 DATE;
DECLARE v_date_hk_t1 DATE;
DECLARE v_date_hk_t2 DATE;
DECLARE v_date_us_t1 DATE;
DECLARE v_date_us_t2 DATE;
IF i_process_date IS NULL THEN
    SELECT buss_date INTO i_process_date FROM sys_info;
END IF;
SELECT funIntervalSettleDay(4,i_process_date,1) INTO v_date_cn_t1;
SELECT funIntervalSettleDay(1,i_process_date,1) INTO v_date_hk_t1;
SELECT funIntervalSettleDay(1,i_process_date,2) INTO v_date_hk_t2;
SELECT funIntervalSettleDay(2,i_process_date,1) INTO v_date_us_t1;
SELECT funIntervalSettleDay(2,i_process_date,2) INTO v_date_us_t2;

drop temporary table IF EXISTS tmp_acct;
CREATE TEMPORARY TABLE tmp_acct
(
    account_id       VARCHAR(32),
    INDEX idx1(account_id)
);
insert into tmp_acct
SELECT ACCOUNT_id FROM (
select a.account_id,COUNT(a.account_id) AS cur_cnt,SUM(case when a.settle_balance <= 0 then 1 ELSE 0 end) AS cnt_bal1,SUM(case when a.settle_balance > 0 then 1 ELSE 0 end) AS cnt_bal2
from account_balance a 
inner join tmp_ignore_acct b on b.account_id = a.account_id
INNER JOIN account_profile c on c.account_id = a.account_id and c.account_class <> 1 
where a.process_date = i_process_date
GROUP BY a.account_id
HAVING((cur_cnt <> cnt_bal1) AND (cur_cnt <> cnt_bal2)) ) t;



drop temporary table IF EXISTS tmp_rpt;
CREATE TEMPORARY TABLE tmp_rpt
(
    process_date     DATE,
    ae_code          VARCHAR(32),
    account_id       VARCHAR(32),
    account_name     VARCHAR(256),
    account_type     INT,
    currency         INT,
    balance_t0       DECIMAL(30,10),
    pend_settle_t1   DECIMAL(30,10),
    balance_t1       DECIMAL(30,10),
    pend_settle_t2   DECIMAL(30,10),
    net_balance      DECIMAL(30,10),
    accrued_interest DECIMAL(30,10),
    uncleared_amount DECIMAL(30,10),
    net_avail_bal    DECIMAL(30,10),
    mkt_value_t0     DECIMAL(30,10),
    data_type        INT,
    INDEX idx1(process_date,account_id,account_type,currency,data_type),
    index idx2(account_type)
);
drop temporary table IF EXISTS tmp_rpt_set;
CREATE TEMPORARY TABLE tmp_rpt_set SELECT * FROM tmp_rpt WHERE 1=2; -- 集合.

create INDEX idx1 on tmp_rpt_set(process_date,account_id,account_type,currency,data_type);
create INDEX idx2 on tmp_rpt_set(account_id);

drop temporary table if exists tmp1; 
create temporary table tmp1 
SELECT account_id, SUM(IF(purpose=1,amount,0)-IF(purpose=2,amount,0))AS amt 
FROM cash_flow_cit 
WHERE process_date<=i_process_date AND currency=1 
GROUP BY account_id; 
create index idx1 on tmp1(account_id);

drop temporary table if exists tmp2; 
create temporary table tmp2 
select 
    po.account_id,
    po.currency,
    sum(po.quantity * po.closing_price) as market_value
from account_position po
inner join product pr on pr.product_id = po.product_id
where po.process_date = i_process_date and 
      po.account_id in (select account_id from tmp_acct)
group by po.account_id,po.currency;
create index idx on tmp2(account_id, currency);

-- CNY.
INSERT INTO tmp_rpt(  process_date,   account_id, account_name,   account_type,   currency,      balance_t0,    net_balance,                                            accrued_interest, uncleared_amount,   mkt_value_t0)
SELECT a.process_date, a.account_id, replace(b.short_name,',',' '), a.account_type, a.currency,a.settle_balance,a.trade_balance-IFNULL(c.amt,0),a.accrued_interest_credit-a.accrued_interest,                0, ifnull(e.market_value,0)
FROM account_balance a 
LEFT JOIN account_profile b ON a.account_id=b.account_id
LEFT JOIN tmp1 c ON a.account_id=c.account_id 
left join tmp2 e on e.account_id = a.account_id and e.currency = a.currency
WHERE i_process_date=a.process_date AND 
      a.account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND 
      a.currency=1 and 
      a.account_id in (select account_id from tmp_acct);

drop temporary table if exists tmp3; 
create temporary table tmp3 
SELECT account_id, SUM(IF(buy_sell = 1, -1, 1) * net_amount) AS net_amount 
FROM account_trade 
WHERE settle_date=v_date_cn_t1 and 
      account_id in (select account_id from tmp_acct) AND 
     account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND 
     clearing_currency=1 and status = 'Confirmed' 
GROUP BY account_id;
create index idx3 on tmp3(account_id);

UPDATE tmp_rpt a
inner join tmp3 b on a.account_id = b.account_id 
SET a.pend_settle_t1=b.net_amount;


UPDATE tmp_rpt 
SET pend_settle_t1 = IFNULL(pend_settle_t1,0), 
    pend_settle_t2 = IFNULL(pend_settle_t2,0),
    balance_t1 = balance_t0 + IFNULL(pend_settle_t1,0),
    net_avail_bal = net_balance + accrued_interest;

drop temporary table IF EXISTS tmp_rpt_2;
CREATE TEMPORARY TABLE tmp_rpt_2 
SELECT * FROM tmp_rpt WHERE 1=2;

create INDEX idx1 on tmp_rpt_2(process_date,account_id,account_type,currency,data_type);

INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest, data_type)
SELECT  'Debit',        1, SUM(IF(balance_t0<0,balance_t0,0)),SUM(IF(pend_settle_t1<0,pend_settle_t1,0)),SUM(IF(balance_t1<0,balance_t1,0)),SUM(IF(pend_settle_t2<0,pend_settle_t2,0)),SUM(IF(net_balance<0,net_balance,0)),SUM(IF(accrued_interest<0,accrued_interest,0)),2 
FROM tmp_rpt;

INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest, data_type)
SELECT 'Credit',        1, SUM(IF(balance_t0>0,balance_t0,0)),SUM(IF(pend_settle_t1>0,pend_settle_t1,0)),SUM(IF(balance_t1>0,balance_t1,0)),SUM(IF(pend_settle_t2>0,pend_settle_t2,0)),SUM(IF(net_balance>0,net_balance,0)),SUM(IF(accrued_interest>0,accrued_interest,0)),2 
FROM tmp_rpt;

drop temporary table if exists tmp4; 
create temporary table tmp4 
SELECT IF(buy_sell=1,'Debit','Credit')AS memo, SUM(IF(buy_sell=1,-1,1)*net_amount)AS net_amount 
FROM account_trade 
WHERE STATUS='Confirmed' AND 
      settle_date=v_date_cn_t1 AND 
      account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND 
      clearing_currency=1  and account_id in (select account_id from tmp_acct)
GROUP BY buy_sell;
create index idx1 on tmp4(memo);

UPDATE tmp_rpt_2 dst
inner join tmp4 src on dst.ae_code=src.memo
SET dst.pend_settle_t1=net_amount;

UPDATE tmp_rpt_2 dst SET dst.pend_settle_t2=0;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
SELECT 'SubTotal',        1,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       
        SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 
FROM tmp_rpt;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
       SELECT 'SubTotal_Cash',        1,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=1;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
     SELECT 'SubTotal_Margin',        1,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=2;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
     SELECT  'SubTotal_House',        1,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=0;
INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_2;
INSERT INTO tmp_rpt_set SELECT * FROM tmp_rpt;

drop temporary table if exists tmp1; 
create temporary table tmp1 
SELECT 
    account_id, SUM(IF(purpose=1,amount,0)-IF(purpose=2,amount,0))AS amt 
FROM cash_flow_cit 
WHERE process_date<=i_process_date AND currency=2 and 
      account_id in (select account_id from tmp_acct) 
GROUP BY account_id; 
create index idx1 on tmp1(account_id);

-- HKD.
truncate table tmp_rpt;
INSERT INTO tmp_rpt(  process_date,   account_id, account_name,   account_type,   currency,      balance_t0,    net_balance,                                            accrued_interest, uncleared_amount,   mkt_value_t0)
SELECT a.process_date, a.account_id, replace(b.short_name,',',' '), a.account_type, a.currency,a.settle_balance,a.trade_balance-IFNULL(c.amt,0),a.accrued_interest_credit-a.accrued_interest,                0, ifnull(e.market_value,0)
FROM account_balance a LEFT JOIN account_profile b ON a.account_id=b.account_id 
LEFT JOIN tmp1 c ON a.account_id=c.account_id
left join tmp2 e on e.account_id = a.account_id and e.currency = a.currency 
WHERE i_process_date=a.process_date AND 
      a.account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND 
      a.currency=2 and 
      a.account_id in (select account_id from tmp_acct);

drop temporary table if exists tmp; 
create temporary table tmp 
SELECT account_id, SUM(IF(buy_sell = 1, -1, 1) * net_amount) AS net_amount 
FROM account_trade 
WHERE settle_date=v_date_hk_t1 and 
      account_id in (select account_id from tmp_acct) AND 
      account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND 
      clearing_currency=2 and status = 'Confirmed'
GROUP BY account_id;
create index idx on tmp(account_id);

UPDATE tmp_rpt a
inner join tmp b  on a.account_id=b.account_id
SET a.pend_settle_t1=b.net_amount;

drop temporary table if exists tmp; 
create temporary table tmp 
SELECT account_id, SUM(IF(buy_sell = 1, -1, 1) * net_amount) AS net_amount 
FROM account_trade 
WHERE settle_date=v_date_hk_t2 AND 
      account_id in (select account_id from tmp_acct) and 
      account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND 
      clearing_currency=2 and status = 'Confirmed' GROUP BY account_id;
create index idx on tmp(account_id);

UPDATE tmp_rpt a
inner join tmp b on a.account_id=b.account_id
SET a.pend_settle_t2=ifnull(b.net_amount,0);

UPDATE tmp_rpt SET pend_settle_t1 = IFNULL(pend_settle_t1,0), 
                   pend_settle_t2 = IFNULL(pend_settle_t2,0),
                       balance_t1 = balance_t0 + IFNULL(pend_settle_t1,0),
                    net_avail_bal = net_balance + accrued_interest;

-- drop temporary table IF EXISTS tmp_rpt_2;
-- CREATE TEMPORARY TABLE tmp_rpt_2 SELECT * FROM tmp_rpt WHERE 1=2;
delete from tmp_rpt_2;
INSERT INTO 
tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest, data_type)
SELECT  'Debit',        2, SUM(IF(balance_t0<0,balance_t0,0)),SUM(IF(pend_settle_t1<0,pend_settle_t1,0)),SUM(IF(balance_t1<0,balance_t1,0)),SUM(IF(pend_settle_t2<0,pend_settle_t2,0)),SUM(IF(net_balance<0,net_balance,0)),SUM(IF(accrued_interest<0,accrued_interest,0)),2 
FROM tmp_rpt;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest, data_type)
SELECT 'Credit',        2, SUM(IF(balance_t0>0,balance_t0,0)),SUM(IF(pend_settle_t1>0,pend_settle_t1,0)),SUM(IF(balance_t1>0,balance_t1,0)),SUM(IF(pend_settle_t2>0,pend_settle_t2,0)),SUM(IF(net_balance>0,net_balance,0)),SUM(IF(accrued_interest>0,accrued_interest,0)),2 
FROM tmp_rpt;

drop temporary table if exists tmp; 
create temporary table tmp 
 SELECT IF(buy_sell=1,'Debit','Credit')AS memo, SUM(IF(buy_sell=1,-1,1)*net_amount)AS net_amount 
FROM account_trade 
WHERE STATUS='Confirmed' AND settle_date=v_date_hk_t1 AND 
      account_id in (select account_id from tmp_acct) and 
      account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND 
      clearing_currency=2 GROUP BY buy_sell;
create index idx on tmp(memo);

UPDATE tmp_rpt_2 dst 
inner join tmp src on dst.ae_code=src.memo
SET dst.pend_settle_t1=net_amount ;

drop temporary table if exists tmp; 
create temporary table tmp 
 SELECT IF(buy_sell=1,'Debit','Credit')AS memo, SUM(IF(buy_sell=1,-1,1)*net_amount)AS net_amount 
FROM account_trade 
WHERE STATUS='Confirmed' AND settle_date=v_date_hk_t2 AND 
      account_id in (select account_id from tmp_acct) and 
      account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND 
      clearing_currency=2 GROUP BY buy_sell;
create index idx on tmp(memo);

UPDATE tmp_rpt_2 dst
inner join tmp src on dst.ae_code=src.memo
SET dst.pend_settle_t2=net_amount ;

INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
            SELECT 'SubTotal',        2,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
       SELECT 'SubTotal_Cash',        2,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=1;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
     SELECT 'SubTotal_Margin',        2,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=2;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
     SELECT  'SubTotal_House',        2,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=0;
INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_2;
INSERT INTO tmp_rpt_set SELECT * FROM tmp_rpt;


-- USD.
drop temporary table if exists tmp1; 
create temporary table tmp1 
SELECT 
    account_id, SUM(IF(purpose=1,amount,0)-IF(purpose=2,amount,0))AS amt 
FROM cash_flow_cit 
WHERE process_date<=i_process_date AND currency=4 and account_id in (select account_id from tmp_acct) 
GROUP BY account_id;
create index idx on tmp1(account_id);

truncate table tmp_rpt;
INSERT INTO tmp_rpt(  process_date,   account_id, account_name,   account_type,   currency,      balance_t0,    net_balance,                                            accrued_interest, uncleared_amount,   mkt_value_t0)
SELECT a.process_date, a.account_id, replace(b.short_name,',',' '), a.account_type, a.currency,a.settle_balance,a.trade_balance-IFNULL(c.amt,0),a.accrued_interest_credit-a.accrued_interest,                0, ifnull(e.market_value,0)
FROM account_balance a LEFT JOIN account_profile b ON a.account_id=b.account_id 
LEFT JOIN tmp1 c ON a.account_id=c.account_id 
left join tmp2 e on e.account_id = a.account_id and e.currency = a.currency
WHERE i_process_date=a.process_date AND 
      a.account_id in (select account_id from tmp_acct) and 
      a.account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND 
      a.currency=4;

drop temporary table if exists tmp; 
create temporary table tmp 
SELECT account_id, SUM(IF(buy_sell = 1, -1, 1) * net_amount) AS net_amount 
FROM account_trade WHERE settle_date=v_date_us_t1 and account_id in (select account_id from tmp_acct) AND account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND clearing_currency=4 and status = 'Confirmed' GROUP BY account_id;
create index idx on tmp(account_id);


UPDATE tmp_rpt a
inner join tmp b on a.account_id=b.account_id
SET a.pend_settle_t1=b.net_amount ;

UPDATE tmp_rpt SET pend_settle_t1 = IFNULL(pend_settle_t1,0), 
                   pend_settle_t2 = IFNULL(pend_settle_t2,0),
                       balance_t1 = balance_t0 + IFNULL(pend_settle_t1,0),
                    net_avail_bal = net_balance + accrued_interest;

delete from tmp_rpt_2;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest, data_type)
              SELECT  'Debit',        4, SUM(IF(balance_t0<0,balance_t0,0)),SUM(IF(pend_settle_t1<0,pend_settle_t1,0)),SUM(IF(balance_t1<0,balance_t1,0)),SUM(IF(pend_settle_t2<0,pend_settle_t2,0)),SUM(IF(net_balance<0,net_balance,0)),SUM(IF(accrued_interest<0,accrued_interest,0)),2 FROM tmp_rpt;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest, data_type)
              SELECT 'Credit',        4, SUM(IF(balance_t0>0,balance_t0,0)),SUM(IF(pend_settle_t1>0,pend_settle_t1,0)),SUM(IF(balance_t1>0,balance_t1,0)),SUM(IF(pend_settle_t2>0,pend_settle_t2,0)),SUM(IF(net_balance>0,net_balance,0)),SUM(IF(accrued_interest>0,accrued_interest,0)),2 FROM tmp_rpt;

drop temporary table if exists tmp; 
create temporary table tmp
SELECT IF(buy_sell=1,'Debit','Credit')AS memo, SUM(IF(buy_sell=1,-1,1)*net_amount)AS net_amount 
FROM account_trade 
WHERE settle_date=v_date_us_t1 and account_id in (select account_id from tmp_acct) AND account_type IN(IF(i_account_type='',0,i_account_type),IF(i_account_type='',1,i_account_type),IF(i_account_type='',2,i_account_type),IF(i_account_type='','',i_account_type)) AND clearing_currency=4 and STATUS='Confirmed' 
GROUP BY buy_sell;
create index idx1 on tmp(memo);

UPDATE tmp_rpt_2 dst
inner join tmp src on dst.ae_code=src.memo
SET dst.pend_settle_t1=net_amount ;

UPDATE tmp_rpt_2 dst SET dst.pend_settle_t2=0;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
            SELECT 'SubTotal',        4,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
       SELECT 'SubTotal_Cash',        4,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=1;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
     SELECT 'SubTotal_Margin',        4,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=2;
INSERT INTO tmp_rpt_2(ae_code, currency,                         balance_t0,                            pend_settle_t1,                        balance_t1,                            pend_settle_t2,                         net_balance,                             accrued_interest,      uncleared_amount,     net_avail_bal,    mkt_value_t0, data_type)
     SELECT  'SubTotal_House',        4,                    SUM(balance_t0),                       SUM(pend_settle_t1),                   SUM(balance_t1),                       SUM(pend_settle_t2),                    SUM(net_balance),                         SUM(accrued_interest),SUM(uncleared_amount),SUM(net_avail_bal),SUM(mkt_value_t0),3 FROM tmp_rpt WHERE account_type=0;
INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_2;
INSERT INTO tmp_rpt_set SELECT * FROM tmp_rpt;


SELECT * FROM tmp_rpt_set;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientFundInOutListing
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientFundInOutListing`;
delimiter ;;
CREATE PROCEDURE `proExportClientFundInOutListing`(IN i_process_date DATE,
    IN i_account_type varchar(16),
    IN i_status varchar(16),
    IN i_order varchar(16))
label:BEGIN
 
    declare v_done int; 
    DECLARE v_currency varchar(16);
    DECLARE v_ccy varchar(16);
    DECLARE v_tmp_ccy varchar(16);
    DECLARE v_rec_bank_id varchar(32);
    DECLARE v_rec_bank varchar(64);
    DECLARE v_rec_bank_account_id varchar(32);
    DECLARE v_gl_mapping_item_id varchar(64);
    DECLARE v_reference varchar(128);

    DECLARE cur_cash CURSOR FOR 
    select currency,rec_bank_id,rec_bank_account_id,substring(gl_mapping_item_id,1,8),
        	if(substring(gl_mapping_item_id,1,8) = 'accrued_',substring(gl_mapping_item_id,1,8),substring(reference,1,8)) as reference
    from tmp_cash_flow 
    where process_date = i_process_date 
    group by currency,rec_bank_id,rec_bank_account_id,substring(gl_mapping_item_id,1,8),
        	if(substring(gl_mapping_item_id,1,8) = 'accrued_',substring(gl_mapping_item_id,1,8),substring(reference,1,8))
    order by currency,if(rec_bank_id='',1,0),rec_bank_id,rec_bank_account_id,
        if(substring(reference,1,8)='',1,0),substring(reference,1,8),if(substring(gl_mapping_item_id,1,8)='',1,0),substring(gl_mapping_item_id,1,8);

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1; 
    
    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    
    drop temporary table IF EXISTS tmp_cash_flow;
    CREATE TEMPORARY TABLE tmp_cash_flow 
    (
        `id` BIGINT(11) NOT NULL AUTO_INCREMENT,
        `process_date` DATE NULL DEFAULT NULL,
        `account_id` VARCHAR(16) NULL DEFAULT NULL,
        `currency` INT(11) NULL DEFAULT NULL,
        `amount` DECIMAL(21,6) NULL DEFAULT NULL,
        `purpose` INT(11) NULL DEFAULT NULL,
        `remark` VARCHAR(128) NULL DEFAULT NULL,
        `rec_bank_id` VARCHAR(32) NULL DEFAULT NULL,
        `rec_bank_account_id` VARCHAR(32) NULL DEFAULT NULL,
        `gl_mapping_item_id` VARCHAR(64) NULL DEFAULT NULL,
        `reference`   VARCHAR(128) NULL DEFAULT NULL,
        `update_user` CHAR(32) NULL DEFAULT NULL,
        `update_time` DATETIME NULL DEFAULT NULL,
        PRIMARY KEY (`id`),
        INDEX `idx1` (`process_date`, `account_id`, `currency`, `remark`)
    );

    insert into tmp_cash_flow
    select 
        a.id,
        a.process_date,
        a.account_id,
        currency,
        amount,
        purpose,
        remark,
        ifnull(rec_bank_id,''),
        ifnull(rec_bank_account_id,''),
        ifnull(gl_mapping_item_id,''),
        ifnull(reference,''),
        a.update_user,
        a.update_time
    from cash_flow a
    inner join capital_account b on a.account_id = b.account_id and (i_account_type = '' or b.account_type = i_account_type) 
    where process_date = i_process_date and 
        (i_status = '' or status = i_status) and 
        amount <> 0;

    drop temporary table IF EXISTS tmp_export;
    CREATE TEMPORARY TABLE tmp_export 
    (
        `Tran_Date` VARCHAR(32) NULL DEFAULT NULL,
        `Avail_Date` VARCHAR(32) NULL DEFAULT NULL,
        `Tran_code` VARCHAR(16) NULL DEFAULT NULL,
        `account_id` VARCHAR(16) NULL DEFAULT NULL,
        `short_name` VARCHAR(128) NULL DEFAULT NULL,
        `currency` VARCHAR(64) NULL DEFAULT NULL,
        `currency1` VARCHAR(16) NULL DEFAULT NULL,
        `deposit` VARCHAR(32) NULL DEFAULT NULL,
        `withdraw` VARCHAR(32) NULL DEFAULT NULL,
        `type` VARCHAR(16) NULL DEFAULT NULL,
        `cheque` VARCHAR(16) NULL DEFAULT NULL,
        `remark` CHAR(128) NULL DEFAULT NULL,
        `sum_amount` VARCHAR(32) NULL DEFAULT NULL,
        `inputuser` VARCHAR(32) NULL DEFAULT NULL,
        `inputtime` VARCHAR(32) NULL DEFAULT NULL
    );

    drop temporary table IF EXISTS tmp_export_sum;
    CREATE TEMPORARY TABLE tmp_export_sum 
    (
        `Tran_Date` DATE NULL DEFAULT NULL,
        `Avail_Date` DATE NULL DEFAULT NULL,
        `Tran_code` VARCHAR(16) NULL DEFAULT NULL,
        `account_id` VARCHAR(16) NULL DEFAULT NULL,
        `short_name` VARCHAR(128) NULL DEFAULT NULL,
        `currency` VARCHAR(16) NULL DEFAULT NULL,
        `deposit` DECIMAL(21,6) NULL DEFAULT NULL,
        `withdraw` DECIMAL(21,6) NULL DEFAULT NULL,
        `type` VARCHAR(16) NULL DEFAULT NULL,
        `remark` VARCHAR(128) NULL DEFAULT NULL,
        `rec_bank_id` VARCHAR(32) NULL DEFAULT NULL,
        `rec_bank_account_id` VARCHAR(32) NULL DEFAULT NULL,
        `gl_mapping_item_id` VARCHAR(64) NULL DEFAULT NULL,
        `reference`   VARCHAR(128) NULL DEFAULT NULL,
        `inputuser` VARCHAR(32) NULL DEFAULT NULL,
        `inputtime` DATETIME NULL DEFAULT NULL
    );

    insert into tmp_export
        select
            'Tran.Date',
            'Avail.Date',
            'Tran.Code',
            'Client A/C',
            '',
            '',
            '',
            'Deposit',
            'Withdraw',
            'Type',
            'Cheque no.',
            'Remark',
            '',
            'Input User',
            'Input Time';


    set v_tmp_ccy = '';
    delete from tmp_export_sum;
    open cur_cash; 
    set v_done = 0; 
    fetch cur_cash into v_currency,v_rec_bank_id,v_rec_bank_account_id,v_gl_mapping_item_id,v_reference; 
    while v_done <> 1 do 

        if v_tmp_ccy <> '' and v_currency <>  v_tmp_ccy then
            insert into tmp_export
            select
            '','','','','','Total',
            v_ccy,
            sum(round(deposit,2)),sum(round(withdraw,2)),
            '','Net Amount','',sum(round(deposit,2))-sum(round(withdraw,2)),'',''
            from tmp_export_sum a where a.Tran_Date = i_process_date and a.currency = v_tmp_ccy;

            delete from tmp_export_sum;
        end if;

        set v_tmp_ccy = v_currency;
        set v_ccy = case v_currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end;
        set v_rec_bank = concat(v_rec_bank_id,':',v_ccy,':',v_rec_bank_account_id);
        insert into tmp_export
        select
            'Bank a/c',
            if(v_rec_bank_id = '', '', v_rec_bank),
            '','','','','','','','','','','','','';

        if v_gl_mapping_item_id = 'OTH:Acct' then 
            
            insert into tmp_export_sum
            select 
                a.process_date,
                a.process_date,
                a.id,
                a.account_id,
                replace(b.short_name,',',' '),
                a.currency,
                if(a.purpose = 1,a.amount,0),
                if(a.purpose = 2,a.amount,0),
                case a.purpose when 1 then if(a.rec_bank_id <> '','IN_TR','IN_OTHER') when 2 then if(a.rec_bank_id <> '','OUT_TR','OUT_OTHER') end,
                a.remark,
                a.rec_bank_id,
                a.rec_bank_account_id,
                a.gl_mapping_item_id,
                a.reference,
                a.update_user,
                a.update_time
            from tmp_cash_flow a
            inner join account_profile b on b.account_id = a.account_id 
            where a.process_date = i_process_date and a.currency = v_currency and 
                a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and
                substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                substring(reference,1,8) = v_reference and a.remark like '提款;%';

            if i_order = '' then 
                insert into tmp_export
                select 
                Tran_Date,
                Avail_Date,
                Tran_code,
                account_id,
                short_name,
                '',
                v_ccy,
                if(round(deposit,2) = 0,'',round(deposit,2)),
                if(round(withdraw,2) = 0,'',round(withdraw,2)),
                type,
                '',
                remark,
                '',
                inputuser,
                inputtime
                from tmp_export_sum a 
                where a.Tran_Date = i_process_date and a.currency = v_currency and 
                    a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and 
                    substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                    if(v_gl_mapping_item_id = 'accrued_', 1=1 ,substring(reference,1,8) = v_reference) and a.remark like '提款;%'
                order by remark,type,account_id;
            else 
                insert into tmp_export
                select 
                Tran_Date,
                Avail_Date,
                Tran_code,
                account_id,
                short_name,
                '',
                v_ccy,
                if(round(deposit,2) = 0,'',round(deposit,2)),
                if(round(withdraw,2) = 0,'',round(withdraw,2)),
                type,
                '',
                remark,
                '',
                inputuser,
                inputtime
                from tmp_export_sum a 
                where a.Tran_Date = i_process_date and a.currency = v_currency and 
                    a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and 
                    substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                    if(v_gl_mapping_item_id = 'accrued_', 1=1 ,substring(reference,1,8) = v_reference) and a.remark like '提款;%'
                order by remark,Tran_code;
            end if;

            insert into tmp_export
            select
            '','','','','',
            if(a.rec_bank_id = '',v_ccy,v_rec_bank),
            v_ccy,
            sum(round(deposit,2)),sum(round(withdraw,2)),
            '','Net Amount','',sum(round(deposit,2))-sum(round(withdraw,2)),'',''
            from tmp_export_sum a 
            where a.Tran_Date = i_process_date and a.currency = v_currency and
                a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and 
                substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                if(v_gl_mapping_item_id = 'accrued_', 1=1 ,substring(reference,1,8) = v_reference) and a.remark like '提款;%'
            group by a.currency;

            insert into tmp_export_sum
            select 
                a.process_date,
                a.process_date,
                a.id,
                a.account_id,
                replace(b.short_name,',',' '),
                a.currency,
                if(a.purpose = 1,a.amount,0),
                if(a.purpose = 2,a.amount,0),
                case a.purpose when 1 then if(a.rec_bank_id <> '','IN_TR','IN_OTHER') when 2 then if(a.rec_bank_id <> '','OUT_TR','OUT_OTHER') end,
                a.remark,
                a.rec_bank_id,
                a.rec_bank_account_id,
                a.gl_mapping_item_id,
                a.reference,
                a.update_user,
                a.update_time
            from tmp_cash_flow a
            inner join account_profile b on b.account_id = a.account_id 
            where a.process_date = i_process_date and a.currency = v_currency and 
                a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and
                substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                substring(reference,1,8) = v_reference and a.remark like '账户管理费;%';

            if i_order = '' then 
                insert into tmp_export
                select 
                Tran_Date,
                Avail_Date,
                Tran_code,
                account_id,
                short_name,
                '',
                v_ccy,
                if(round(deposit,2) = 0,'',round(deposit,2)),
                if(round(withdraw,2) = 0,'',round(withdraw,2)),
                type,
                '',
                remark,
                '',
                inputuser,
                inputtime
                from tmp_export_sum a 
                where a.Tran_Date = i_process_date and a.currency = v_currency and 
                    a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and 
                    substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                    if(v_gl_mapping_item_id = 'accrued_', 1=1 ,substring(reference,1,8) = v_reference) and a.remark like '账户管理费;%'
                order by remark,type,account_id;
            else 
                insert into tmp_export
                select 
                Tran_Date,
                Avail_Date,
                Tran_code,
                account_id,
                short_name,
                '',
                v_ccy,
                if(round(deposit,2) = 0,'',round(deposit,2)),
                if(round(withdraw,2) = 0,'',round(withdraw,2)),
                type,
                '',
                remark,
                '',
                inputuser,
                inputtime
                from tmp_export_sum a 
                where a.Tran_Date = i_process_date and a.currency = v_currency and 
                    a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and 
                    substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                    if(v_gl_mapping_item_id = 'accrued_', 1=1 ,substring(reference,1,8) = v_reference) and a.remark like '账户管理费;%'
                order by remark,Tran_code;
            end if;

            insert into tmp_export
            select
            '','','','','',
            if(a.rec_bank_id = '',v_ccy,v_rec_bank),
            v_ccy,
            sum(round(deposit,2)),sum(round(withdraw,2)),
            '','Net Amount','',sum(round(deposit,2))-sum(round(withdraw,2)),'',''
            from tmp_export_sum a 
            where a.Tran_Date = i_process_date and a.currency = v_currency and
                a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and 
                substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                if(v_gl_mapping_item_id = 'accrued_', 1=1 ,substring(reference,1,8) = v_reference) and a.remark like '账户管理费;%'
            group by a.currency;

            insert into tmp_export_sum
            select 
                a.process_date,
                a.process_date,
                a.id,
                a.account_id,
                replace(b.short_name,',',' '),
                a.currency,
                if(a.purpose = 1,a.amount,0),
                if(a.purpose = 2,a.amount,0),
                case a.purpose when 1 then if(a.rec_bank_id <> '','IN_TR','IN_OTHER') when 2 then if(a.rec_bank_id <> '','OUT_TR','OUT_OTHER') end,
                a.remark,
                a.rec_bank_id,
                a.rec_bank_account_id,
                a.gl_mapping_item_id,
                a.reference,
                a.update_user,
                a.update_time
            from tmp_cash_flow a
            inner join account_profile b on b.account_id = a.account_id 
            where a.process_date = i_process_date and a.currency = v_currency and 
                a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and
                substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                substring(reference,1,8) = v_reference and a.remark not like '账户管理费;%' and a.remark not like '提款;%';

            if i_order = '' then 
                insert into tmp_export
                select 
                Tran_Date,
                Avail_Date,
                Tran_code,
                account_id,
                short_name,
                '',
                v_ccy,
                if(round(deposit,2) = 0,'',round(deposit,2)),
                if(round(withdraw,2) = 0,'',round(withdraw,2)),
                type,
                '',
                remark,
                '',
                inputuser,
                inputtime
                from tmp_export_sum a 
                where a.Tran_Date = i_process_date and a.currency = v_currency and 
                    a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and 
                    substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                    if(v_gl_mapping_item_id = 'accrued_', 1=1 ,substring(reference,1,8) = v_reference) and a.remark not like '账户管理费;%'  and a.remark not like '提款;%'
                order by remark,type,account_id;
            else 
                insert into tmp_export
                select 
                Tran_Date,
                Avail_Date,
                Tran_code,
                account_id,
                short_name,
                '',
                v_ccy,
                if(round(deposit,2) = 0,'',round(deposit,2)),
                if(round(withdraw,2) = 0,'',round(withdraw,2)),
                type,
                '',
                remark,
                '',
                inputuser,
                inputtime
                from tmp_export_sum a 
                where a.Tran_Date = i_process_date and a.currency = v_currency and 
                    a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and 
                    substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                    if(v_gl_mapping_item_id = 'accrued_', 1=1 ,substring(reference,1,8) = v_reference) and a.remark not like '账户管理费;%' and a.remark not like '提款;%'
                order by remark,Tran_code;
            end if;

            insert into tmp_export
            select
            '','','','','',
            if(a.rec_bank_id = '',v_ccy,v_rec_bank),
            v_ccy,
            sum(round(deposit,2)),sum(round(withdraw,2)),
            '','Net Amount','',sum(round(deposit,2))-sum(round(withdraw,2)),'',''
            from tmp_export_sum a 
            where a.Tran_Date = i_process_date and a.currency = v_currency and
                a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and 
                substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                if(v_gl_mapping_item_id = 'accrued_', 1=1 ,substring(reference,1,8) = v_reference) and a.remark not like '账户管理费;%' and a.remark not like '提款;%'
            group by a.currency;
        elseif v_gl_mapping_item_id = '' then 
            insert into tmp_export_sum
            select 
                a.process_date,
                a.process_date,
                a.id,
                a.account_id,
                replace(b.short_name,',',' '),
                a.currency,
                if(a.purpose = 1,a.amount,0),
                if(a.purpose = 2,a.amount,0),
                case a.purpose when 1 then if(a.rec_bank_id <> '','IN_TR','IN_OTHER') when 2 then if(a.rec_bank_id <> '','OUT_TR','OUT_OTHER') end,
                a.remark,
                a.rec_bank_id,
                a.rec_bank_account_id,
                a.gl_mapping_item_id,
                a.reference,
                a.update_user,
                a.update_time
            from tmp_cash_flow a
            inner join account_profile b on b.account_id = a.account_id 
            where a.process_date = i_process_date and a.currency = v_currency and 
                a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and
                substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                substring(reference,1,8) = v_reference and a.remark like '自动货币兑换%';

            if i_order = '' then 
                insert into tmp_export
                select 
                Tran_Date,
                Avail_Date,
                Tran_code,
                account_id,
                short_name,
                '',
                v_ccy,
                if(round(deposit,2) = 0,'',round(deposit,2)),
                if(round(withdraw,2) = 0,'',round(withdraw,2)),
                type,
                '',
                remark,
                '',
                inputuser,
                inputtime
                from tmp_export_sum a 
                where a.Tran_Date = i_process_date and a.currency = v_currency and 
                    a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and 
                    substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                    if(v_gl_mapping_item_id = 'accrued_', 1=1 ,substring(reference,1,8) = v_reference) and a.remark like '自动货币兑换%'
                order by remark,type,account_id;
            else 
                insert into tmp_export
                select 
                Tran_Date,
                Avail_Date,
                Tran_code,
                account_id,
                short_name,
                '',
                v_ccy,
                if(round(deposit,2) = 0,'',round(deposit,2)),
                if(round(withdraw,2) = 0,'',round(withdraw,2)),
                type,
                '',
                remark,
                '',
                inputuser,
                inputtime
                from tmp_export_sum a 
                where a.Tran_Date = i_process_date and a.currency = v_currency and 
                    a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and 
                    substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                    if(v_gl_mapping_item_id = 'accrued_', 1=1 ,substring(reference,1,8) = v_reference) and a.remark like '自动货币兑换%'
                order by remark,Tran_code;
            end if;

            insert into tmp_export
            select
            '','','','','',
            if(a.rec_bank_id = '',v_ccy,v_rec_bank),
            v_ccy,
            sum(round(deposit,2)),sum(round(withdraw,2)),
            '','Net Amount','',sum(round(deposit,2))-sum(round(withdraw,2)),'',''
            from tmp_export_sum a 
            where a.Tran_Date = i_process_date and a.currency = v_currency and
                a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and 
                substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                if(v_gl_mapping_item_id = 'accrued_', 1=1 ,substring(reference,1,8) = v_reference) and a.remark like '自动货币兑换%'
            group by a.currency;

            insert into tmp_export_sum
            select 
                a.process_date,
                a.process_date,
                a.id,
                a.account_id,
                replace(b.short_name,',',' '),
                a.currency,
                if(a.purpose = 1,a.amount,0),
                if(a.purpose = 2,a.amount,0),
                case a.purpose when 1 then if(a.rec_bank_id <> '','IN_TR','IN_OTHER') when 2 then if(a.rec_bank_id <> '','OUT_TR','OUT_OTHER') end,
                a.remark,
                a.rec_bank_id,
                a.rec_bank_account_id,
                a.gl_mapping_item_id,
                a.reference,
                a.update_user,
                a.update_time
            from tmp_cash_flow a
            inner join account_profile b on b.account_id = a.account_id 
            where a.process_date = i_process_date and a.currency = v_currency and 
                a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and
                substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                substring(reference,1,8) = v_reference and a.remark not like '自动货币兑换%';

            if i_order = '' then 
                insert into tmp_export
                select 
                Tran_Date,
                Avail_Date,
                Tran_code,
                account_id,
                short_name,
                '',
                v_ccy,
                if(round(deposit,2) = 0,'',round(deposit,2)),
                if(round(withdraw,2) = 0,'',round(withdraw,2)),
                type,
                '',
                remark,
                '',
                inputuser,
                inputtime
                from tmp_export_sum a 
                where a.Tran_Date = i_process_date and a.currency = v_currency and 
                    a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and 
                    substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                    if(v_gl_mapping_item_id = 'accrued_', 1=1 ,substring(reference,1,8) = v_reference) and a.remark not like '自动货币兑换%'
                order by remark,type,account_id;
            else 
                insert into tmp_export
                select 
                Tran_Date,
                Avail_Date,
                Tran_code,
                account_id,
                short_name,
                '',
                v_ccy,
                if(round(deposit,2) = 0,'',round(deposit,2)),
                if(round(withdraw,2) = 0,'',round(withdraw,2)),
                type,
                '',
                remark,
                '',
                inputuser,
                inputtime
                from tmp_export_sum a 
                where a.Tran_Date = i_process_date and a.currency = v_currency and 
                    a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and 
                    substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                    if(v_gl_mapping_item_id = 'accrued_', 1=1 ,substring(reference,1,8) = v_reference) and a.remark not like '自动货币兑换%'
                order by remark,Tran_code;
            end if;

            insert into tmp_export
            select
            '','','','','',
            if(a.rec_bank_id = '',v_ccy,v_rec_bank),
            v_ccy,
            sum(round(deposit,2)),sum(round(withdraw,2)),
            '','Net Amount','',sum(round(deposit,2))-sum(round(withdraw,2)),'',''
            from tmp_export_sum a 
            where a.Tran_Date = i_process_date and a.currency = v_currency and
                a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and 
                substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                if(v_gl_mapping_item_id = 'accrued_', 1=1 ,substring(reference,1,8) = v_reference) and a.remark not like '自动货币兑换%'
            group by a.currency;
        else 
            insert into tmp_export_sum
            select 
                a.process_date,
                a.process_date,
                a.id,
                a.account_id,
                replace(b.short_name,',',' '),
                a.currency,
                if(a.purpose = 1,a.amount,0),
                if(a.purpose = 2,a.amount,0),
                case a.purpose when 1 then if(a.rec_bank_id <> '','IN_TR','IN_OTHER') when 2 then if(a.rec_bank_id <> '','OUT_TR','OUT_OTHER') end,
                a.remark,
                a.rec_bank_id,
                a.rec_bank_account_id,
                a.gl_mapping_item_id,
                a.reference,
                a.update_user,
                a.update_time
            from tmp_cash_flow a
            inner join account_profile b on b.account_id = a.account_id 
            where a.process_date = i_process_date and a.currency = v_currency and 
                a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and
                substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                (case when v_gl_mapping_item_id = 'accrued_' then 1=1 else substring(reference,1,8) = v_reference end);

            if i_order = '' then 
                insert into tmp_export
                select 
                Tran_Date,
                Avail_Date,
                Tran_code,
                account_id,
                short_name,
                '',
                v_ccy,
                if(round(deposit,2) = 0,'',round(deposit,2)),
                if(round(withdraw,2) = 0,'',round(withdraw,2)),
                type,
                '',
                remark,
                '',
                inputuser,
                inputtime
                from tmp_export_sum a 
                where a.Tran_Date = i_process_date and a.currency = v_currency and 
                    a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and 
                    substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                    if(v_gl_mapping_item_id = 'accrued_', 1=1 ,substring(reference,1,8) = v_reference)
                order by remark,type,account_id;
            else 
                insert into tmp_export
                select 
                Tran_Date,
                Avail_Date,
                Tran_code,
                account_id,
                short_name,
                '',
                v_ccy,
                if(round(deposit,2) = 0,'',round(deposit,2)),
                if(round(withdraw,2) = 0,'',round(withdraw,2)),
                type,
                '',
                remark,
                '',
                inputuser,
                inputtime
                from tmp_export_sum a 
                where a.Tran_Date = i_process_date and a.currency = v_currency and 
                    a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and 
                    substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                    if(v_gl_mapping_item_id = 'accrued_', 1=1 ,substring(reference,1,8) = v_reference)
                order by remark,Tran_code;
            end if;

            insert into tmp_export
            select
                '','','','','',
                if(a.rec_bank_id = '',v_ccy,v_rec_bank),
                v_ccy,
                sum(round(deposit,2)),sum(round(withdraw,2)),
                '','Net Amount','',sum(round(deposit,2))-sum(round(withdraw,2)),'',''
            from tmp_export_sum a 
            where a.Tran_Date = i_process_date and a.currency = v_currency and
                a.rec_bank_id = v_rec_bank_id and a.rec_bank_account_id = v_rec_bank_account_id and 
                substring(gl_mapping_item_id,1,8) = v_gl_mapping_item_id and 
                if(v_gl_mapping_item_id = 'accrued_', 1=1 ,substring(reference,1,8) = v_reference)
            group by a.currency;
        end if;

        set v_done = 0; 
        fetch cur_cash into v_currency,v_rec_bank_id,v_rec_bank_account_id,v_gl_mapping_item_id,v_reference; 
    end while; 
    close cur_cash;

    insert into tmp_export
    select
        '','','','','','Total',
        v_ccy,
        sum(round(deposit,2)),sum(round(withdraw,2)),
        '','Net Amount','',sum(round(deposit,2))-sum(round(withdraw,2)),'',''
    from tmp_export_sum a where a.Tran_Date = i_process_date and a.currency = v_tmp_ccy;

    select * from tmp_export a;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientFundInOutListingQuery
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientFundInOutListingQuery`;
delimiter ;;
CREATE PROCEDURE `proExportClientFundInOutListingQuery`(IN i_date_beg   DATE,
    IN i_date_end   DATE,
    IN i_account_id VARCHAR(32),
    IN i_remark     VARCHAR(128))
label:BEGIN

SELECT
a.id,
a.process_date,
a.account_id,
 concat('"',b.short_name,'"'),
CONCAT(a.currency,'(',CASE a.currency WHEN 1 THEN 'CNY' WHEN 2 THEN 'HKD' WHEN 4 THEN 'USD' ELSE a.currency END,')') AS currency,
a.amount,
-- CONCAT(a.way,'(',CASE a.way WHEN 1 THEN 'Cash' WHEN 2 THEN 'Check' WHEN 3 THEN 'Online' ELSE a.way END,')')AS way,
CONCAT(a.purpose,'(',CASE a.purpose WHEN 1 THEN 'CashIn' WHEN 2 THEN 'CashOut' WHEN 3 THEN 'Internal' ELSE a.purpose END,')')AS purpose,
REPLACE(a.remark,',',' ')AS remark,
a.pay_bank_id,
a.pay_check_no,
a.pay_bank_account_name,
a.pay_bank_account_id,
a.rec_bank_id,
a.rec_check_no,
a.rec_bank_account_name,
a.rec_bank_account_id,
a.update_user,
a.update_time,
a.dividend_market_id,
a.dividend_product_id,
a.gl_mapping_item_id,
a.status
FROM cash_flow a LEFT JOIN account_profile b ON a.account_id=b.account_id
WHERE i_date_beg<=a.process_date AND a.process_date<=i_date_end AND a.status='Confirmed'
AND (i_account_id = '' OR a.account_id = i_account_id)
AND (i_remark     = '' OR a.remark LIKE i_remark)
ORDER BY a.process_date,a.account_id,a.update_time;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientInformationListing
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientInformationListing`;
delimiter ;;
CREATE PROCEDURE `proExportClientInformationListing`()
label:BEGIN

    drop temporary table IF EXISTS tmp_account_trade;
    CREATE TEMPORARY TABLE tmp_account_trade
    (
        account_id VARCHAR(32),
        process_date DATE,
        PRIMARY KEY(account_id)
    ); 
    insert into tmp_account_trade
    select account_id,max(process_date) as process_date 
    from account_trade where status = 'Confirmed' group by account_id order by account_id ;

    -- drop temporary table IF EXISTS tmp_flow;
    -- CREATE TEMPORARY TABLE tmp_flow
    -- (
    --     account_id VARCHAR(32),
    --     process_date DATE,
    --     INDEX idx1(account_id)
    -- );
    -- insert into tmp_flow
    -- select account_id,max(process_date) as process_date from cash_flow group by account_id
    -- union all
    -- select account_id,max(process_date) as process_date from product_flow group by account_id
    -- union all 
    -- select table_key_value as account_id,max(process_date) as process_date from audit_trail where table_id in ('account_profile','capital_account') group by table_key_value;

    drop temporary table IF EXISTS tmp_sum_flow;
    CREATE TEMPORARY TABLE tmp_sum_flow
    (
        account_id VARCHAR(32),
        process_date DATE,
        PRIMARY KEY(account_id)
    );
    insert into tmp_sum_flow
    select 
        cp.account_id,
        max(cp.process_date) as process_date 
    from (
    select account_id,max(process_date) as process_date from cash_flow group by account_id
    union all
    select account_id,max(process_date) as process_date from product_flow group by account_id
    union all 
    select table_key_value as account_id,max(process_date) as process_date from audit_trail where table_id in ('account_profile','capital_account') group by table_key_value
    ) cp group by cp.account_id;

    select
        concat('''',a.account_id) as client_acc_id,
        case b.account_type when 0 then 'H' when 1 then 'C' when 2 then 'M' end as acc_type,
        replace(a.short_name,',',' ') as name,
        replace(a.short_name,',',' ') as payee_name,
        a.bank as payee_bank,
        a.bank_account_id as payee_bank_acc,
        concat('''',ifnull(a.photoid,a.partyid)) as id_code,
        b.ae_id as ae_code,
        replace(a.email_address,',',' ') as email,
        a.phone1 as phone,
        replace(a.mailing_address,',',' ') as addr,
        case a.gender when 1 then 'Mr' when 2 then 'Miss' else '' end as gender,
        a.birth_day as date_of_brith,
        case b.account_type when 0 then 'H' when 1 then 'C' when 2 then 'M' end as client_type,
        b.client_group_code as client_group_code,
        CONCAT(a.account_class,(CASE account_class WHEN '1' THEN '(公司)' WHEN '3' THEN '(个人)' ELSE '(?)' END) ) AS account_class,
        case when ifnull(b.auth_markets,'') & 1 = 1 then (case when b.client_group_code not in ('TEST','IPI','CDT','MDT','PI','SDT','H') then '否' else '是' end)
             else '否' end as Derivative,
        case when ifnull(b.auth_markets,'') & 12 = 12 then '是' else '否' end  as ZhongHuaTong,
        case when ifnull(b.auth_markets,'') & 2 = 2 then '是' else '否' end as US_stock,
        a.city as nationality,
        a.insert_time as sys_instime,
        a.update_time as sys_updtime,
        a.update_user as sys_user,
        a.phone2 as phone_home,
        a.phone3 as phone_office,
        a.country as country,
        a.country as residence,
        a.photoid_type as photoid_type,
        a.partyid_type as partyid_type,
        a.employment as employment_status,
        replace(a.employer_name,',',' ') as employer_name,
        replace(a.middle_name,',',' ') as middle_name,
        replace(a.last_name,',',' ') as last_name,
        replace(a.first_name,',',' ') as first_name,
        a.country as country_of_issue,
        replace(a.email_address,',',' ') as addr1,
        case a.`status` when 0 then 'A' when 1 then 'A' when 2 then 'C' when 3 then 'S' end as status,
        round(case when ifnull(b.loan_limit,'') = '' then ifnull(c.reject_limit,'') else ifnull(b.loan_limit,'') end,2) as loan_limit,
        concat(g.formula_code,':',g.formula_type) as hk_commission,
        case when ifnull(h.debit_formula_code,'') = '' then 'DEFAULT:DBINT' else concat(h.debit_formula_code,':DBINT') end as debit_hkd_interest,
        case when ifnull(h.credit_formula_code,'') = '' then 'HKD_SAV:CRINT' else concat(h.credit_formula_code,':DBINT') end as credit_hkd_interest,
        ifnull(e.process_date,'') as last_trade_date,
        ifnull(f.process_date,'') as last_activity_date,
        IFNULL(a.first_name_eng, '') AS first_name_eng,
        IFNULL(a.last_name_eng, '') AS last_name_eng
    from account_profile a 
    inner join capital_account b on a.account_id = b.account_id
    left join account_type_loan_limit c on c.account_type = b.account_type 
    left join tmp_account_trade e on e.account_id = a.account_id
    left join tmp_sum_flow f on f.account_id = a.account_id
    left join market_charge_rule g on g.market_id = 1 and g.formula_type = 'COMM'
    left join account_interest_rule h on h.account_id = a.account_id and h.currency = 2
    where a.account_id not in ('1010111','2030101','1111111111111')
    order by a.account_id;
    
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientInformationListingEmail
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientInformationListingEmail`;
delimiter ;;
CREATE PROCEDURE `proExportClientInformationListingEmail`()
label:BEGIN

    drop temporary table IF EXISTS tmp_account_trade;
    CREATE TEMPORARY TABLE tmp_account_trade
    (
        account_id VARCHAR(32),
        process_date DATE,
        PRIMARY KEY(account_id),
        index idx1(account_id)
    ); 
    insert into tmp_account_trade
    select account_id,max(process_date) as process_date 
    from account_trade where status = 'Confirmed' group by account_id order by account_id ;

    -- drop temporary table IF EXISTS tmp_flow;
    -- CREATE TEMPORARY TABLE tmp_flow
    -- (
    --     account_id VARCHAR(32),
    --     process_date DATE,
    --     INDEX idx1(account_id)
    -- );
    -- insert into tmp_flow
    -- select account_id,max(process_date) as process_date from cash_flow group by account_id
    -- union all
    -- select account_id,max(process_date) as process_date from product_flow group by account_id
    -- union all 
    -- select table_key_value as account_id,max(process_date) as process_date from audit_trail where table_id in ('account_profile','capital_account') group by table_key_value;

    drop temporary table IF EXISTS tmp_sum_flow;
    CREATE TEMPORARY TABLE tmp_sum_flow
    (
        account_id VARCHAR(32),
        process_date DATE,
        PRIMARY KEY(account_id),
        index idx1(account_id)
    );
    insert into tmp_sum_flow
    select 
        cp.account_id,
        max(cp.process_date) as process_date 
    from (
    select account_id,max(process_date) as process_date from cash_flow group by account_id
    union all
    select account_id,max(process_date) as process_date from product_flow group by account_id
    union all 
    select table_key_value as account_id,max(process_date) as process_date from audit_trail where table_id in ('account_profile','capital_account') group by table_key_value
    ) cp group by cp.account_id;

    drop temporary table IF EXISTS tmp_information_list;
    CREATE TEMPORARY TABLE tmp_information_list
    select
        concat('''',a.account_id) as client_acc_id,
        case b.account_type when 0 then 'H' when 1 then 'C' when 2 then 'M' end as acc_type,
        replace(a.short_name,',',' ') as name,
        replace(a.short_name,',',' ') as payee_name,
        a.bank as payee_bank,
        a.bank_account_id as payee_bank_acc,
        concat('''',ifnull(a.photoid,a.partyid)) as id_code,
        b.ae_id as ae_code,
        replace(a.email_address,',',' ') as email,
        a.phone1 as phone,
        replace(a.mailing_address,',',' ') as addr,
        case a.gender when 1 then 'Mr' when 2 then 'Miss' else '' end as gender,
        a.birth_day as date_of_brith,
        case b.account_type when 0 then 'H' when 1 then 'C' when 2 then 'M' end as client_type,
        b.client_group_code as client_group_code,
        CONCAT(a.account_class,(CASE account_class WHEN '1' THEN '(公司)' WHEN '3' THEN '(个人)' ELSE '(?)' END) ) AS account_class,
        case when ifnull(b.auth_markets,'') & 1 = 1 then (case when b.client_group_code not in ('TEST','IPI','CDT','MDT','PI','SDT','H') then '否' else '是' end)
             else '否' end as Derivative,
        case when ifnull(b.auth_markets,'') & 12 = 12 then '是' else '否' end  as ZhongHuaTong,
        case when ifnull(b.auth_markets,'') & 2 = 2 then '是' else '否' end as US_stock,
        a.city as nationality,
        a.insert_time as sys_instime,
        a.update_time as sys_updtime,
        a.update_user as sys_user,
        a.phone2 as phone_home,
        a.phone3 as phone_office,
        a.country as country,
        a.country as residence,
        a.photoid_type as photoid_type,
        a.partyid_type as partyid_type,
        a.employment as employment_status,
        replace(a.employer_name,',',' ') as employer_name,
        replace(a.middle_name,',',' ') as middle_name,
        replace(a.last_name,',',' ') as last_name,
        replace(a.first_name,',',' ') as first_name,
        a.country as country_of_issue,
        replace(a.email_address,',',' ') as addr1,
        case a.`status` when 0 then 'A' when 1 then 'A' when 2 then 'C' when 3 then 'S' end as status,
        round(case when ifnull(b.loan_limit,'') = '' then ifnull(c.reject_limit,'') else ifnull(b.loan_limit,'') end,2) as loan_limit,
        concat(g.formula_code,':',g.formula_type) as hk_commission,
        case when ifnull(h.debit_formula_code,'') = '' then 'DEFAULT:DBINT' else concat(h.debit_formula_code,':DBINT') end as debit_hkd_interest,
        case when ifnull(h.credit_formula_code,'') = '' then 'HKD_SAV:CRINT' else concat(h.credit_formula_code,':DBINT') end as credit_hkd_interest,
        ifnull(e.process_date,'') as last_trade_date,
        ifnull(f.process_date,'') as last_activity_date,
        IFNULL(a.first_name_eng, '') AS first_name_eng,
        IFNULL(a.last_name_eng, '') AS last_name_eng
    from account_profile a 
    inner join capital_account b on a.account_id = b.account_id
    left join account_type_loan_limit c on c.account_type = b.account_type 
    left join tmp_account_trade e on e.account_id = a.account_id
    left join tmp_sum_flow f on f.account_id = a.account_id
    left join market_charge_rule g on g.market_id = 1 and g.formula_type = 'COMM'
    left join account_interest_rule h on h.account_id = a.account_id and h.currency = 2
    where a.account_id not in ('1010111','2030101','1111111111111')
    order by a.account_id;

    drop temporary table IF EXISTS tmp_information_list2;
    CREATE TEMPORARY TABLE tmp_information_list2 as select * from tmp_information_list;
    create index idx1 on tmp_information_list(email);
    create index idx1 on tmp_information_list2(email);

    SELECT * FROM tmp_information_list WHERE email IN (SELECT email FROM tmp_information_list2 GROUP BY email HAVING(count(email) <> 1)) order by email;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientPortfolio
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientPortfolio`;
delimiter ;;
CREATE PROCEDURE `proExportClientPortfolio`(IN i_process_date DATE,
    IN i_account_type INT)
label:BEGIN

drop temporary table IF EXISTS cash_flow_cit_summary;
CREATE TEMPORARY TABLE cash_flow_cit_summary
(
    account_id VARCHAR(32),
    currency INT,
    amt DECIMAL(30,10),
    PRIMARY KEY(account_id,currency)
);
INSERT INTO cash_flow_cit_summary(account_id, currency, amt)
SELECT account_id, currency, SUM(IF(purpose=1,amount,0)-IF(purpose=2,amount,0))AS amt FROM cash_flow_cit 
    WHERE process_date<=i_process_date GROUP BY account_id,currency;

drop temporary table IF EXISTS tmp_rpt;
CREATE TEMPORARY TABLE tmp_rpt
(
    process_date DATE,
    ae_code    VARCHAR(32),
    account_id VARCHAR(32),
    short_name VARCHAR(256),
    account_type INT,
    currency INT,
    product_market_id INT,
    product_id VARCHAR(32),
    product_balance_t0 DECIMAL(20,2),
    product_net_balance DECIMAL(20,2),
    product_nominal DECIMAL(30,10),
    product_mkt_value_t0 DECIMAL(30,10),
    product_market_value DECIMAL(30,10),
    product_margin DECIMAL(30,10),
    product_margin_value_t0 DECIMAL(30,10),
    product_marginable_value DECIMAL(30,10),
    cash_balance_t0 DECIMAL(30,10),
    cash_net_balance DECIMAL(30,10),
    cash_accrued_interest DECIMAL(30,10),
    cash_uncleared DECIMAL(30,10),
    data_type INT,
    INDEX idx1(process_date,account_id,account_type,currency,product_market_id,product_id,data_type),
    index idx2(data_type)
);
INSERT INTO tmp_rpt(process_date,ae_code,account_id,short_name,account_type,currency,product_market_id,product_id,
                    product_balance_t0,product_net_balance,product_nominal,product_mkt_value_t0,product_market_value,
                    product_margin,product_margin_value_t0,product_marginable_value,data_type)
SELECT process_date,
'' AS ae_code,
a.account_id,
replace(c.short_name,',',' '),
a.account_type,
a.currency,
a.market_id AS product_market_id,
a.product_id AS product_id,
a.quantity AS product_balance_t0,
a.net_quantity AS product_net_balance,
a.closing_price AS product_nominal,
a.quantity*a.closing_price AS product_mkt_value_t0,
a.net_quantity*a.closing_price AS product_market_value, 
ifnull(b.loan_ratio,0) AS product_margin,
if(a.account_type = 1,0,ifnull(b.loan_ratio,0)*a.quantity*a.closing_price/100) AS product_margin_value_t0,
if(a.account_type = 1,0,ifnull(b.loan_ratio,0)*a.net_quantity*a.closing_price/100) AS product_marginable_value,
1 AS data_type
FROM account_position a 
LEFT JOIN product b ON a.market_id=b.list_market_id AND a.product_id=b.product_id
LEFT JOIN account_profile c ON a.account_id=c.account_id
WHERE a.process_date=i_process_date AND 
      a.account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type));

drop temporary table IF EXISTS tmp_rpt_2;
CREATE TEMPORARY TABLE tmp_rpt_2 SELECT * FROM tmp_rpt WHERE 1=2;

create index idx1 on tmp_rpt_2(process_date,account_id,account_type,currency,product_market_id,product_id,data_type);
create index idx2 on tmp_rpt_2(account_id, currency);

INSERT INTO tmp_rpt_2(account_id,currency,
                      product_balance_t0,product_net_balance,
                      product_mkt_value_t0,product_market_value,
                      product_margin_value_t0,product_marginable_value)
SELECT account_id,currency,
SUM(product_balance_t0),
SUM(product_net_balance),
SUM(product_mkt_value_t0),
SUM(product_market_value),
SUM(product_margin_value_t0),
SUM(product_marginable_value)
FROM tmp_rpt WHERE data_type=1 GROUP BY account_id,currency;

INSERT INTO tmp_rpt(process_date,ae_code,account_id,short_name,account_type,currency,
                    product_balance_t0,product_net_balance,
                    product_mkt_value_t0,product_market_value,product_margin_value_t0,product_marginable_value,
                    cash_balance_t0,cash_net_balance,cash_accrued_interest,cash_uncleared,data_type)
SELECT a.process_date,
'' AS ae_code,
a.account_id,
replace(c.short_name,',',' '),
a.account_type,
a.currency, 
b.product_balance_t0,
b.product_net_balance,
b.product_mkt_value_t0,
b.product_market_value,
b.product_margin_value_t0,
b.product_marginable_value,
a.settle_balance AS cash_balance_t0,
a.trade_balance-IFNULL(d.amt,0) AS cash_net_balance,
a.accrued_interest_credit-a.accrued_interest AS cash_accrued_interest,
0 AS cash_uncleared,
2 AS data_type
FROM account_balance a 
LEFT JOIN tmp_rpt_2 b ON a.account_id=b.account_id AND a.currency=b.currency
LEFT JOIN account_profile c ON a.account_id=c.account_id
LEFT JOIN cash_flow_cit_summary d ON a.account_id=d.account_id AND a.currency=d.currency
WHERE a.process_date=i_process_date AND 
      a.account_type IN(IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type),IF(i_account_type=0,0,i_account_type));

delete from tmp_rpt_2;
INSERT INTO tmp_rpt_2(process_date,ae_code,currency,
                    product_balance_t0,product_net_balance,
                    product_mkt_value_t0,product_market_value,product_margin_value_t0,product_marginable_value,
                    cash_balance_t0,cash_net_balance,cash_accrued_interest,cash_uncleared,data_type)
SELECT i_process_date,CONCAT('Total_',IF(currency=1,'CNY',IF(currency=2,'HKD','USD'))) AS ae_code,currency,
SUM(product_balance_t0),SUM(product_net_balance),
SUM(product_mkt_value_t0),SUM(product_market_value),SUM(product_margin_value_t0),SUM(product_marginable_value),
SUM(cash_balance_t0),SUM(cash_net_balance),SUM(cash_accrued_interest),SUM(cash_uncleared),
3 AS data_type
FROM tmp_rpt WHERE data_type=2 GROUP BY currency;
INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_2;

SELECT * FROM tmp_rpt WHERE data_type=3;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientProductInOutListing
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientProductInOutListing`;
delimiter ;;
CREATE PROCEDURE `proExportClientProductInOutListing`(IN i_process_date DATE)
label:BEGIN
 
    declare v_done int; 
    DECLARE v_Tran_code varchar(16);

    DECLARE cur_product CURSOR FOR 
    select Tran_code
    from tmp_product_flow 
    order by Tran_code;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1; 
    
    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    drop temporary table IF EXISTS tmp_export;
    CREATE TEMPORARY TABLE tmp_export 
    (
        `Tran_Date` VARCHAR(32) NULL DEFAULT NULL,
        `Avail_Date` VARCHAR(32) NULL DEFAULT NULL,
        `Tran_code` VARCHAR(16) NULL DEFAULT NULL,
        `Client_AC` VARCHAR(128) NULL DEFAULT NULL,
        `product_id` VARCHAR(256) NULL DEFAULT NULL,
        `custodian` VARCHAR(32) NULL DEFAULT NULL,
        `deposit` varchar(32) NULL DEFAULT NULL,
        `withdraw` varchar(32) NULL DEFAULT NULL,
        `remark` CHAR(128) NULL DEFAULT NULL,
        `nominee` varchar(7) NULL DEFAULT NULL,
        `inputuser` VARCHAR(32) NULL DEFAULT NULL,
        `inputtime` VARCHAR(32) NULL DEFAULT NULL
    );

    insert into tmp_export
        select
            'Tran.Date',
            'Avail.Date',
            'Tran.Code',
            'Client A/C',
            'Product',
            'Custodian a/c',
            'Deposit',
            'Withdraw',
            'Remark',
            'Nominee',
            'Input User',
            'Input Time';

    drop temporary table IF EXISTS tmp_product_flow;
    CREATE TEMPORARY TABLE tmp_product_flow 
    (
        `Tran_Date` DATE NULL DEFAULT NULL,
        `Avail_Date` DATE NULL DEFAULT NULL,
        `Tran_code` VARCHAR(16) NULL DEFAULT NULL,
        `account_id` VARCHAR(16) NULL DEFAULT NULL,
        `short_name` VARCHAR(128) NULL DEFAULT NULL,
        `product_id` VARCHAR(256) NULL DEFAULT NULL,
        `product_desc` VARCHAR(256) NULL DEFAULT NULL,
        `custodian` VARCHAR(32) NULL DEFAULT NULL,
        `deposit` DECIMAL(30,10) NULL DEFAULT NULL,
        `withdraw` DECIMAL(30,10) NULL DEFAULT NULL,
        `remark` CHAR(128) NULL DEFAULT NULL,
        `nominee` VARCHAR(1) NULL DEFAULT NULL,
        `inputuser` VARCHAR(32) NULL DEFAULT NULL,
        `inputtime` DATETIME NULL DEFAULT NULL,
        INDEX idx1(`Tran_code`)
    );

    insert into tmp_product_flow
    select 
        a.process_date,
        a.settle_date,
        a.id,
        a.account_id,
        replace(c.short_name,',',' '),
        concat(a.product_id,':',case a.market_id when 1 then 'HK' when 2 then 'US' when 4 then 'SHA' when 8 then 'SZA' when 16 then 'OTC' end) as product_id,
        replace(b.product_description,',',' '),
        concat(a.custodian_account,':',a.custodian_code) as custodian,
        case a.purpose when 1 then a.quantity else 0 end as deposit,
        case a.purpose when 2 then a.quantity else 0 end as withdraw,
        a.remark,
        case a.nominee_quantity when 0 then 'N' else 'Y' end as nominee,
        a.update_user,
        a.update_time
    from product_flow a
    inner join product b on a.market_id = b.list_market_id and a.product_id = b.product_id
    inner join account_profile c on c.account_id = a.account_id
    where a.process_date = i_process_date and a.status = 'Confirmed'
    order by a.id;

    open cur_product; 
    set v_done = 0; 
    fetch cur_product into v_Tran_code; 
    while v_done <> 1 do 

        insert into tmp_export
        select 
            Tran_Date,
            Avail_Date,
            Tran_code,
            account_id,
            product_id,
            custodian,
            case deposit when 0 then '' else round(deposit,0) end,
            case withdraw when 0 then '' else round(withdraw,0) end,
            remark,
            nominee,
            inputuser,
            inputtime
        from tmp_product_flow where Tran_code = v_Tran_code;

        insert into tmp_export
        select '','','',short_name,product_desc,'','','','','','',''
        from tmp_product_flow where Tran_code = v_Tran_code;

        set v_done = 0; 
        fetch cur_product into v_Tran_code; 
    end while; 
    close cur_product;

    insert into tmp_export
    select 
    '','','','','','',round(sum(deposit),0),round(sum(withdraw),0),'','','','' from tmp_product_flow;

    select * from tmp_export a;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientProductInOutListingQuery
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientProductInOutListingQuery`;
delimiter ;;
CREATE PROCEDURE `proExportClientProductInOutListingQuery`(IN i_date_beg   DATE,
    IN i_date_end   DATE,
    IN i_account_id VARCHAR(32),
    IN i_market_id  INT,
    IN i_product_id VARCHAR(32))
label:BEGIN
    SELECT
        a.process_date,
        a.settle_date,
        a.id,
        a.account_id,
        REPLACE(c.short_name,',',' ') AS short_name,
        CONCAT(a.market_id,'(',CASE a.market_id WHEN 1 THEN 'HK' WHEN 2 THEN 'US' WHEN 4 THEN 'SHA' WHEN 8 THEN 'SZA' when 16 then 'OTC' END,')')AS market_id,
        a.product_id,
        REPLACE(b.product_description,',',' ') AS product_description,
        CONCAT(a.custodian_account,':',a.custodian_code) AS custodian,
        CASE a.purpose WHEN 1 THEN ROUND(a.quantity,0) ELSE 0 END AS deposit,
        CASE a.purpose WHEN 2 THEN ROUND(a.quantity,0) ELSE 0 END AS withdraw,
        REPLACE(a.remark,',',' ') AS remark,
        CASE a.nominee_quantity WHEN 0 THEN 'N' ELSE 'Y' END AS nominee,
        a.update_user,
        a.update_time
    FROM product_flow a
    LEFT JOIN product b ON a.market_id = b.list_market_id and a.product_id = b.product_id
    LEFT JOIN account_profile c ON c.account_id = a.account_id
    WHERE i_date_beg <= a.process_date AND a.process_date <= i_date_end AND a.status = 'Confirmed'
        AND (i_account_id = '' OR a.account_id = i_account_id)
        AND (i_market_id  = 0  OR a.market_id  = i_market_id)
        AND (i_product_id = '' OR a.product_id = i_product_id)
        ORDER BY a.process_date,a.settle_date,a.account_id,a.market_id,a.product_id,a.id;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientProductLocationBalanceCSV04
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientProductLocationBalanceCSV04`;
delimiter ;;
CREATE PROCEDURE `proExportClientProductLocationBalanceCSV04`(IN i_process_date DATE)
label:BEGIN
 
    declare v_done int; 
    declare v_hk_1t date;
    declare v_hk_t1 date; 
    declare v_hk_t2 date; 
    
    declare v_us_1t date;
    declare v_us_t1 date; 
    declare v_us_t2 date; 

    declare v_csc_1t date;
    declare v_csc_t1 date; 
    declare v_csc_t2 date; 

    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    select max(calendar_day) into v_hk_1t from calendar where calendar_day<DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and market_id = 1 and holiday in('N','S'); 
    select min(calendar_day) into v_hk_t1 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and market_id = 1 and holiday in('N','S'); 
    select min(calendar_day) into v_hk_t2 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(v_hk_t1,INTERVAL 0 DAY),'%Y%m%d') and market_id = 1 and holiday in('N','S'); 

    select max(calendar_day) into v_us_1t from calendar where calendar_day<DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and market_id in(2,16) and holiday in('N','S'); 
    select min(calendar_day) into v_us_t1 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and market_id in(2,16) and holiday in('N','S'); 
    select min(calendar_day) into v_us_t2 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(v_us_t1,INTERVAL 0 DAY),'%Y%m%d') and market_id in(2,16) and holiday in('N','S'); 

    select max(calendar_day) into v_csc_1t from calendar where calendar_day<DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and market_id in (4,8) and holiday in('N','S'); 
    select min(calendar_day) into v_csc_t1 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and market_id in (4,8) and holiday in('N','S'); 
    select min(calendar_day) into v_csc_t2 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(v_csc_t1,INTERVAL 0 DAY),'%Y%m%d') and market_id in (4,8) and holiday in('N','S'); 

    drop temporary table IF EXISTS tmp_export;
    CREATE TEMPORARY TABLE tmp_export 
    (
        `client_acc_id`         VARCHAR(16) NULL DEFAULT NULL,
        `product_id`            VARCHAR(32) NULL DEFAULT NULL,
        `custodian_acc_id`      VARCHAR(32) NULL DEFAULT NULL,
        `buss_date`             VARCHAR(32) NULL DEFAULT NULL,
        `buss_date_1`           VARCHAR(32) NULL DEFAULT NULL,
        `buss_date_2`           VARCHAR(32) NULL DEFAULT NULL,
        `product_code`          VARCHAR(32) NULL DEFAULT NULL,
        `product_name`          VARCHAR(128) NULL DEFAULT NULL,
        `ccy`                   VARCHAR(16) NULL DEFAULT NULL,
        `nominal`               VARCHAR(32) NULL DEFAULT NULL,
        `closing_price`         VARCHAR(32) NULL DEFAULT NULL,
        `prev_close`            VARCHAR(32) NULL DEFAULT NULL,
        `loan_ratio`            VARCHAR(32) NULL DEFAULT NULL,
        `status`                VARCHAR(32) NULL DEFAULT NULL,
        `prev_qty`              VARCHAR(32) NULL DEFAULT NULL,
        `t0_qty`                VARCHAR(32) NULL DEFAULT NULL,
        `t1_qty`                VARCHAR(32) NULL DEFAULT NULL,
        `t2_qty`                VARCHAR(32) NULL DEFAULT NULL,
        `t0_unavail_qty`        VARCHAR(32) NULL DEFAULT NULL,
        `net_avail_qty`         VARCHAR(32) NULL DEFAULT NULL,
        `qty`                   VARCHAR(32) NULL DEFAULT NULL,
        `t0_nominee_qty`        VARCHAR(32) NULL DEFAULT NULL,
        `nominee_qty`           VARCHAR(32) NULL DEFAULT NULL,
        `t0_non_nominee_qty`    VARCHAR(32) NULL DEFAULT NULL,
        `non_nominee_qty`       VARCHAR(32) NULL DEFAULT NULL,
        `t1_settle_qty`         VARCHAR(32) NULL DEFAULT NULL,
        `t2_settle_qty`         VARCHAR(32) NULL DEFAULT NULL,
        `t1_after_settle_qty`   VARCHAR(32) NULL DEFAULT NULL,
        `t2_after_settle_qty`   VARCHAR(32) NULL DEFAULT NULL,
        `settle_qty`            VARCHAR(32) NULL DEFAULT NULL,
        `t2_mv`                 VARCHAR(32) NULL DEFAULT NULL,
        `t1_mv`                 VARCHAR(32) NULL DEFAULT NULL,
        `t0_mv`                 VARCHAR(32) NULL DEFAULT NULL,
        `mv`                    VARCHAR(32) NULL DEFAULT NULL,
        `t0_all_mv`             VARCHAR(32) NULL DEFAULT NULL,
        `avg_price`             VARCHAR(32) NULL DEFAULT NULL,
        `t0_onhold_qty`         VARCHAR(32) NULL DEFAULT NULL,
        `t0_uncleared_qty`      VARCHAR(32) NULL DEFAULT NULL,
        `group_key`             VARCHAR(16) NULL DEFAULT NULL,
        `ae_code`               VARCHAR(16) NULL DEFAULT NULL,
        `client_acc_name`       VARCHAR(128) NULL DEFAULT NULL
    );

    drop temporary table IF EXISTS tmp_position;
    CREATE TEMPORARY TABLE tmp_position 
    (
        `client_acc_id`         VARCHAR(16) NULL DEFAULT NULL,
        `product_id`            VARCHAR(32) NULL DEFAULT NULL,
        `custodian_acc_id`      VARCHAR(32) NULL DEFAULT NULL,
        `buss_date`             DATE NULL DEFAULT NULL,
        `buss_date_1`           DATE NULL DEFAULT NULL,
        `buss_date_2`           DATE NULL DEFAULT NULL,
        `product_code`          VARCHAR(32) NULL DEFAULT NULL,
        `product_name`          VARCHAR(128) NULL DEFAULT NULL,
        `ccy`                   VARCHAR(16) NULL DEFAULT NULL,
        `nominal`               DECIMAL(30,10) NULL DEFAULT 0.00,
        `closing_price`         DECIMAL(30,10) NULL DEFAULT 0.00,
        `prev_close`            DECIMAL(30,10) NULL DEFAULT 0.00,
        `loan_ratio`            DECIMAL(30,10) NULL DEFAULT 0.00,
        `status`                VARCHAR(16) NULL DEFAULT NULL,
        `prev_qty`              DECIMAL(30,10) NULL DEFAULT 0.00,
        `t0_qty`                DECIMAL(30,10) NULL DEFAULT 0.00,
        `t1_qty`                DECIMAL(30,10) NULL DEFAULT 0.00,
        `t2_qty`                DECIMAL(30,10) NULL DEFAULT 0.00,
        `t0_unavail_qty`        DECIMAL(30,10) NULL DEFAULT 0.00,
        `net_avail_qty`         DECIMAL(30,10) NULL DEFAULT 0.00,
        `qty`                   DECIMAL(30,10) NULL DEFAULT 0.00,
        `t0_nominee_qty`        DECIMAL(30,10) NULL DEFAULT 0.00,
        `nominee_qty`           DECIMAL(30,10) NULL DEFAULT 0.00,
        `t0_non_nominee_qty`    DECIMAL(30,10) NULL DEFAULT 0.00,
        `non_nominee_qty`       DECIMAL(30,10) NULL DEFAULT 0.00,
        `t1_settle_qty`         DECIMAL(30,10) NULL DEFAULT 0.00,
        `t2_settle_qty`         DECIMAL(30,10) NULL DEFAULT 0.00,
        `t1_after_settle_qty`   DECIMAL(30,10) NULL DEFAULT 0.00,
        `t2_after_settle_qty`   DECIMAL(30,10) NULL DEFAULT 0.00,
        `settle_qty`            DECIMAL(30,10) NULL DEFAULT 0.00,
        `t2_mv`                 DECIMAL(30,10) NULL DEFAULT 0.00,
        `t1_mv`                 DECIMAL(30,10) NULL DEFAULT 0.00,
        `t0_mv`                 DECIMAL(30,10) NULL DEFAULT 0.00,
        `mv`                    DECIMAL(30,10) NULL DEFAULT 0.00,
        `t0_all_mv`             DECIMAL(30,10) NULL DEFAULT 0.00,
        `avg_price`             DECIMAL(30,10) NULL DEFAULT 0.00,
        `t0_onhold_qty`         DECIMAL(30,10) NULL DEFAULT 0.00,
        `t0_uncleared_qty`      DECIMAL(30,10) NULL DEFAULT 0.00,
        `group_key`             VARCHAR(16) NULL DEFAULT NULL,
        `ae_code`               VARCHAR(16) NULL DEFAULT NULL,
        `client_acc_name`       VARCHAR(128) NULL DEFAULT NULL
    );

    drop temporary table if exists tmp; 
    create temporary table tmp 
    select account_id,product_id,custodian_code,custodian_account,
            sum(case buy_sell when 1 then 1 else -1 end * quantity) as qty, 
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as amt
        from account_trade where settle_date = v_hk_t1 and list_market_id = 1 and status = 'Confirmed'
        group by account_id,product_id,custodian_code,custodian_account; 
    create index idx on tmp(account_id, product_id, custodian_code, custodian_account);    

    drop temporary table if exists tmp2; 
    create temporary table tmp2 
    select account_id,product_id,custodian_code,custodian_account,
            sum(case buy_sell when 1 then 1 else -1 end * quantity) as qty, 
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as amt
        from account_trade 
        where settle_date = v_hk_t2 and list_market_id = 1 and status = 'Confirmed' group by account_id,product_id,custodian_code,custodian_account;
    create index idx on tmp2(account_id, product_id, custodian_code, custodian_account);

    -- HK
    insert into tmp_position
    select 
        a.account_id,
        concat(a.product_id,':',(case a.market_id when 1 then 'HK' when 2 then 'US' when 4 then 'SHA' when 8 then 'SZA' when 16 then 'OTC' end)) as product_id,
        concat(a.custodian_account,':',a.custodian_code) as custodian_acc_id,
        a.process_date as buss_date,
        v_hk_t1 as buss_date_1,
        v_hk_t2 as buss_date_2,
        a.product_id as product_code,
        replace(b.product_description,',','') as product_name,
        case a.currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end as ccy,
        a.closing_price as nominal,
        a.closing_price as closing_price,
        ifnull(c.closing_price,0) as prev_close,
        ifnull(b.loan_ratio,0) as loan_ratio,
        case d.status when 0 then 'A' when 1 then 'A' when 2 then 'C' when 3 then 'S' end as status,
        ifnull(c.quantity,0) as prev_qty,
        a.quantity as t0_qty,
        a.quantity + ifnull(f.qty,0) as t1_qty,
        a.net_quantity as t2_qty,
        0 as t0_unavail_qty,
        a.net_quantity as net_avail_qty,
        a.net_quantity as qty,
        a.nominee_quantity as t0_nominee_qty,
        a.nominee_quantity as nominee_qty,
        case when (a.quantity - a.nominee_quantity) < 0 then 0 else (a.quantity - a.nominee_quantity) end as t0_non_nominee_qty,
        a.net_quantity - a.nominee_quantity as non_nominee_qty,
        ifnull(f.qty,0) as t1_settle_qty,
        ifnull(g.qty,0) as t2_settle_qty,
        ifnull(g.qty,0) as t1_after_settle_qty,
        0 as t2_after_settle_qty,
        a.net_quantity - a.quantity as settle_qty,
        round((a.net_quantity *a.closing_price * b.price_factor),2) as t2_mv,
        -- a.market_value as t2_mv,
        round((a.quantity + ifnull(f.qty,0)) * a.closing_price * b.price_factor,2) as t1_mv,
        round(a.quantity * a.closing_price * b.price_factor,2) as t0_mv,
        round((a.net_quantity *a.closing_price * b.price_factor),2) as mv,
        round(a.quantity * a.closing_price * b.price_factor,2) as all_mv,
        a.avg_price1,
        0 as t0_onhold_qty,
        0 as t0_uncleared_qty,
        a.account_id as group_key,
        e.ae_id,
        replace(d.short_name,',',' ')
    from account_position a 
    inner join product b on a.market_id = b.list_market_id and a.product_id = b.product_id 
    left join account_position c on c.process_date = v_hk_1t and c.market_id = a.market_id and 
                c.product_id = a.product_id and c.account_id = a.account_id and 
                c.custodian_code = a.custodian_code and 
                c.custodian_account = a.custodian_account
    inner join account_profile d on d.account_id = a.account_id
    inner join capital_account e on e.account_id = a.account_id
    left join tmp f on f.account_id = a.account_id and f.product_id = a.product_id and f.custodian_code = a.custodian_code and f.custodian_account = a.custodian_account
    left join tmp2 g on g.account_id = a.account_id and g.product_id = a.product_id and g.custodian_code = a.custodian_code and g.custodian_account = a.custodian_account
    where a.process_date = i_process_date and a.market_id = 1
    order by a.currency,a.account_id,a.market_id,a.product_id,a.custodian_code,a.custodian_account;
    
    -- CSC
    drop temporary table if exists tmp; 
    create temporary table tmp 
    select account_id,product_id,custodian_code,custodian_account,
            sum(case buy_sell when 1 then 1 else -1 end * quantity) as qty, 
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as amt
        from account_trade where settle_date = v_csc_t1 and list_market_id in (4,8) and status = 'Confirmed' group by account_id,product_id,custodian_code,custodian_account; 
    create index idx on tmp(account_id, product_id, custodian_code, custodian_account);    

    drop temporary table if exists tmp2; 
    create temporary table tmp2 
    select account_id,product_id,custodian_code,custodian_account,
            sum(case buy_sell when 1 then 1 else -1 end * quantity) as qty, 
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as amt
        from account_trade 
        where settle_date = v_csc_t2 and list_market_id in (4,8) and status = 'Confirmed' group by account_id,product_id,custodian_code,custodian_account;
    create index idx on tmp2(account_id, product_id, custodian_code, custodian_account);


    insert into tmp_position
    select 
        a.account_id,
        concat(a.product_id,':',(case a.market_id when 1 then 'HK' when 2 then 'US' when 4 then 'SHA' when 8 then 'SZA' when 16 then 'OTC' end)) as product_id,
        concat(a.custodian_account,':',a.custodian_code) as custodian_acc_id,
        a.process_date as buss_date,
        v_csc_t1 as buss_date_1,
        v_csc_t2 as buss_date_2,
        a.product_id as product_code,
        replace(b.product_description,',','') as product_name,
        case a.currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end as ccy,
        a.closing_price as nominal,
        a.closing_price as closing_price,
        ifnull(c.closing_price,0) as prev_close,
        ifnull(b.loan_ratio,0) as loan_ratio,
        case d.status when 0 then 'A' when 1 then 'A' when 2 then 'C' when 3 then 'S' end as status,
        ifnull(c.quantity,0) as prev_qty,
        a.quantity as t0_qty,
        a.quantity + ifnull(f.qty,0) as t1_qty,
        a.net_quantity as t2_qty,
        0 as t0_unavail_qty,
        a.net_quantity as net_avail_qty,
        a.net_quantity as qty,
        a.nominee_quantity as t0_nominee_qty,
        a.nominee_quantity as nominee_qty,
        case when (a.quantity - a.nominee_quantity) < 0 then 0 else (a.quantity - a.nominee_quantity) end as t0_non_nominee_qty,
        a.net_quantity - a.nominee_quantity as non_nominee_qty,
        ifnull(f.qty,0) as t1_settle_qty,
        ifnull(g.qty,0) as t2_settle_qty,
        ifnull(g.qty,0) as t1_after_settle_qty,
        0 as t2_after_settle_qty,
        a.net_quantity - a.quantity as settle_qty,
        round((a.net_quantity *a.closing_price * b.price_factor),2) as t2_mv,
        -- a.market_value as t2_mv,
        round((a.quantity + ifnull(f.qty,0)) * a.closing_price * b.price_factor,2) as t1_mv,
        round(a.quantity * a.closing_price * b.price_factor,2) as t0_mv,
        round((a.net_quantity *a.closing_price * b.price_factor),2) as mv,
        round(a.quantity * a.closing_price * b.price_factor,2) as all_mv,
        a.avg_price1,
        0 as t0_onhold_qty,
        0 as t0_uncleared_qty,
        a.account_id as group_key,
        e.ae_id,
        replace(d.short_name,',',' ')
    from account_position a 
    inner join product b on a.market_id = b.list_market_id and a.product_id = b.product_id 
    left join account_position c on c.process_date = v_csc_1t and c.market_id = a.market_id and 
                c.product_id = a.product_id and c.account_id = a.account_id and 
                c.custodian_code = a.custodian_code and 
                c.custodian_account = a.custodian_account
    inner join account_profile d on d.account_id = a.account_id
    inner join capital_account e on e.account_id = a.account_id
    left join tmp f on f.account_id = a.account_id and f.product_id = a.product_id and f.custodian_code = a.custodian_code and f.custodian_account = a.custodian_account
    left join tmp2 g on g.account_id = a.account_id and g.product_id = a.product_id and g.custodian_code = a.custodian_code and g.custodian_account = a.custodian_account
    where a.process_date = i_process_date and a.market_id in (4,8)
    order by a.currency,a.account_id,a.market_id,a.product_id,a.custodian_code,a.custodian_account;
    
    -- US
    drop temporary table if exists tmp; 
    create temporary table tmp 
    select account_id,product_id,custodian_code,custodian_account,
            sum(case buy_sell when 1 then 1 else -1 end * quantity) as qty, 
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as amt
        from account_trade where settle_date = v_us_t1 and list_market_id in (2,16) and status = 'Confirmed' group by account_id,product_id,custodian_code,custodian_account;
    create index idx on tmp(account_id, product_id, custodian_code, custodian_account);    

    drop temporary table if exists tmp2; 
    create temporary table tmp2 
    select account_id,product_id,custodian_code,custodian_account,
            sum(case buy_sell when 1 then 1 else -1 end * quantity) as qty, 
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as amt
        from account_trade 
        where settle_date = v_us_t2 and list_market_id in (2,16) and status = 'Confirmed' group by account_id,product_id,custodian_code,custodian_account;
    create index idx on tmp2(account_id, product_id, custodian_code, custodian_account);

    insert into tmp_position
    select 
        a.account_id,
        concat(a.product_id,':',(case a.market_id when 1 then 'HK' when 2 then 'US' when 4 then 'SHA' when 8 then 'SZA' when 16 then 'OTC' end)) as product_id,
        concat(a.custodian_account,':',a.custodian_code) as custodian_acc_id,
        a.process_date as buss_date,
        v_us_t1 as buss_date_1,
        v_us_t2 as buss_date_2,
        a.product_id as product_code,
        replace(b.product_description,',','') as product_name,
        case a.currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end as ccy,
        a.closing_price as nominal,
        a.closing_price as closing_price,
        ifnull(c.closing_price,0) as prev_close,
        ifnull(b.loan_ratio,0) as loan_ratio,
        case d.status when 0 then 'A' when 1 then 'A' when 2 then 'C' when 3 then 'S' end as status,
        ifnull(c.quantity,0) as prev_qty,
        a.quantity as t0_qty,
        a.quantity + ifnull(f.qty,0) as t1_qty,
        a.net_quantity as t2_qty,
        0 as t0_unavail_qty,
        a.net_quantity as net_avail_qty,
        a.net_quantity as qty,
        a.nominee_quantity as t0_nominee_qty,
        a.nominee_quantity as nominee_qty,
        case when (a.quantity - a.nominee_quantity) < 0 then 0 else (a.quantity - a.nominee_quantity) end as t0_non_nominee_qty,
        a.net_quantity - a.nominee_quantity as non_nominee_qty,
        ifnull(f.qty,0) as t1_settle_qty,
        ifnull(g.qty,0) as t2_settle_qty,
        ifnull(g.qty,0) as t1_after_settle_qty,
        0 as t2_after_settle_qty,
        a.net_quantity - a.quantity as settle_qty,
        round((a.net_quantity *a.closing_price) * b.price_factor,2) as t2_mv,
        -- a.market_value as t2_mv,
        round((a.quantity + ifnull(f.qty,0)) * a.closing_price * b.price_factor,2) as t1_mv,
        round(a.quantity * a.closing_price * b.price_factor,2) as t0_mv,
        round((a.net_quantity *a.closing_price * b.price_factor),2) as mv,
        round(a.quantity * a.closing_price * b.price_factor,2) as all_mv,
        a.avg_price1,
        0 as t0_onhold_qty,
        0 as t0_uncleared_qty,
        a.account_id as group_key,
        e.ae_id,
        replace(d.short_name,',',' ')
    from account_position a 
    inner join product b on a.market_id = b.list_market_id and a.product_id = b.product_id 
    left join account_position c on c.process_date = v_us_1t and c.market_id = a.market_id and 
                c.product_id = a.product_id and c.account_id = a.account_id and c.custodian_code = a.custodian_code and 
                c.custodian_account = a.custodian_account
    inner join account_profile d on d.account_id = a.account_id
    inner join capital_account e on e.account_id = a.account_id
    left join tmp f on f.account_id = a.account_id and f.product_id = a.product_id and f.custodian_code = a.custodian_code and f.custodian_account = a.custodian_account
    left join tmp2 g on g.account_id = a.account_id and g.product_id = a.product_id and g.custodian_code = a.custodian_code and g.custodian_account = a.custodian_account
    where a.process_date = i_process_date and a.market_id in (2,16)
    order by a.currency,a.account_id,a.market_id,a.product_id,a.custodian_code,a.custodian_account;

    insert into tmp_export
    select * from tmp_position where (t0_qty <> 0 or t1_qty <> 0 or t2_qty <> 0);

    select * from tmp_export;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientTradeHistory
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientTradeHistory`;
delimiter ;;
CREATE PROCEDURE `proExportClientTradeHistory`(IN i_process_date DATE)
label:BEGIN

  drop temporary table if exists tmp; 
  create temporary table tmp 
   SELECT min(trade_exec_id) as trade_exec_id,
      trade_id,
      exec_price AS price,
      SUM(exec_quantity)AS qty,
      sum(trade_amount) as trade_amount,
      sum(commission) as commission,
      sum(charges) as charges 
      FROM account_trade_detail 
    WHERE process_date=i_process_date GROUP BY process_date,trade_id,exec_price;
  create index idx on tmp(trade_id);

  drop temporary table if exists tmp1; 
  create temporary table tmp1 
  	select external_id,
		  sum(charges) as other_charges
  		from account_charge where process_date = i_process_date and formula_type <> 'COMM' and ifnull(external_id2,'') = '' group by external_id;
  create index idx on tmp1(external_id);

  SELECT 
    a.process_date,
    a.trade_date,
    a.settle_date,
    a.list_market_id,
    a.product_id,
    replace(a.product_description,',',' '),
    a.account_id,
    replace(b.short_name,',',' ') AS full_name_of_ultimate_client,
    b.photoid_type AS nationality,
    b.photoid AS id_code,
    IF(a.buy_sell=1,c.qty,NULL)AS bought, 
    IF(a.buy_sell=2,c.qty,NULL)AS sold, 
    c.price, 
    c.trade_amount,
    case c.trade_exec_id when 1 then a.commission else '' end as commission,
    case c.trade_exec_id when 1 then ifnull(d.other_charges,0) else '' end as other_charges,
    c.charges as charges,
    b.phone1 AS contact_phone_no,
    REPLACE(IFNULL(b.address1,b.mailing_address),',','') AS address_of_ultimat_client,
    replace(b.short_name,',','') as name_of_person_giving_order,
    a.broker AS broker_for_farm_out_trade,
    NULL AS full_name_of_responsible_ae,
    NULL AS short_sell
  FROM jcbms.account_trade a 
  LEFT JOIN jcbms.account_profile b ON a.account_id=b.account_id
  LEFT JOIN tmp c ON a.trade_id=c.trade_id
  left join tmp1 d  on d.external_id = a.trade_id
  WHERE a.process_date=i_process_date and a.status = 'Confirmed'
  ORDER BY a.product_id,a.list_market_id,a.buy_sell,a.account_id,c.price;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientTradeHistoryQuery
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientTradeHistoryQuery`;
delimiter ;;
CREATE PROCEDURE `proExportClientTradeHistoryQuery`(IN i_date_beg   DATE,
    IN i_date_end   DATE,
    IN i_account_id VARCHAR(32),
    IN i_market_id  INT,
    IN i_product_id VARCHAR(32))
label:BEGIN

SELECT
a.process_date,
a.trade_date,
a.settle_date,
a.list_market_id,
a.product_id,
REPLACE(a.product_description,',',' ') AS product_description,
a.account_id,
REPLACE(b.short_name,',',' ') AS short_name,
(CASE b.account_class WHEN'1'THEN b.party_country WHEN'3'THEN b.photo_country ELSE NULL END) AS nationality,
(CASE b.account_class WHEN'1'THEN b.partyid       WHEN'3'THEN b.photoid       ELSE NULL END) AS id_code,
IF(a.buy_sell=1,c.qty,NULL)AS bought, 
IF(a.buy_sell=2,c.qty,NULL)AS sold, 
c.price, 
c.trade_amount,
CASE c.trade_exec_id WHEN 1 THEN a.commission ELSE 0 END AS commission,
CASE c.trade_exec_id WHEN 1 THEN IFNULL(d.other_charges,0) ELSE 0 END AS other_charges,
c.charges AS charges,
b.phone1 AS contact_phone_no,
REPLACE(IFNULL(b.address1,b.mailing_address),',','') AS address_of_ultimat_client,
ifnull(a.broker,'') AS broker_for_farm_out_trade,
ifnull(case ca.account_type when 1 then 'Cash' when 2 then 'Margin' when 0 then 'House' end,'') AS account_type,
ifnull(dict.value,'') AS input_channel
FROM jcbms.account_trade a 
LEFT JOIN jcbms.capital_account ca ON a.account_id=ca.account_id
LEFT JOIN jcbms.account_profile b ON a.account_id=b.account_id
LEFT JOIN jcbms.dict dict on dict.class = 'ORDER' and dict.sub_class = 'CHANNEL' and dict.item = a.input_channel
LEFT JOIN(
    SELECT
    process_date,
    MIN(trade_exec_id) AS trade_exec_id,
    trade_id,
    exec_price AS price,
    SUM(exec_quantity)AS qty,
    SUM(trade_amount) AS trade_amount,
    SUM(commission) AS commission,
    SUM(charges) AS charges
    FROM account_trade_detail
    WHERE i_date_beg<=process_date AND process_date<=i_date_end GROUP BY process_date,trade_id,exec_price
)c ON a.process_date=c.process_date AND a.trade_id=c.trade_id
LEFT JOIN(
		SELECT
    process_date,
    external_id,
	  SUM(charges) AS other_charges
		FROM account_charge
    WHERE formula_type <> 'COMM' AND IFNULL(external_id2,'') = ''
    AND i_date_beg<=process_date AND process_date<=i_date_end GROUP BY process_date,external_id
) d ON a.process_date=d.process_date AND a.trade_id=d.external_id
WHERE i_date_beg<=a.process_date AND a.process_date<=i_date_end
AND (i_account_id = '' OR a.account_id = i_account_id)
AND (i_market_id  = 0  OR a.market_id  = i_market_id)
AND (i_product_id = '' OR a.product_id = i_product_id) and a.status = 'Confirmed'
ORDER BY a.process_date,a.account_id,a.list_market_id,a.product_id,a.buy_sell,c.price;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientTradeJournalListing
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientTradeJournalListing`;
delimiter ;;
CREATE PROCEDURE `proExportClientTradeJournalListing`(in i_process_date date, 
    in i_market_id int)
label:begin
DECLARE v_broker  VARCHAR(32);
DECLARE v_note_22 DECIMAL(30,10);
DECLARE v_note_23 DECIMAL(30,10);
    

    
    drop temporary table if exists tmp_rpt; 
    create temporary table tmp_rpt
    (
        id bigint primary key auto_increment,
        type int, 
        show_id bigint, 
        trade_date date, 
        settle_date date, 
        trade_id varchar(32), 
        account_id varchar(16), 
        buy_sell int, 
        market_id int, 
        product_id varchar(32), 
        currency int,
        price decimal(30,10), 
        quantity decimal(30,10), 
        turnover decimal(30,10), 
        commission decimal(30,10), 
        market_charges decimal(30,10), 
        broker_cost decimal(30,10), 
        net_amount decimal(30,10), 
        index idx(trade_id)
    );

    insert into tmp_rpt
    select 
        NULL,
        1, 
        0,
        trade_date, 
        settle_date, 
        trade_id, 
        account_id, 
        buy_sell,
        market_id, 
        product_id, 
        clearing_currency,
        avg_price, 
        quantity, 
        trade_amount, 
        commission, 
        charges, 
        0,
        case when buy_sell = 1 then -1 else 1 end *net_amount
    from account_trade a
    where a.process_date = i_process_date 
    and a.market_id = i_market_id and a.status = 'Confirmed'
    order by buy_sell,market_id,product_id,account_id,trade_id; 

    update tmp_rpt 
    set show_id = id; 

    
    drop temporary table if exists tmp_rpt_id;
    create temporary table tmp_rpt_id 
    (
        show_id bigint, 
        trade_id varchar(64), 
        index idx1(trade_id)
    ); 
    insert into tmp_rpt_id
    select show_id, 
           trade_id 
        from tmp_rpt
        group by show_id,trade_id;

    insert into tmp_rpt 
    (
        type,
        trade_id, 
        show_id, 
        quantity, 
        price
    )
    select 
        2, 
        a.trade_id, 
        b.show_id, 
        a.exec_quantity, 
        a.exec_price
    from account_trade_detail a 
    inner join tmp_rpt_id b on a.trade_id = b.trade_id
    where a.process_date = i_process_date 
    and a.market_id = i_market_id;

IF i_market_id=2 or i_market_id=16 THEN

SELECT
'US_broker' AS broker, 
-1*round(sum(case when a.account_type = 1 then case when buy_sell = 1 then -1 else 1 end * a.net_amount else 0 end )*ifnull(b.exchange_rate,c.exchange_rate),2) as note22,  
-1*round(sum(case when a.account_type = 2 then case when buy_sell = 1 then -1 else 1 end * a.net_amount else 0 end )*ifnull(b.exchange_rate,c.exchange_rate),2) as note23
INTO v_broker, v_note_22, v_note_23
from account_trade a
left join currency_history b on a.process_date = b.process_date and a.clearing_currency = b.currency
left join currency c on a.clearing_currency = c.currency
where a.process_date = i_process_date and market_id in ('2','16') and a.status = 'Confirmed' 
; 
REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, voucher_value, update_time)VALUES
(i_process_date, 'note_22', '1-2317 Cash clt rec- US mkt -USD'      , v_note_22, NOW()),
(i_process_date, 'note_23', '1-2325 Margin clt rec -US market- USD' , v_note_23, NOW());
END IF;

    select * from tmp_rpt order by show_id,type;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientTradeJournalListingBroker
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientTradeJournalListingBroker`;
delimiter ;;
CREATE PROCEDURE `proExportClientTradeJournalListingBroker`(IN i_process_date DATE)
label:BEGIN

drop temporary table IF EXISTS tmp_rpt;
CREATE TEMPORARY TABLE tmp_rpt
(
    process_date DATE,
    tran_date DATE,
    settle_date DATE,
    broker VARCHAR(32),
    currency INT,
    tran_code VARCHAR(32),
    ae_code VARCHAR(32),
    account_id VARCHAR(32),
    market_id INT,
    product_id VARCHAR(32),
    price DECIMAL(30,10),
    quantity DECIMAL(30,10),
    turnover DECIMAL(30,10),
    commission DECIMAL(30,10),
    ae_commission DECIMAL(30,10),
    mkt_charges DECIMAL(30,10),
    broker_cost DECIMAL(30,10),
    net_amount DECIMAL(30,10),
    line_type INT,
    account_type INT,
    buy_sell INT,
    INDEX idx1(broker,line_type)
);

INSERT INTO tmp_rpt(process_date, tran_date,settle_date,broker,         currency,tran_code,ae_code,account_id,market_id,product_id,    price,quantity,    turnover,commission,ae_commission,mkt_charges,net_amount,line_type,account_type,buy_sell)
             SELECT process_date,trade_date,settle_date,broker,clearing_currency, trade_id,   NULL,account_id,market_id,product_id,avg_price,quantity,trade_amount,commission,         NULL,    charges,net_amount,        1,account_type,buy_sell
               FROM account_trade WHERE process_date=i_process_date AND broker IS NOT NULL and status = 'Confirmed';

drop temporary table IF EXISTS tmp_rpt_2;
CREATE TEMPORARY TABLE tmp_rpt_2 SELECT * FROM tmp_rpt WHERE 1=2;
INSERT INTO tmp_rpt_2(                                       ae_code,broker,currency,    turnover,     commission,     ae_commission,     mkt_charges,     broker_cost,                    net_amount ,line_type )
SELECT IF(account_type=0,'House',IF(account_type=1,'Cash','Margin')),broker,currency,SUM(turnover),SUM(commission),SUM(ae_commission),SUM(mkt_charges),SUM(broker_cost),SUM((buy_sell*2-3)*net_amount),2
    FROM tmp_rpt WHERE line_type=1 GROUP BY account_type,broker,currency;
INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_2;

delete from tmp_rpt_2;
INSERT INTO tmp_rpt_2(         ae_code,broker,currency,                   turnover,                    commission,                    ae_commission,                    mkt_charges,                    broker_cost,                    net_amount ,line_type )
    SELECT IF(buy_sell=1,'BUY','SELL'),broker,currency,SUM((buy_sell*2-3)*turnover),SUM((buy_sell*2-3)*commission),SUM((buy_sell*2-3)*ae_commission),SUM((buy_sell*2-3)*mkt_charges),SUM((buy_sell*2-3)*broker_cost),SUM((buy_sell*2-3)*net_amount),3
        FROM tmp_rpt WHERE line_type=1 GROUP BY buy_sell,broker,currency;
INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_2;

delete from tmp_rpt_2;
INSERT INTO tmp_rpt_2(ae_code,broker,currency,    turnover,     commission,     ae_commission,     mkt_charges,     broker_cost,                    net_amount ,line_type )
    SELECT            'Total',broker,currency,SUM(turnover),SUM(commission),SUM(ae_commission),SUM(mkt_charges),SUM(broker_cost),SUM((buy_sell*2-3)*net_amount),4
        FROM tmp_rpt WHERE line_type=1 GROUP BY broker,currency;
INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_2;

SELECT * FROM tmp_rpt ORDER BY broker,line_type;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientTrust
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientTrust`;
delimiter ;;
CREATE PROCEDURE `proExportClientTrust`(IN i_process_date DATE,
    IN i_account_type INT)
label:BEGIN
DECLARE v_prev_process_date DATE;

IF i_process_date IS NULL THEN
    SELECT buss_date INTO i_process_date FROM sys_info;
END IF;
IF DATE_FORMAT(i_process_date,'%w') = 1 THEN 
    SET v_prev_process_date = DATE_SUB(i_process_date, INTERVAL 3 DAY);
ELSE 
    SET v_prev_process_date = DATE_SUB(i_process_date, INTERVAL 1 DAY);
END IF;

drop temporary table IF EXISTS tmp_rpt;
CREATE TEMPORARY TABLE tmp_rpt
(
    prev_process_date DATE,
    curr_process_date DATE,
    account_id VARCHAR(32),
    short_name VARCHAR(128),
    account_type INT,
    ae_code VARCHAR(32),
    currency INT,
    prev_balance DECIMAL(30,10),
    prev_balance_uncleared DECIMAL(30,10),
    prev_avail_balance DECIMAL(30,10),
    today_momvement DECIMAL(30,10),
    curr_balance DECIMAL(30,10),
    curr_balance_uncleared DECIMAL(30,10),
    curr_avail_balance DECIMAL(30,10),
    INDEX idx1(account_id,account_type,currency)
);

drop temporary table if EXISTS tmp; 
create temporary table tmp
SELECT process_date,account_id,currency,settle_balance,account_type FROM account_balance WHERE process_date=v_prev_process_date; 
create index idx on tmp(account_id, currency);

INSERT INTO tmp_rpt(prev_process_date,curr_process_date,account_id,short_name,account_type,ae_code,currency,
                    prev_balance,prev_balance_uncleared,prev_avail_balance,today_momvement,
                    curr_balance,curr_balance_uncleared,curr_avail_balance)

SELECT 
b.process_date AS prev_process_date,
a.process_date AS curr_process_date,
a.account_id,
replace(c.short_name,',',' ') as short_name,
a.account_type,
''AS ae_code,
a.currency,
IFNULL(b.settle_balance,0)AS prev_balance,
0 AS prev_balance_uncleared,
IFNULL(b.settle_balance,0)AS prev_avail_balance,
a.settle_balance-IFNULL(b.settle_balance,0) AS today_momvement,
a.settle_balance AS curr_balance,
0 AS curr_balance_uncleared,
a.settle_balance AS curr_avail_balance
FROM account_balance a  
LEFT JOIN tmp b ON a.account_id=b.account_id AND a.currency=b.currency
LEFT JOIN account_profile c ON a.account_id=c.account_id
WHERE a.process_date = i_process_date and (a.settle_balance>0 OR b.settle_balance>0)
AND a.account_type IN ( IF(i_account_type=0,1,i_account_type),IF(i_account_type=0,2,i_account_type) )
ORDER BY a.currency,a.account_id ASC;

drop temporary table IF EXISTS tmp_rpt_2;
CREATE TEMPORARY TABLE tmp_rpt_2 SELECT * FROM tmp_rpt WHERE 1=2;

INSERT INTO tmp_rpt_2(ae_code,currency,
                    prev_balance,prev_balance_uncleared,prev_avail_balance,
                    curr_balance,curr_balance_uncleared,curr_avail_balance)
SELECT 
CONCAT(IF(currency=1,'CNY',IF(currency=2,'HKD','USD')),'_Total') AS ae_code,
currency,
SUM(prev_balance),SUM(prev_balance_uncleared),SUM(prev_avail_balance),
SUM(curr_balance),SUM(curr_balance_uncleared),SUM(curr_avail_balance)
FROM tmp_rpt GROUP BY currency;

INSERT INTO tmp_rpt_2(ae_code,currency,prev_avail_balance,curr_avail_balance)
SELECT 
CONCAT(IF(currency=1,'CNY',IF(currency=2,'HKD','USD')),'_Total_Debit') AS ae_code,
currency,
SUM(IF(prev_avail_balance<0,prev_avail_balance,0)),
SUM(IF(curr_avail_balance<0,curr_avail_balance,0))
FROM tmp_rpt GROUP BY currency;

INSERT INTO tmp_rpt_2(ae_code,currency,prev_avail_balance,curr_avail_balance)
SELECT 
CONCAT(IF(currency=1,'CNY',IF(currency=2,'HKD','USD')),'_Total_Credit') AS ae_code,
currency,
SUM(IF(prev_avail_balance>0,prev_avail_balance,0)),
SUM(IF(curr_avail_balance>0,curr_avail_balance,0))
FROM tmp_rpt GROUP BY currency;

UPDATE tmp_rpt_2 SET today_momvement=curr_avail_balance-prev_avail_balance;

INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_2;

SELECT * FROM tmp_rpt;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientTurnOverSummary
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientTurnOverSummary`;
delimiter ;;
CREATE PROCEDURE `proExportClientTurnOverSummary`(IN i_process_date DATE,
    IN i_market_id VARCHAR(16),
    IN i_account_id VARCHAR(16))
label:BEGIN

IF i_process_date IS NULL THEN
    SELECT buss_date INTO i_process_date FROM sys_info;
END IF;

drop temporary table IF EXISTS tmp_rpt;
CREATE TEMPORARY TABLE tmp_rpt
(
    process_date DATE,
    account_id VARCHAR(32),
    short_name VARCHAR(128),
    ae_code VARCHAR(16),
    buy_quantity INT,
    sell_quantity INT,
    total_quantity INT,
    currency VARCHAR(16),
    exchange_rate DECIMAL(30,10),
    buy_turnover DECIMAL(30,10),
    sell_turnover DECIMAL(30,10),
    total_turnover DECIMAL(30,10),
    commission DECIMAL(30,10),
    platform_user_charges DECIMAL(30,10),
    INDEX idx1(account_id,currency)
);

DROP TABLE IF EXISTS tmp_rpt1;
CREATE TEMPORARY TABLE tmp_rpt1
(
    process_date DATE,
    account_id VARCHAR(32),
    short_name VARCHAR(128),
    ae_code VARCHAR(16),
    buy_quantity INT,
    sell_quantity INT,
    total_quantity INT,
    currency VARCHAR(16),
    exchange_rate DECIMAL(30,10),
    buy_turnover DECIMAL(30,10),
    sell_turnover DECIMAL(30,10),
    total_turnover DECIMAL(30,10),
    commission DECIMAL(30,10),
    platform_user_charges DECIMAL(30,10),
    INDEX idx1(account_id,currency)
);

INSERT INTO tmp_rpt(process_date,account_id,short_name,ae_code,buy_quantity,sell_quantity,total_quantity,
                       currency,exchange_rate,buy_turnover,sell_turnover,total_turnover,commission,platform_user_charges)
SELECT 
    a.process_date,
    a.account_id,
    replace(b.short_name,',',' ') as short_name,
    e.ae_id AS ae_code,
    SUM(IF(buy_sell=1,quantity,0)) AS buy_quantity,
    SUM(IF(buy_sell=2,quantity,0)) AS sell_quantity,
    SUM(quantity) AS total_quantity,
    case clearing_currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end AS currency,
    ROUND(case when ifnull(d.exchange_rate,'') = '' then c.exchange_rate else d.exchange_rate end,6) AS exchange_rate,
    SUM(IF(buy_sell=1,trade_amount,0)) AS buy_turnover,
    SUM(IF(buy_sell=2,trade_amount,0)) AS sell_turnover,
    SUM(trade_amount) AS total_turnover,
    SUM(commission) AS commission,
    IFNULL(SUM(f.JC_QSF),0) AS platform_user_charges
FROM account_trade a
LEFT JOIN account_profile b ON a.account_id=b.account_id
left join currency c on a.clearing_currency = c.currency
left join currency_history d on d.process_date = i_process_date and d.currency = a.clearing_currency
LEFT JOIN capital_account e ON a.account_id=e.account_id
LEFT JOIN (
    SELECT process_date,external_id,SUM(charges)AS JC_QSF FROM account_charge
        WHERE process_date=i_process_date AND formula_type='CHRG' AND charge_code in ('US_JC_FEE:US','JC_QSF:HK','JC_CC:SHA','JC_CC:SZA')
        GROUP BY process_date,external_id
) f ON a.process_date=f.process_date AND a.trade_id=f.external_id
WHERE a.process_date=i_process_date and (i_market_id = '' or a.list_market_id = i_market_id) and (i_account_id = '' or a.account_id = i_account_id) and a.status = 'Confirmed' 
GROUP BY a.account_id,clearing_currency ORDER BY clearing_currency,a.account_id;


INSERT INTO tmp_rpt1 select * from tmp_rpt;

INSERT INTO tmp_rpt(process_date,account_id,short_name,ae_code,buy_quantity,sell_quantity,total_quantity,
                       currency,exchange_rate,buy_turnover,sell_turnover,total_turnover,commission,platform_user_charges)
SELECT 
    a.process_date,
    a.currency AS account_id,
    'Total' AS short_name,
    ''AS ae_code,
    SUM(buy_quantity) AS buy_quantity,
    SUM(sell_quantity) AS sell_quantity,
    SUM(total_quantity) AS total_quantity,
    'HKD' AS currency,
    1.00 as exchange_rate,
    SUM(ROUND(a.buy_turnover*(case when ifnull(c.exchange_rate,'') = '' then b.exchange_rate else c.exchange_rate end),2)) AS buy_turnover,
    SUM(ROUND(a.sell_turnover*(case when ifnull(c.exchange_rate,'') = '' then b.exchange_rate else c.exchange_rate end),2)) AS sell_turnover,
    SUM(ROUND(a.total_turnover*(case when ifnull(c.exchange_rate,'') = '' then b.exchange_rate else c.exchange_rate end),2)) AS total_turnover,
    SUM(ROUND(a.commission*(case when ifnull(c.exchange_rate,'') = '' then b.exchange_rate else c.exchange_rate end),2)) as commission,
    SUM(ROUND(a.platform_user_charges*(case when ifnull(c.exchange_rate,'') = '' then b.exchange_rate else c.exchange_rate end),2)) as platform_user_charges
FROM tmp_rpt1 a 
left join currency b on a.currency = (case b.currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end)
left join currency_history c on c.process_date = a.process_date and (case c.currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end) = a.currency
group by a.currency;



SELECT * FROM tmp_rpt;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientTurnOverSummaryPeriod
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientTurnOverSummaryPeriod`;
delimiter ;;
CREATE PROCEDURE `proExportClientTurnOverSummaryPeriod`(IN i_process_date_from DATE,
    IN i_process_date_to DATE,
    IN i_market_id VARCHAR(16),
    IN i_account_id VARCHAR(16))
label:BEGIN

IF i_process_date_from IS NULL THEN
    SELECT buss_date INTO i_process_date_from FROM sys_info;
END IF;

if i_process_date_to is null then 
    set i_process_date_to = i_process_date_from;
end if; 

DROP TABLE IF EXISTS tmp_rpt;
CREATE TEMPORARY TABLE tmp_rpt
(
    process_date DATE,
    account_id VARCHAR(32),
    short_name VARCHAR(128),
    ae_code VARCHAR(16),
    buy_quantity BIGINT,
    sell_quantity BIGINT,
    total_quantity BIGINT,
    currency VARCHAR(16),
    exchange_rate DECIMAL(30,10),
    buy_turnover DECIMAL(30,10),
    sell_turnover DECIMAL(30,10),
    total_turnover DECIMAL(30,10),
    total_base_turnover DECIMAL(30,10),
    commission DECIMAL(30,10),
    INDEX idx1(account_id,currency)
);

INSERT INTO tmp_rpt(process_date,account_id,short_name,ae_code,buy_quantity,sell_quantity,total_quantity,
                       currency,exchange_rate,buy_turnover,sell_turnover,total_turnover,total_base_turnover,commission)
SELECT 
a.process_date,
a.account_id,
replace(b.short_name,',',' ') as short_name,
''AS ae_code,
SUM(IF(buy_sell=1,quantity,0)) AS buy_quantity,
SUM(IF(buy_sell=2,quantity,0)) AS sell_quantity,
SUM(quantity) AS total_quantity,
case clearing_currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end AS currency,
ROUND(case when ifnull(d.exchange_rate,'') = '' then c.exchange_rate else d.exchange_rate end,6) AS exchange_rate,
SUM(IF(buy_sell=1,trade_amount,0)) AS buy_turnover,
SUM(IF(buy_sell=2,trade_amount,0)) AS sell_turnover,
SUM(trade_amount) AS total_turnover,
round(sum(trade_amount)*ROUND(case when ifnull(d.exchange_rate,'') = '' then c.exchange_rate else d.exchange_rate end,6),2) as total_base_turnover,
SUM(commission)
FROM account_trade a
LEFT JOIN account_profile b ON a.account_id=b.account_id
left join currency c on a.clearing_currency = c.currency
left join currency_history d on d.process_date = a.process_date and d.currency = a.clearing_currency
WHERE a.process_date>=i_process_date_from and a.process_date <=i_process_date_to and (i_market_id = '' or a.list_market_id = i_market_id) and (i_account_id = '' or a.account_id = i_account_id) 
GROUP BY a.account_id,clearing_currency ORDER BY a.process_date,a.account_id,clearing_currency;


INSERT INTO tmp_rpt(process_date,account_id,short_name,ae_code,buy_quantity,sell_quantity,total_quantity,
                       currency,exchange_rate,buy_turnover,sell_turnover,total_turnover,commission)
SELECT 
i_process_date_to,
NULL AS account_id,
'Total(HKD)' AS short_name,
''AS ae_code,
SUM(IF(buy_sell=1,quantity,0)) AS buy_quantity,
SUM(IF(buy_sell=2,quantity,0)) AS sell_quantity,
SUM(quantity) AS total_quantity,
'HKD' AS currency,
1.00 as exchange_rate,
SUM(IF(buy_sell=1,ROUND(trade_amount*(case when ifnull(c.exchange_rate,'') = '' then b.exchange_rate else c.exchange_rate end),2),0)) AS buy_turnover,
SUM(IF(buy_sell=2,ROUND(trade_amount*(case when ifnull(c.exchange_rate,'') = '' then b.exchange_rate else c.exchange_rate end),2),0)) AS sell_turnover,
SUM(ROUND(trade_amount*(case when ifnull(c.exchange_rate,'') = '' then b.exchange_rate else c.exchange_rate end),2)) AS total_turnover,
SUM(ROUND(commission*(case when ifnull(c.exchange_rate,'') = '' then b.exchange_rate else c.exchange_rate end),2))
FROM account_trade a 
left join currency b on a.clearing_currency = b.currency
left join currency_history c on c.process_date = a.process_date and c.currency = a.clearing_currency
WHERE a.process_date>=i_process_date_from and a.process_date<=i_process_date_to and (i_market_id = '' or a.list_market_id = i_market_id) and (i_account_id = '' or a.account_id = i_account_id); 




SELECT * FROM tmp_rpt ; 

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientTurnOverSummaryQuery
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientTurnOverSummaryQuery`;
delimiter ;;
CREATE PROCEDURE `proExportClientTurnOverSummaryQuery`(IN i_date_beg   DATE,
    IN i_date_end   DATE,
    IN i_account_id VARCHAR(32),
    IN i_market_id  INT,
    IN i_product_id VARCHAR(32))
label:BEGIN


drop temporary table if exists tmp; 
create temporary table tmp 
SELECT process_date,external_id,SUM(charges)AS JC_QSF FROM account_charge
WHERE i_date_beg <= process_date AND process_date <= i_date_end AND formula_type='CHRG' AND charge_code in ('US_JC_FEE:US','JC_QSF:HK','JC_CC:SHA','JC_CC:SZA')
GROUP BY process_date,external_id;
create index idx on tmp(process_date, external_id);


drop temporary table if exists tmp2; 
create temporary table tmp2 
SELECT process_date,external_id,SUM(charges)AS other_charges FROM account_charge
WHERE i_date_beg <= process_date AND process_date <= i_date_end AND formula_type='CHRG' AND charge_code not in ('US_JC_FEE:US','JC_QSF:HK','JC_CC:SHA','JC_CC:SZA')
GROUP BY process_date,external_id;
create index idx on tmp2(process_date, external_id);

SELECT
NULL AS process_date,
NULL AS trade_date,
NULL AS settle_date,
t.account_id,
REPLACE(b.short_name,',',' ') as short_name,
e.ae_id AS ae_code,
t.buy_quantity,
t.sell_quantity,
t.total_quantity,
CONCAT(t.clearing_currency,'(', CASE t.clearing_currency WHEN 1 THEN 'CNY' WHEN 2 THEN 'HKD' WHEN 4 THEN 'USD' ELSE t.clearing_currency END, ')') AS currency,
NULL AS exchange_rate,
t.buy_turnover,
t.sell_turnover,
t.total_turnover,
t.commission,
t.platform_user_charges,
t.other_charges
FROM
(
SELECT 
a.account_id,
SUM(IF(buy_sell=1, ROUND(quantity,0), 0)) AS buy_quantity,
SUM(IF(buy_sell=2, ROUND(quantity,0), 0)) AS sell_quantity,
SUM(ROUND(quantity,0)) AS total_quantity,
clearing_currency,
SUM(IF(buy_sell=1,trade_amount,0)) AS buy_turnover,
SUM(IF(buy_sell=2,trade_amount,0)) AS sell_turnover,
SUM(trade_amount) AS total_turnover,
ifnull(SUM(commission),0) AS commission,
IFNULL(SUM(f.JC_QSF),0) AS platform_user_charges,
ifnull(SUM(g.other_charges),0) as other_charges
FROM account_trade a
LEFT JOIN tmp f ON a.process_date=f.process_date AND a.trade_id=f.external_id
LEFT JOIN tmp2 g ON a.process_date=g.process_date AND a.trade_id=g.external_id
WHERE i_date_beg <= a.process_date AND a.process_date <= i_date_end AND a.status = 'Confirmed'
AND (i_account_id = '' OR a.account_id = i_account_id)
AND (i_market_id  = 0  OR a.market_id  = i_market_id)
AND (i_product_id = '' OR a.product_id = i_product_id)
GROUP BY a.account_id,a.clearing_currency
ORDER BY a.account_id,a.clearing_currency
)t
LEFT JOIN account_profile b ON t.account_id=b.account_id
LEFT JOIN capital_account e ON t.account_id=e.account_id;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportClientTurnoverSummaryReportBR085
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportClientTurnoverSummaryReportBR085`;
delimiter ;;
CREATE PROCEDURE `proExportClientTurnoverSummaryReportBR085`(IN i_process_date DATE)
label:BEGIN

    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    drop temporary table IF EXISTS tmp_export;
    CREATE TEMPORARY TABLE tmp_export 
    (
        `Client_AC`        VARCHAR(64) NULL DEFAULT NULL,
        `Short_name`    VARCHAR(64) NULL DEFAULT NULL,
        `AE`   varchar(64) NULL DEFAULT NULL,
        `Buy1`              varchar(64) NULL DEFAULT NULL,
        `Sell1`       varchar(64) NULL DEFAULT NULL,
        `Total1`         varchar(64) NULL DEFAULT NULL,
        `Currency`        VARCHAR(64) NULL DEFAULT NULL,
        `Buy2`    VARCHAR(64) NULL DEFAULT NULL,
        `Sell2`   varchar(64) NULL DEFAULT NULL,
        `Total2`              varchar(64) NULL DEFAULT NULL,
        `Commission`       varchar(64) NULL DEFAULT NULL
    );

    insert into tmp_export
    values
        ('','','','','Quantity','','','','Turnover','',''),
        ('Client A/C','','AE','Buy','Sell','Total','','Buy','Sell','Total','Commission');

    insert into tmp_export
    select 
        a.account_id,
        replace(e.short_name,',',' ') as short_name,
        d.ae_id,
        round(sum(case a.buy_sell when 1 then 1 else 0 end * a.quantity),2),
        round(sum(case a.buy_sell when 1 then 0 else 1 end * a.quantity),2),
        round(sum(a.quantity),2),
        case a.clearing_currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' else '' end,
        round(sum(case a.buy_sell when 1 then 1 else 0 end * a.trade_amount * case when ifnull(b.exchange_rate,'') = '' then round(c.exchange_rate,6) else round(b.exchange_rate,6) end),2),
        round(sum(case a.buy_sell when 1 then 0 else 1 end * a.trade_amount * case when ifnull(b.exchange_rate,'') = '' then round(c.exchange_rate,6) else round(b.exchange_rate,6) end),2),
        round(sum(a.trade_amount * case when ifnull(b.exchange_rate,'') = '' then round(c.exchange_rate,6) else round(b.exchange_rate,6) end),2),
        round(sum(a.commission * case when ifnull(b.exchange_rate,'') = '' then round(c.exchange_rate,6) else round(b.exchange_rate,6) end),2)
    from account_trade a 
    left join currency_history b on a.process_date = b.process_date and a.clearing_currency = b.currency
    left join currency c on c.currency = a.clearing_currency
    inner join capital_account d on d.account_id = a.account_id
    inner join account_profile e on e.account_id = a.account_id
    where a.process_date = i_process_date and a.status = 'Confirmed' 
    group by a.account_id;

    insert into tmp_export
    select 
        '','','',
        round(sum(case a.buy_sell when 1 then 1 else 0 end * a.quantity),2),
        round(sum(case a.buy_sell when 1 then 0 else 1 end * a.quantity),2),
        round(sum(a.quantity),2),
        'HKD',
        round(sum(case a.buy_sell when 1 then 1 else 0 end * a.trade_amount * case when ifnull(b.exchange_rate,'') = '' then round(c.exchange_rate,6) else round(b.exchange_rate,6) end),2),
        round(sum(case a.buy_sell when 1 then 0 else 1 end * a.trade_amount * case when ifnull(b.exchange_rate,'') = '' then round(c.exchange_rate,6) else round(b.exchange_rate,6) end),2),
        round(sum(a.trade_amount * case when ifnull(b.exchange_rate,'') = '' then round(c.exchange_rate,6) else round(b.exchange_rate,6) end),2),
        round(sum(a.commission * case when ifnull(b.exchange_rate,'') = '' then round(c.exchange_rate,6) else round(b.exchange_rate,6) end),2)
    from account_trade a 
    left join currency_history b on a.process_date = b.process_date and a.clearing_currency = b.currency
    left join currency c on c.currency = a.clearing_currency
    inner join capital_account d on d.account_id = a.account_id
    inner join account_profile e on e.account_id = a.account_id
    where a.process_date = i_process_date and a.status = 'Confirmed'; 


    select * from tmp_export a;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportCustodianProductBalanceSummary
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportCustodianProductBalanceSummary`;
delimiter ;;
CREATE PROCEDURE `proExportCustodianProductBalanceSummary`(in i_process_date date)
label:begin

    declare v_hk_t1 date; 
    declare v_us_t date; 
    declare v_us_t1 date; 
    declare v_zht_t1 date; 
    declare v_hk_t2 date; 
    declare v_us_t2 date; 
    declare v_zht_t2 date; 
    declare v_done int; 
    DECLARE v_custodian varchar(32);
    DECLARE cur_custodian CURSOR FOR
    SELECT
      custodian_code
    FROM
      account_position a
    where a.process_date = i_process_date group by custodian_code; 
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1; 
    
    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    set v_hk_t1  = NULL; 
    set v_hk_t2  = NULL; 
    select min(calendar_day) into v_hk_t1 from calendar where market_id = 1 and calendar_day>i_process_date and holiday <> 'Y'; 
    select min(calendar_day) into v_hk_t2 from calendar where market_id = 1 and calendar_day>v_hk_t1 and holiday <> 'Y'; 
    set v_us_t1  = NULL; 
    set v_us_t2  = NULL; 
    select max(calendar_day) into v_us_t from calendar where market_id = 2 and calendar_day<i_process_date and holiday <> 'Y'; 
    select min(calendar_day) into v_us_t1 from calendar where market_id = 2 and calendar_day>v_us_t and holiday <> 'Y'; 
    select min(calendar_day) into v_us_t2 from calendar where market_id = 2 and calendar_day>v_us_t1 and holiday <> 'Y'; 



    drop temporary table if exists tmp_custodian_position; 
    create temporary table tmp_custodian_position
    ( 
        custodian varchar(32),
        custodian_code VARCHAR(16),
        t0_qty varchar(32), 
        t0_mv varchar(32), 
        t1_qty varchar(32), 
        t1_mv varchar(32),
        qty varchar(32), 
        mv varchar(32), 
        index idx1(custodian,custodian_code)
    ); 

    insert into tmp_custodian_position
    select 'Custodian a/c','','Balance(T)','Mkt.Value(T)','Balance(T+1)','Mkt.Value(T+1)','Net Balance','Market Value';

    open cur_custodian; 
    set v_done = 0; 
    fetch cur_custodian into v_custodian; 
    while v_done <> 1 do 

        insert into tmp_custodian_position
        select 'Custodian',v_custodian,'','HKD','','HKD','','HKD';

        INSERT INTO tmp_custodian_position
        select
            concat(a.custodian_account,':',a.custodian_code) as custodian,
            '',
            round(sum(a.quantity),0) as t0_qty,
            round(sum(a.quantity* a.closing_price * ifnull(d.exchange_rate,b.exchange_rate)),2) as t0_mv,
            round(sum(a.net_quantity-ifnull(c.quantity,0)),0) as t1_qty,
            round(sum((a.net_quantity-ifnull(c.quantity,0)) * a.closing_price * ifnull(d.exchange_rate,b.exchange_rate)),2) as t1_mv,
            round(sum(a.net_quantity),0) as qty,
            round(sum(a.net_quantity * a.closing_price * ifnull(d.exchange_rate,b.exchange_rate)),2) as mv
        from account_position a 
        left join currency_history b on b.process_date = a.process_date and b.currency = a.currency 
        left join currency d on d.currency = a.currency
        left join (
            select account_id,list_market_id,product_id,custodian_code,custodian_account,sum(case buy_sell when 1 then 1 else -1 end * quantity) as quantity 
            from account_trade 
            where settle_date = case list_market_id when 1 then v_hk_t2 when 2 then v_us_t2 when 16 then v_us_t2 end and status = 'Confirmed' and market_id not in (4,8)
            group by account_id,list_market_id,product_id,custodian_code,custodian_account
        ) c on c.account_id = a.account_id and c.list_market_id = a.market_id and c.product_id= a.product_id and c.custodian_code = a.custodian_code and c.custodian_account = a.custodian_account
        where a.process_date = i_process_date and a.custodian_code = v_custodian group by a.custodian_code,custodian;

        insert into tmp_custodian_position
        select 
            '',
            'SubTotal',
            round(sum(a.quantity),0) as t0_qty,
            round(sum(a.quantity* a.closing_price * ifnull(d.exchange_rate,b.exchange_rate)),2) as t0_mv,
            round(sum(a.net_quantity-ifnull(c.quantity,0)),0) as t1_qty,
            round(sum((a.net_quantity-ifnull(c.quantity,0)) * a.closing_price * ifnull(d.exchange_rate,b.exchange_rate)),2) as t1_mv,
            round(sum(a.net_quantity),0) as qty,
            round(sum(a.net_quantity * a.closing_price * ifnull(d.exchange_rate,b.exchange_rate)),2) as mv
        from account_position a 
        left join currency_history b on b.process_date = a.process_date and b.currency = a.currency 
        left join currency d on d.currency = a.currency
        left join (
            select account_id,list_market_id,product_id,custodian_code,custodian_account,sum(case buy_sell when 1 then 1 else -1 end * quantity) as quantity 
            from account_trade 
            where settle_date = case list_market_id when 1 then v_hk_t2 when 2 then v_us_t2 when 16 then v_us_t2 end and status = 'Confirmed' and market_id not in (4,8)
            group by account_id,list_market_id,product_id,custodian_code,custodian_account
        ) c on c.account_id = a.account_id and c.list_market_id = a.market_id and c.product_id= a.product_id and c.custodian_code = a.custodian_code and c.custodian_account = a.custodian_account
        where a.process_date = i_process_date and a.custodian_code = v_custodian group by a.custodian_code;

        set v_done = 0; 
        fetch cur_custodian into v_custodian; 
    end while; 
    close cur_custodian; 

    select * from tmp_custodian_position a;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportFinancialAdjustment
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportFinancialAdjustment`;
delimiter ;;
CREATE PROCEDURE `proExportFinancialAdjustment`(in i_process_date date)
label:begin

    declare v_total_liquid_assets decimal(30,10); 

    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    
    drop temporary table if exists tmp_rpt_financial_adjustment;
    create temporary table tmp_rpt_financial_adjustment
    (
        id bigint primary key auto_increment, 
        process_date date, 
        account_id   varchar(16),
        account_name varchar(128),
        net_balance decimal(30,10) default 0.0,
        market_value decimal(30,10) default 0.0,
        market_value_after_haircut decimal(30,10) default 0.0,
        margin_short_fall decimal(30,10) default 0.0,
        liquid_asset decimal(30,10) default 0.0,
        ratio_to_total decimal(30,10) default 0.0,
        financial_adjustment decimal(30,10) default 0.0,
        index idx1(process_date ,account_id)
    );

    
    insert into tmp_rpt_financial_adjustment
    (
        process_date,
        account_id,
        account_name, 
        net_balance, 
        market_value
    )
    select
        a.process_date,
        a.account_id,
        ifnull(replace(account_profile.short_name,',',' '),'') as short_name,
        sum(round((a.trade_balance-IFNULL(d.amt,0))*round(ifnull(b.exchange_rate,c.exchange_rate),6),2)) as net_balance,
        sum(round(ifnull(e.market_value,0)*round(ifnull(b.exchange_rate, c.exchange_rate),4), 2)) as market_value
    from 
    account_balance a 
    left join currency_history b on a.process_date = b.process_date and a.currency = b.currency 
    left join currency c on a.currency = c.currency
    left join account_profile on account_profile.account_id = a.account_id
    LEFT JOIN (
    SELECT account_id, currency, SUM(IF(purpose=1,amount,0)-IF(purpose=2,amount,0))AS amt FROM cash_flow_cit WHERE process_date<=i_process_date GROUP BY account_id,currency
    )d ON a.account_id=d.account_id AND a.currency=d.currency
    left join (
        select 
            po.account_id,
            po.currency,
            sum(po.net_quantity * po.closing_price) as market_value
        from account_position po
        inner join product pr on pr.product_id = po.product_id
        where po.process_date = i_process_date group by po.account_id,po.currency
    ) e on e.account_id = a.account_id and e.currency = a.currency
    where 
        a.process_date = i_process_date and 
        a.account_type in('2','3')
        group by a.process_date, a.account_id, account_profile.short_name
        having net_balance <0  order by account_id; 

    
    call proPositionMarketValueSummary(i_process_date); 

    
    update tmp_rpt_financial_adjustment a
    left join tmp_position_market_value_summary b on a.process_date = b.process_date and a.account_id = b.account_id
    set a.market_value = ifnull(b.market_value,0),
    a.market_value_after_haircut  = ifnull(b.market_value_after_haircut,0),
    
    a.margin_short_fall = case when ifnull(b.market_value_after_haircut,0) = 0 then -1*a.net_balance
                               when -1*a.net_balance - ifnull(b.market_value_after_haircut,0) > 0 then -1*a.net_balance - ifnull(b.market_value_after_haircut,0)
                               else 0 end;  

    
    update  tmp_rpt_financial_adjustment a 
    set a.liquid_asset = -1*a.net_balance - a.margin_short_fall; 

    
    select 
        ifnull(sum(liquid_asset),0) 
    into v_total_liquid_assets 
    from tmp_rpt_financial_adjustment; 
    
    
    update tmp_rpt_financial_adjustment a 
    set a.ratio_to_total = case when v_total_liquid_assets  = 0 then 0 else round(a.liquid_asset/v_total_liquid_assets,4)*100 end ; 

    
    update tmp_rpt_financial_adjustment a 
    set a.financial_adjustment = case when a.ratio_to_total >= 0.1*100 then a.liquid_asset - round(v_total_liquid_assets*0.1,2) else 0 end ;

drop temporary table IF EXISTS tmp_rpt_financial_adjustment_2;
CREATE TEMPORARY TABLE tmp_rpt_financial_adjustment_2 SELECT * FROM tmp_rpt_financial_adjustment WHERE 1=2;
INSERT INTO tmp_rpt_financial_adjustment_2(account_name,    net_balance ,    market_value ,    market_value_after_haircut ,    margin_short_fall ,    liquid_asset ,    ratio_to_total ,    financial_adjustment)
                                     SELECT     'Total',SUM(net_balance),SUM(market_value),SUM(market_value_after_haircut),SUM(margin_short_fall),SUM(liquid_asset),round(SUM(ratio_to_total),0),SUM(financial_adjustment) FROM tmp_rpt_financial_adjustment;
INSERT INTO tmp_rpt_financial_adjustment SELECT * FROM tmp_rpt_financial_adjustment_2;

    select * from tmp_rpt_financial_adjustment; 
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportHKStampDailyReturnReportBR054
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportHKStampDailyReturnReportBR054`;
delimiter ;;
CREATE PROCEDURE `proExportHKStampDailyReturnReportBR054`(IN i_process_date DATE)
label:BEGIN
    declare v_sum_amount decimal(30,10) default 0;
    declare v_sum_charges decimal(30,10) default 0;
    declare v_variance decimal(30,10) default 0;
    declare YYYYMMDD varchar(10);



    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    set YYYYMMDD = date_format(i_process_date,'%Y-%m-%d');

    drop temporary table IF EXISTS tmp_export;
    CREATE TEMPORARY TABLE tmp_export 
    (
        `key1`     VARCHAR(128) NULL DEFAULT NULL,
        `value1`   VARCHAR(128) NULL DEFAULT NULL,
        `key2`     varchar(128) NULL DEFAULT NULL,
        `value2`   varchar(128) NULL DEFAULT NULL
    );

    insert into tmp_export
    (
        key1,
        value1,
        key2,
        value2
    )
    values 
        ('TO : STAMP OFFICE, HONG KONG C/O THE STOCK EXCHANGE OF HONG KONG LTD.','','',''),
        ('FILE NO :','SDO/SB/1242','BROKER FIRM ID :','B02102'),
        ('CONTACT PERSON :','ELVIN WANG','BROKER NAME :','Zinvest Global Limited'),
        ('TELEPHONE NO. :','5211656','BROKER NUMBER :','5256'),
        ('PART A : STAMP DUTY PAYMENT PARTICULARS :','','','');

    insert into tmp_export
    select 
        '1. STAMP DUTY PAYABLE FOR TRADING DATE OF',
        YYYYMMDD,
        '',
        '';

    select 
    ceil(sum(b.charges* a.exchange_rate)) as sum_charges,
	ceil(sum((a.trade_amount*a.exchange_rate)*1/10/100) ) as sum_amount,
	ceil(sum(b.charges* a.exchange_rate)) - ceil(sum(a.trade_amount*(case when ifnull(c.exchange_rate,'') = '' then d.exchange_rate else c.exchange_rate end)) * 1/10/100) as variance
    into 
        v_sum_charges,v_sum_amount,v_variance
    from account_trade a 
    left join currency d on a.clearing_currency = d.currency
    left join currency_history c on c.process_date = a.process_date and c.currency = a.clearing_currency
    inner join account_charge b on b.process_date = a.process_date and b.charge_code = 'STAMP_HK:HK' and b.external_id = a.trade_id and b.charges<> 0 
    where a.process_date = i_process_date and a.market_id = 1 and a.input_channel <> 5 and a.status = 'Confirmed';

    insert into tmp_export
    values
        ('2. ACTUAL CONTRACT NOTE STAMP DUTY PAID','','HK$',round(v_sum_charges,2)),
        ('3. TOTAL SALES AND PURCHASE x 0.001','','HK$',round(v_sum_amount,2)),
        ('(excluding exempt stocks)','','',''),
        ('VARIANCE (Item 2 minus Item 3)','','HK$',round(v_variance,2)),
        ('PART B : BREAKDOWN OF NEGATIVE VARIANCE ONLY :','','',''),
        ('1. DIRECT STAMPING AT IRD ','','HK$',''),
        ('2. SET OFF AGAINST CREDIT REFUNDED BY IRD ','','HK$',''),
        ('3. LATE TRADE AMENDMENTS ','','HK$',''),
        ('4. OTHERS (e.g. exchange rate difference)','','',''),
        ('Please Specify : _________________________________ ','','HK$',''),
        ('NET TOTAL (EQUAL OR MORE THAN VARIANCE IN PART A)','','HK$',''),
        ('COMPANY CHOP : ','____________________________','',''),
        ('SIGNATURE :',' ____________________________','',''),
        ('PRINT DATE :',YYYYMMDD,'',''),
        ('SETTLEMENT DATE :',YYYYMMDD,'','');

    select * from tmp_export a;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportHKStampMonthlyReturnReportBR055
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportHKStampMonthlyReturnReportBR055`;
delimiter ;;
CREATE PROCEDURE `proExportHKStampMonthlyReturnReportBR055`(IN i_process_date DATE)
label:BEGIN
    declare v_sum_stamp decimal(30,10) default 0.00;
    declare v_trade_date date;
    declare v_sum_charges decimal(30,10) default 0.00;
    declare v_variance decimal(30,10) default 0.00;
    declare YYYYMMDD varchar(10);
    declare v_done int; 
    declare v_real_month_first_day date;
    
    declare cur_trade cursor for 
        select 
            a.process_date,
            round(ceil(sum(b.charges* a.exchange_rate)),2) as sum_charges
        from account_trade a 
        inner join account_charge b on b.process_date = a.process_date and b.charge_code = 'STAMP_HK:HK' and b.external_id = a.trade_id and b.charges<> 0 
        where a.process_date >= v_real_month_first_day and a.process_date <= i_process_date and a.market_id = 1 and a.input_channel <> 5 and a.status = 'Confirmed'
        group by a.process_date,a.clearing_currency;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done=1;

    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    select min(calendar_day) into v_real_month_first_day from calendar where date_format(calendar_day,'%Y%m') = date_format(i_process_date,'%Y%m') ; 

    set YYYYMMDD = date_format(i_process_date,'%Y-%m-%d');

    drop temporary table IF EXISTS tmp_export;
    CREATE TEMPORARY TABLE tmp_export 
    (
        `key1`     VARCHAR(128) NULL DEFAULT NULL,
        `value1`   VARCHAR(128) NULL DEFAULT NULL,
        `key2`     varchar(128) NULL DEFAULT NULL,
        `value2`   varchar(128) NULL DEFAULT NULL
    );

    insert into tmp_export
    (
        key1,
        value1,
        key2,
        value2
    )
    values 
        ('TO : STAMP OFFICE, HONG KONG C/O THE STOCK EXCHANGE OF HONG KONG LTD.','','',''),
        ('FILE NO :','SDO/SB/1242','BROKER FIRM ID :','B02102'),
        ('CONTACT PERSON :','KEN MAK','BROKER NAME :','Zinvest Global Limited'),
        ('TELEPHONE NO. :','5211656','BROKER NUMBER :','5256'),
        ('PART A : MONTHLY INFORMATION :','','',''),
        ('1. RETURN FOR THE MONTH OF',date_format(i_process_date,'%Y-%m'),'','');

    select sum(t.sum_charges)
    into v_sum_stamp
    from 
        (select 
            a.process_date,
            round(ceil(sum(b.charges* a.exchange_rate)),2) as sum_charges
        from account_trade a 
        inner join account_charge b on b.process_date = a.process_date and b.charge_code = 'STAMP_HK:HK' and b.external_id = a.trade_id and b.charges<> 0 
        where a.process_date >= v_real_month_first_day and a.process_date <= i_process_date and a.market_id = 1 and a.input_channel <> 5 and a.status = 'Confirmed'
        group by a.process_date,a.clearing_currency
        ) t;

    insert into tmp_export
    values
        ('2. TOTAL STAMP DUTY PAYABLE FOR THE MONTH *','','HK$',round(v_sum_stamp,2)),
        ('3. ACTUAL STAMP DUTY PAID THROUGH THE','','HK$',round(v_sum_stamp,2)),
        ('EXCHANGE FOR THE MONTH *','','',''),
        ('* Please attach copy of daily Stamp ','Duty Ledger (U3/SC/S136) for this month.','',''),
        ('PART B : SUSPENSION OR CESSATION INFORMATION :','','',''),
        ('1. SUSPENSION FROM','____________________________','TO','______________________(NOTE)'),
        ('2. CESSATION  FROM','____________________________','',''),
        ('3. REASON FOR SUSPENTION OR CESSATION ','- (please specify)','',''),
        ('','','',''),
        ('','','',''),
        ('NOTE : Leave blank if the exchange ','participant (broker) cannot anticipate','',''),
        ('the date of resumption of business.','','',''),
        ('COMPANY CHOP OF EXCHANGE PARTICIPANT :','____________________________','',''),
        ('SIGNATURE :',' ____________________________','',''),
        ('PRINT DATE :',YYYYMMDD,'',''),
        ('','','',''),
        ('','','',''),
        ('','','','');



    insert into tmp_export
    values ('Trade DATE','TOTAL STAMP DUTY PAYABLE(per contract notes)','STAMP DUTY PAID THROUGH HKEX','REMARK');

    open cur_trade; 
    set v_done=0; 
    fetch cur_trade into v_trade_date,v_sum_charges;
    while v_done <> 1 do

        insert into tmp_export
        values (v_trade_date,round(v_sum_charges,2),round(v_sum_charges,2),'');

        set v_done=0; 
        fetch cur_trade into v_trade_date,v_sum_charges;
    end while; 
    CLOSE cur_trade;

    insert into tmp_export
    values
        ('TOTAL FOR THE MONTH :',round(v_sum_stamp,2),round(v_sum_stamp,2),''),
        ('Print Time :',now(),'',''),
        ('U3/SC/S136','','','');

    select * from tmp_export a;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportIlliquidProductSummaryBR039
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportIlliquidProductSummaryBR039`;
delimiter ;;
CREATE PROCEDURE `proExportIlliquidProductSummaryBR039`(IN i_process_date DATE)
label:BEGIN
    DECLARE v_total_mv DECIMAL(30,10);
    DECLARE v_20_mv DECIMAL(30,10);
    DECLARE temp_date	date;
    DECLARE month_1 varchar(6);
    DECLARE month_2 varchar(6);
    DECLARE month_3 varchar(6);
    DECLARE month_4 varchar(6);
    DECLARE month_5 varchar(6);
    DECLARE month_6 varchar(6);


    -- fn_illiquid_product_0
    -- fn_illiquid_product
	set temp_date = i_process_date;
	set temp_date = temp_date - day(temp_date) + 1;
	set month_1 = date_format(DATE_SUB(i_process_date, INTERVAL 2 MONTH), '%Y%m');
	set month_2 = date_format(DATE_SUB(i_process_date, INTERVAL 3 MONTH), '%Y%m');
	set month_3 = date_format(DATE_SUB(i_process_date, INTERVAL 4 MONTH), '%Y%m');
	set month_4 = date_format(DATE_SUB(i_process_date, INTERVAL 5 MONTH), '%Y%m');
	set month_5 = date_format(DATE_SUB(i_process_date, INTERVAL 6 MONTH), '%Y%m');
	set month_6 = date_format(DATE_SUB(i_process_date, INTERVAL 7 MONTH), '%Y%m');


    drop temporary table IF EXISTS result_table1;
    CREATE TEMPORARY TABLE result_table1
    (
        product_id	varchar(32),
        month_1	varchar(6),
        month_2	varchar(6),
        month_3	varchar(6),
        month_4	varchar(6),
        month_5	varchar(6),
        month_6	varchar(6),
        turnover_1	DECIMAL(30,10),
        turnover_2	DECIMAL(30,10),
        turnover_3	DECIMAL(30,10),
        turnover_4	DECIMAL(30,10),
        turnover_5	DECIMAL(30,10),
        turnover_6	DECIMAL(30,10),
        mth_turnover	DECIMAL(30,10),
        mkt_cap	DECIMAL(30,10),
        type varchar(10)
    );

    insert into result_table1
    select 
        p.product_id, 
        month_1, month_2, month_3, month_4, month_5, month_6,
        0,0,0,0,0,0,0,0,0
    from product p;

    -- fn_illiquid_product_1
    drop temporary table IF EXISTS result_table2;
    CREATE TEMPORARY TABLE result_table2
    (
        product_id		varchar(36) null,
        name			varchar(100) null,
        mth_turnover	DECIMAL(30,10) null,
        mkt_cap			DECIMAL(30,10) null,
        mkt_cap_5		DECIMAL(30,10) null,
        qty				DECIMAL(30,10) null,
        price			DECIMAL(30,10) null,
        mv				DECIMAL(30,10) null,
        a_b				varchar(1) null,
        a_c				varchar(1) null,
        month_6			varchar(1) null,
        frr_grade_code	varchar(10) null
    );

    drop temporary table IF EXISTS TempProductId ;
    CREATE TEMPORARY TABLE TempProductId (product_id varchar(36), client_acc_id varchar(36));
	drop temporary table IF EXISTS TempTopClient ;
    CREATE TEMPORARY TABLE TempTopClient (client_acc_id varchar(36), product_id varchar(36), mv DECIMAL(30,10));
	drop temporary table IF EXISTS TempIlliquidMarket ;
    CREATE TEMPORARY TABLE TempIlliquidMarket (market_id varchar(128));

    insert into TempTopClient
    -- select t.account_id, d.product_id, round(d.market_value * currency.exchange_rate, 2) mv
    select t.account_id, d.product_id, round(d.net_quantity * d.closing_price * currency.exchange_rate, 2) mv
        from (
                select db.* from (
                    select 
                        a.account_id,
                        concat('"',b.short_name,'"') as short_name,
                        sum((a.trade_balance - ifnull(f.amt,0))*(case when e.exchange_rate is null then d.exchange_rate else e.exchange_rate end)) as amount,
                        sum((a.trade_balance - ifnull(f.amt,0))*(case when e.exchange_rate is null then d.exchange_rate else e.exchange_rate end)) as mv
                    from account_balance a 
                    inner join account_profile b on a.account_id = b.account_id
                    inner join capital_account c on c.account_id = a.account_id
                    left join currency d on d.currency = a.currency
                    left join currency_history e on e.process_date = a.process_date and e.currency = a.currency
                    LEFT JOIN (
                        SELECT account_id, currency, SUM(IF(purpose=1,amount,0)-IF(purpose=2,amount,0))AS amt FROM cash_flow_cit WHERE process_date<=i_process_date GROUP BY account_id,currency
                    ) f ON a.account_id=f.account_id AND a.currency=f.currency
                    where a.process_date = i_process_date and a.account_id = b.account_id and c.account_type = 2
                    group by a.account_id, short_name
                    having(sum((a.trade_balance - ifnull(f.amt,0))*(case when e.exchange_rate is null then d.exchange_rate else e.exchange_rate end))) < 0
                    order by sum((a.trade_balance - ifnull(f.amt,0))*(case when e.exchange_rate is null then d.exchange_rate else e.exchange_rate end))
                    ) db
                    union all
                    select cr.* from (
                    select 
                        a.account_id,
                        concat('"',b.short_name,'"') as short_name,
                        sum((a.trade_balance - ifnull(f.amt,0))*(case when e.exchange_rate is null then d.exchange_rate else e.exchange_rate end)) as amount,
                        sum((a.trade_balance - ifnull(f.amt,0))*(case when e.exchange_rate is null then d.exchange_rate else e.exchange_rate end)) as mv
                    from account_balance a 
                    inner join account_profile b on a.account_id = b.account_id
                    inner join capital_account c on c.account_id = a.account_id
                    left join currency d on d.currency = a.currency
                    left join currency_history e on e.process_date = a.process_date and e.currency = a.currency
                    LEFT JOIN (
                        SELECT account_id, currency, SUM(IF(purpose=1,amount,0)-IF(purpose=2,amount,0))AS amt FROM cash_flow_cit WHERE process_date<=i_process_date GROUP BY account_id,currency
                    ) f ON a.account_id=f.account_id AND a.currency=f.currency
                    where a.process_date = i_process_date and a.account_id = b.account_id and c.account_type = 2
                    group by a.account_id, short_name
                    having(sum((a.trade_balance - ifnull(f.amt,0))*(case when e.exchange_rate is null then d.exchange_rate else e.exchange_rate end))) >= 0
                    order by sum((a.trade_balance - ifnull(f.amt,0))*(case when e.exchange_rate is null then d.exchange_rate else e.exchange_rate end)) desc
                ) cr limit 20
            ) t, account_position d, product p, currency
        where d.process_date = i_process_date 
        and d.account_id  = t.account_id
        and d.product_id = p.product_id
        and p.quote_currency = currency.currency
        and d.net_quantity <> 0;

    drop temporary table IF EXISTS TempTopClient2 ;
    CREATE TEMPORARY TABLE TempTopClient2 (client_acc_id varchar(36), product_id varchar(36), mv DECIMAL(30,10));
    insert into TempTopClient2 select *from TempTopClient;

    insert into TempProductId
    select product_id, client_acc_id from (
        select *, (
            select count(*)
            from TempTopClient2 counter
            where counter.client_acc_id = topCacc.client_acc_id
            and counter.mv >= topCacc.mv
            ) as rowNumber
        from TempTopClient topCacc
    ) top3 where rowNumber <= 3;
    
    drop temporary table IF EXISTS TempProductId2 ;
    CREATE TEMPORARY TABLE TempProductId2 (product_id varchar(36), client_acc_id varchar(36));
    insert into TempProductId2 select *from TempProductId;

	insert into TempIlliquidMarket 
    select ''
    union
    select '1' market_id;

    drop temporary table IF EXISTS RESULT_SET1;
    CREATE TEMPORARY TABLE RESULT_SET1
    (
        product_id		varchar(36) null,
        name			varchar(128) null,
        mth_turnover	DECIMAL(30,10) null,
        mkt_cap			DECIMAL(30,10) null,
        mkt_cap_5		DECIMAL(30,10) null,
        qty				DECIMAL(30,10) null,
        price			DECIMAL(30,10) null,
        mv				DECIMAL(30,10) null,
        a_b				varchar(1) null,
        a_c				varchar(1) null,
        month_6			varchar(1) null,
        frr_grade_code	varchar(10) null
    );

    insert into RESULT_SET1
	select p.product_id, replace(p.product_description,',',' '), ip.mth_turnover, ip.mkt_cap,
        round(ip.mkt_cap * 0.05, 2) mkt_cap_5,
        d.qty,
        d.mv / d.qty price,
        d.mv,
        case when d.mv > round(ip.mkt_cap * 0.05, 2) and ip.mkt_cap > 0 and ip.type <> '5' then 'Y' else 'N' end a_b,
        case when d.mv > ip.mth_turnover and ip.mth_turnover > 0 and ip.type <> '5' then 'Y' else 'N' end a_c,
        case when p.listing_date is null or date_format(DATE_SUB(i_process_date, INTERVAL 6 MONTH), '%Y%m%d') > p.listing_date then 'Y' else 'N' end month_6,
        '' as frr_grade_code
    from
    (
        select d1.product_id, sum(round(/*d1.market_value*/d1.net_quantity *d1.closing_price * ccy.exchange_rate, 2)) mv, SUM(d1.net_quantity) qty
        from account_position d1, product p, currency ccy, capital_account c
        where d1.account_id = c.account_id
        and d1.product_id = p.PRODUCT_ID
        and p.quote_currency = ccy.currency
        and c.account_type = 2
        and d1.process_date = i_process_date
        and (
            d1.product_id in (select product_id from TempProductId)
            and exists (
                select 1
                from TempProductId2 tp
                where tp.product_id = d1.product_id
                and tp.client_acc_id = d1.account_id
            )
        )
        group by d1.product_id    
    ) d, 
    product p, 
    result_table1 ip, 
    TempIlliquidMarket m
    where d.product_id = p.product_id
    and d.product_id = ip.product_id 
    and p.product_type not in (32,64)
    and p.list_market_id = m.market_id 
    and d.qty <> 0;

    drop temporary table IF EXISTS TempPosition ;
    CREATE TEMPORARY TABLE TempPosition (product_id varchar(36), qty DECIMAL(30,10));
    insert into TempPosition
    select product_id,sum(net_quantity) 
    from account_position a 
    where process_date = i_process_date and product_id in (
        select product_id from RESULT_SET1 group by product_id
    ) and a.custodian_account = 5 group by product_id;
    
    update RESULT_SET1 a,TempPosition b 
    set a.qty = b.qty,
        a.mv = a.qty * a.price
    where a.product_id = b.product_id;

    drop temporary table IF EXISTS tmp_monthly_statistics;
    CREATE TEMPORARY TABLE tmp_monthly_statistics
    (
        product_id		    varchar(36) null,
        Market_cap	        DECIMAL(30,10) null,
        Market_cap_5        DECIMAL(30,10) null,
        Monthly_turnover	DECIMAL(30,10) null
    );

    insert into tmp_monthly_statistics
    select 
        code,
        round(sum(monthly_market_val)/count(1),2),
        round(sum(monthly_market_val)/count(1)*0.05,2),
        round(sum(monthly_turnover)/count(1),2)
    from `basicdata`.`hk_monthly_statistics` where date_format(trading_day,'%Y%m') >= month_6 and date_format(trading_day,'%Y%m') <= month_1 group by code;

    update RESULT_SET1 a
    inner join tmp_monthly_statistics b on a.product_id = b.product_id
    set a.mkt_cap = b.Market_cap,
        a.mkt_cap_5 = b.Market_cap_5,
        a.mth_turnover = b.Monthly_turnover;

    drop temporary table IF EXISTS tmp_grade;
    CREATE TEMPORARY TABLE tmp_grade
    (
        list_market_id		varchar(16) null,
        product_id		    varchar(36) null,
        haircut             DECIMAL(30,10) null
    );

    -- insert into tmp_grade
    -- select * from v_product_haircut_percent;

    -- update RESULT_SET1 a
    -- left join tmp_grade b on b.list_market_id = 1 and b.product_id = a.product_id
    -- set a.frr_grade_code = case when ifnull(b.haircut,'') = 0.15 then 'A' 
    --                             when ifnull(b.haircut,'') = 0.3 then 'B' 
    --                             when ifnull(b.haircut,'') = 0.5 then 'C' 
    --                             when ifnull(b.haircut,'') = 1 then 'D'
    --                             else '' end;

    update RESULT_SET1 a
    left join `basicdata`.`index_component` b on b.code = a.product_id and b.exchange = 'HKEX' and b.index_code = 'HSI'
    set a.frr_grade_code = case when ifnull(b.code,'') = '' then '' else 'A' end;

    drop temporary table IF EXISTS report;
    CREATE TEMPORARY TABLE report
    (
        product_id		varchar(128) null,
        name			varchar(128) null,
        qty				varchar(36) null,
        mv				varchar(36) null,
        mkt_cap			varchar(36) null,
        mkt_cap_5		varchar(36) null,
        mth_turnover	varchar(36) null,
        a_b				varchar(32) null,
        a_c				varchar(32) null,
        month_6			varchar(32) null,
        Illquid         varchar(32) null,
        frr_grade_code	varchar(32) null
    );

    insert into report
    select 'Code','Name', 'NetBalQty','MarketValue','MarketCap.(A)',
           '5%MarketCap.(B)','MonthlyTurnover(C)','(A)>(B)','(A)>(C)','>6M?',
           'IllQuid?','FRR Grade';

    insert into report
    select  
        concat(product_id,':HK'),
        name,
        round(qty,0),
        round(mv,2),
        round(mkt_cap,2),
        round(mkt_cap_5,2),
        round(mth_turnover,2),
        a_b,
        a_c,
        a.month_6,
        case when month_6 = 'Y' and (a_b = 'Y' or a_c = 'Y') then 'Y' else 'N' end illiquid,
        frr_grade_code
    from RESULT_SET1 a;


    select round(sum(mv),2)
    into v_20_mv
    from RESULT_SET1;

    insert into report(product_id,name,qty,mv)
    value ('Sub-Total:','','', round(v_20_mv,2));
    
    select round(sum(/*market_value*/ round(a.net_quantity *a.closing_price,2) * round((case when b.exchange_rate is null then c.exchange_rate else b.exchange_rate end),6)),2) 
    into v_total_mv
    from account_position a
    left join currency_history b on b.process_date = a.process_date and b.currency = a.currency
    left join currency c on c.currency = a.currency
    inner join product on product.product_id = a.product_id
    where a.process_date = i_process_date and account_type = 2;

    insert into report(product_id,name,qty,mv)
    value ('Other Securities Collateral For All Margin Clients:','','', round(v_total_mv - v_20_mv,2));

    insert into report(product_id,name,qty,mv)
    value ('Total Securities Collateral For All Margin Clients:','','', round(v_total_mv,2));

    select * from report;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportIpoSubscription
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportIpoSubscription`;
delimiter ;;
CREATE PROCEDURE `proExportIpoSubscription`(IN i_process_date DATE,
    IN i_ipo_id varchar(64))
label:BEGIN
    DECLARE v_process_date DATE;

    select buss_date into v_process_date from sys_info;

    if i_process_date > v_process_date then
        -- leave label;
        set i_process_date = v_process_date;
    end if; 

    drop temporary table IF EXISTS tmp_rpt;
    CREATE TEMPORARY TABLE tmp_rpt
    (
        group_key              VARCHAR(8),
        product_id             VARCHAR(32),
        product_name           VARCHAR(256),
        default_interest_rate  VARCHAR(32),
        interest_day           VARCHAR(32),
        max_margin_ratio       VARCHAR(32),
        max_loan_amount        VARCHAR(32),
        default_charge         VARCHAR(32),
        default_loan_charge    VARCHAR(32),
        start_time             VARCHAR(32),
        close_time             VARCHAR(32),
        margin_close_time      VARCHAR(32),
        allot_date             VARCHAR(32),
        allot_price            VARCHAR(32),
        ae_code                VARCHAR(32),
        client_acc_id          VARCHAR(32),
        client_acc_name        VARCHAR(256),
        id                     VARCHAR(32),
        ccy                    VARCHAR(8),
        app_posted             VARCHAR(8),
        amount                 VARCHAR(32),
        qty                    VARCHAR(32),
        loan_ratio             VARCHAR(32),
        loan_amount            VARCHAR(32),
        charges                VARCHAR(32),
        interest_rate          VARCHAR(32),
        interest               VARCHAR(32),
        refund_amount          VARCHAR(32),
        actual_qty             VARCHAR(32),
        actual_turnover        VARCHAR(32),
        t0_amt                 VARCHAR(32)
    );

    drop temporary table IF EXISTS tmp_rpt_detail;
    CREATE TEMPORARY TABLE tmp_rpt_detail
    (
        group_key         VARCHAR(8),
        product_id             VARCHAR(32),
        product_name           VARCHAR(256),
        default_interest_rate  INT,
        interest_day           INT,
        max_margin_ratio       INT,
        max_loan_amount        DECIMAL(30,10),
        default_charge         DECIMAL(30,10),
        default_loan_charge    DECIMAL(30,10),
        start_time             DATETIME,
        close_time             DATETIME,
        margin_close_time      DATETIME,
        allot_date             DATE,
        allot_price            DECIMAL(30,10),
        ae_code                VARCHAR(32),
        client_acc_id          VARCHAR(32),
        client_acc_name        VARCHAR(256),
        id                     VARCHAR(32),
        ccy                    VARCHAR(8),
        app_posted             VARCHAR(8),
        amount                 DECIMAL(30,10),
        qty                    INT,
        loan_ratio             INT,
        loan_amount            DECIMAL(30,10),
        charges                DECIMAL(30,10),
        interest_rate          DECIMAL(30,10),
        interest               DECIMAL(30,10),
        refund_amount          DECIMAL(30,10),
        actual_qty             INT,
        actual_turnover        DECIMAL(30,10),
        t0_amt                 DECIMAL(30,10)
    );

    drop temporary table IF EXISTS tmp_trade;
    CREATE TEMPORARY TABLE tmp_trade
    (
        account_id             VARCHAR(16),
        clearing_currency           VARCHAR(3),
        amount  DECIMAL(30,10)
    );
    create index Index1 on tmp_trade (account_id,clearing_currency);

    insert into tmp_trade
    select 
        account_id,
        clearing_currency,
        round(sum(case buy_sell when 1 then -1 else 1 end * net_amount * exchange_rate),6) as amount
    from account_trade
    where settle_date = i_process_date and status = 'Confirmed' group by account_id,clearing_currency;

    insert into tmp_rpt_detail
    select 
        case a.sub_status when 1 then 'IPO' else 'PLACING' end as group_key,
        concat(a.product_id,':',(case b.list_market_id when 1 then 'HK' when 2 then 'US' when 4  then 'SHA' when 8 then  'SZA' WHEN 16 then 'OTC' end)) as product_id,
        b.product_name as product_name,
        round(b.interest_rate,2) as default_interest_rate,
        b.interest_day as interest_day,
        round(b.max_loan_ratio,2) as max_margin_ratio,
        round(b.max_loan_amount,2) as max_loan_amt,
        round(b.charge,2) as default_charge,
        round(b.loan_charge,2) as default_loan_charge,
        b.start_time,
        b.close_time,
        b.margin_close_time,
        b.allot_date,
        round(a.allot_price,6) as allot_price,
        c.ae_id as ae_code,
        a.account_id as client_acc_id,
        concat('"',d.short_name,'"') as client_acc_name,
        b.ipo_id as id,
        case b.currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end as ccy,
        a.refund_posted,
        round(a.amount,2) as amount,
        a.quantity as qty,
        round(a.loan_ratio,2) as loan_ratio,
        round(a.loan_amount,2) as loan_amount,
        round((a.charge + a.loan_charge),2) as charges,
        round(a.interest_rate,2) as interest_rate,
        round(a.interest,2) as interest,
        round(a.refund_amount,2) as refund_amount,
        round(a.allot_qty,2) as actual_qty,
        round(a.amount,2) -round(a.refund_amount,2) as actual_turnover, -- round(a.allot_qty * a.allot_price * 1.010077,2) as actual_turnover,
        round(ifnull(e.settle_balance,0) + if(i_process_date < v_process_date,0,ifnull(f.amount,0)),2) as t0_amt
    from product_ipo_app a
    inner join product_ipo_announcement b on a.ipo_id = b.ipo_id
    inner join capital_account c on a.account_id = c.account_id
    inner join account_profile d on d.account_id = a.account_id
    left join account_balance e on e.process_date = i_process_date and e.account_id = a.account_id and e.currency = a.currency
    left join tmp_trade f on f.account_id = a.account_id and f.clearing_currency = a.currency
    where a.ipo_id = i_ipo_id
    order by a.account_id;

    insert into tmp_rpt select *From tmp_rpt_detail;

    insert into tmp_rpt
    select 
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        sum(amount),
        sum(qty),
        '',
        sum(loan_amount),
        sum(charges),
        '',
        sum(interest),
        sum(refund_amount),
        sum(actual_qty),
        sum(actual_turnover),
        ''
    from tmp_rpt_detail;

    select * From tmp_rpt;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportIpoSubscriptionQuery
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportIpoSubscriptionQuery`;
delimiter ;;
CREATE PROCEDURE `proExportIpoSubscriptionQuery`(IN i_close_date_beg   VARCHAR(16),
    IN i_close_date_end   VARCHAR(16),
    IN i_allot_date_beg   VARCHAR(16),
    IN i_allot_date_end   VARCHAR(16),
    IN i_account_id VARCHAR(32),
    IN i_market_id  INT,
    IN i_product_id VARCHAR(32))
label:BEGIN

    SELECT
        CONCAT(a.list_market_id,'(',CASE a.list_market_id WHEN 1 THEN 'HK' WHEN 2 THEN 'US' ELSE a.list_market_id END,')') AS list_market_id,
        a.product_id,
        REPLACE(b.product_name,',',' ') AS product_name,
        ROUND(b.interest_rate,4) AS default_interest_rate,
        b.interest_day,
        ROUND(b.max_loan_ratio,4) AS max_margin_ratio,
        ROUND(b.max_loan_amount,4) AS max_loan_amount,
        ROUND(b.charge,4) AS default_charge,
        ROUND(b.loan_charge,2) AS default_loan_charge,
        b.start_time,
        b.close_time,
        b.margin_close_time,
        b.allot_date,
        ROUND(a.allot_price,6) AS allot_price,
        c.ae_id as ae_code,
        a.account_id,
        concat('"',d.short_name,'"'),
        b.ipo_id,
        CONCAT(b.currency,'(',CASE b.currency WHEN 1 THEN 'CNY' WHEN 2 THEN 'HKD' WHEN 4 THEN 'USD' ELSE b.currency END,')')AS currency,
        b.app_posted,
        round(a.amount,2) as amount,
        round(a.quantity,0) as qty,
        round(a.loan_ratio,0) as loan_ratio,
        round(a.loan_amount,2) as loan_amount,
        round((a.charge + a.loan_charge),2) as charges,
        round(a.interest_rate,0) as interest_rate,
        round(a.interest,2) as interest,
        round(a.refund_amount,2) as refund_amount,
        round(a.allot_qty,0) as actual_qty,
        round(a.amount,2)-round(a.refund_amount,2) as actual_turnover
    FROM product_ipo_app a
    LEFT JOIN product_ipo_announcement b ON a.ipo_id = b.ipo_id
    LEFT JOIN capital_account c ON a.account_id = c.account_id
    LEFT JOIN account_profile d ON d.account_id = a.account_id
    WHERE   (i_close_date_beg = '' OR DATE(close_time) >= i_close_date_beg)
        AND (i_close_date_end = '' OR DATE(close_time) <= i_close_date_end)
        AND (i_allot_date_beg = '' OR allot_date       >= i_allot_date_beg)
        AND (i_allot_date_end = '' OR allot_date       <= i_allot_date_end)
        AND (i_account_id     = '' OR a.account_id      = i_account_id)
        AND (i_market_id      = 0  OR a.list_market_id  = i_market_id) 
        AND (i_product_id     = '' OR a.product_id      = i_product_id)
        ORDER BY a.account_id;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportMarginCallForSecuritiesReportBR020
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportMarginCallForSecuritiesReportBR020`;
delimiter ;;
CREATE PROCEDURE `proExportMarginCallForSecuritiesReportBR020`(IN i_process_date DATE)
label:BEGIN
 
    declare v_done int; 
    DECLARE v_currency varchar(16);
    DECLARE v_ccy varchar(16);
    DECLARE v_ae_id varchar(16);
    DECLARE v_real_month_first_day date;

    DECLARE cur_balance CURSOR FOR 
    select currency
    from account_balance 
    where process_date = i_process_date
    group by currency;

    DECLARE cur_ae CURSOR FOR 
    select ifnull(ae_id,'11111111') as ae_id
    from capital_account 
    group by ifnull(ae_id,'11111111');

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1; 
    
    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    select min(calendar_day) into v_real_month_first_day from calendar where date_format(calendar_day,'%Y%m') = date_format(i_process_date,'%Y%m') ; 

    drop temporary table IF EXISTS tmp_export;
    CREATE TEMPORARY TABLE tmp_export 
    (
        `Client_AC`     VARCHAR(16) NULL DEFAULT NULL,
        `Client_Name`   VARCHAR(128) NULL DEFAULT NULL,
        `AE`            varchar(32) NULL DEFAULT NULL,
        `Currency`      varchar(32) NULL DEFAULT NULL,
        `Avail_CashT`   CHAR(32) NULL DEFAULT NULL,
        `Market_valueT` varchar(32) NULL DEFAULT NULL,
        `MarginValueT`  CHAR(32) NULL DEFAULT NULL,
        `MarginCallT`   varchar(32) NULL DEFAULT NULL,
        `Avail_Cash`    CHAR(32) NULL DEFAULT NULL,
        `Market_value`  varchar(32) NULL DEFAULT NULL,
        `MarginValue`   CHAR(32) NULL DEFAULT NULL,
        `MarginCall`    varchar(32) NULL DEFAULT NULL
    );

    drop temporary table IF EXISTS tmp_balance;
    CREATE TEMPORARY TABLE tmp_balance 
    (
        `Client_AC`     VARCHAR(16) NULL DEFAULT NULL,
        `Client_Name`   VARCHAR(128) NULL DEFAULT NULL,
        `AE_ID`            varchar(32) NULL DEFAULT NULL,
        `Currency`      varchar(32) NULL DEFAULT NULL,
        `Avail_CashT`   DECIMAL(30,10) NULL DEFAULT 0.00,
        `Market_valueT` DECIMAL(30,10) NULL DEFAULT 0.00,
        `MarginValueT`  DECIMAL(30,10) NULL DEFAULT 0.00,
        `MarginCallT`   DECIMAL(30,10) NULL DEFAULT 0.00,
        `Avail_Cash`    DECIMAL(30,10) NULL DEFAULT 0.00,
        `Market_value`  DECIMAL(30,10) NULL DEFAULT 0.00,
        `MarginValue`   DECIMAL(30,10) NULL DEFAULT 0.00,
        `MarginCall`    DECIMAL(30,10) NULL DEFAULT 0.00,
        INDEX `idx1` (`Currency`, `AE_ID`)
    );

    insert into tmp_export
    select 
        '','','',
        '','','Balance(T)',
        '','','',
        'Net Balance','','';

    insert into tmp_export
    select
        'Client A/C',
        '',
        'AE',
        '',
        'Avail.Cash',
        'Market Value',
        'Marginable Value',
        'Margin Call',
        'Avail.Cash',
        'Market Value',
        'Marginable Value',
        'Margin Call';

    open cur_balance; 
    set v_done = 0; 
    fetch cur_balance into v_currency; 
    while v_done <> 1 do 

        set v_ccy = case v_currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end;
        
        if EXISTS(select 1 from account_balance a 
                    left join (
                        SELECT account_id, currency, SUM(IF(purpose=1,amount,0)-IF(purpose=2,amount,0))AS amt FROM cash_flow_cit WHERE process_date<=i_process_date GROUP BY account_id,currency
                    ) b on b.account_id = a.account_id and b.currency = a.currency
                    where a.process_date = i_process_date and a.currency = v_currency and (a.trade_balance - b.amt) < 0) then 
            insert into tmp_balance
            select 
                a.account_id,
                replace(b.short_name,',',' '),
                ifnull(c.ae_id,'11111111') as ae_id,
                a.currency,
                a.settle_balance as balT,
                ifnull(e.t0_mv,0),
                if(a.account_type = 1,0,ifnull(e.loan_t0_mv,0)) as LVT,
                case when a.settle_balance > 0 then 0 else a.settle_balance end as MCallT,
                (a.trade_balance - ifnull(f.amount,0) - ifnull(g.db_interest,0) + ifnull(g.cr_interest,0)) as bal,
                ifnull(e.mv,0) as MV,
                if(a.account_type = 1,0,ifnull(e.loan_mv,0)) as LV,
                case when (a.trade_balance - ifnull(f.amount,0) - ifnull(g.db_interest,0) + ifnull(g.cr_interest,0)) > 0 then 0 
                    else (a.trade_balance - ifnull(f.amount,0) - ifnull(g.db_interest,0) + ifnull(g.cr_interest,0)) end as MCall
            from account_balance a
            inner join account_profile b on b.account_id = a.account_id
            inner join capital_account c on c.account_id = a.account_id
            left join(
                select 
                    po.account_id as account_id,
                    po.currency as currency,
                    round(sum(po.quantity * po.closing_price),2) as t0_mv,
                    round(sum(po.net_quantity * po.closing_price),2) as mv,
                    round(sum(po.quantity * po.closing_price * pr.loan_ratio / 100),2) as loan_t0_mv,
                    round(sum((po.net_quantity * po.closing_price) * pr.loan_ratio / 100),2) as loan_mv
                from account_position po
                inner join product pr on po.product_id = pr.product_id 
                where po.process_date = i_process_date
                group by po.account_id,po.currency
            ) e on e.account_id = a.account_id and e.currency = a.currency
            left join (
                    select account_id,currency,sum(case purpose when 1 then 1 else -1 end * amount) as amount
                    from cash_flow_cit 
                    where process_date <= i_process_date group by account_id,currency
            ) f on f.account_id = a.account_id and f.currency = a.currency
            left join (
                select account_id,currency,sum(debit_interest) as db_interest,sum(credit_interest) as cr_interest 
                from account_interest where process_date >= v_real_month_first_day and process_date <= i_process_date and currency = v_currency group by account_id,currency
            ) g on g.account_id = a.account_id and g.currency = a.currency
            where a.process_date = i_process_date and a.currency = v_currency and 
                (a.trade_balance - ifnull(f.amount,0) - g.db_interest + g.cr_interest) < 0;

            open cur_ae; 
            set v_done = 0; 
            fetch cur_ae into v_ae_id; 
            while v_done <> 1 do 

                if EXISTS(select 1 from tmp_balance where Currency = v_currency and AE_ID = v_ae_id) then
                    insert into tmp_export
                    select 
                        Client_AC,
                        Client_Name,
                        AE_ID,
                        v_ccy,
                        round(Avail_CashT,2),
                        round(Market_valueT,2),
                        round(MarginValueT,2),
                        round(MarginCallT,2),
                        round(Avail_Cash,2),
                        round(Market_value,2),
                        round(MarginValue,2),
                        round(MarginCall,2)
                    from tmp_balance where Currency = v_currency and AE_ID = v_ae_id order by Client_AC;

                    insert into tmp_export
                    select 
                        '',
                        '',
                        '',
                        v_ccy,
                        round(sum(Avail_CashT),2),
                        round(sum(Market_valueT),2),
                        round(sum(MarginValueT),2),
                        round(sum(MarginCallT),2),
                        round(sum(Avail_Cash),2),
                        round(sum(Market_value),2),
                        round(sum(MarginValue),2),
                        round(sum(MarginCall),2)
                    from tmp_balance where Currency = v_currency and AE_ID = v_ae_id;
                end if;

                set v_done = 0; 
                fetch cur_ae into v_ae_id; 
            end while; 
            close cur_ae;

            insert into tmp_export
            select 
                '','',
                'Total',
                v_ccy,
                round(sum(Avail_CashT),2),
                round(sum(Market_valueT),2),
                round(sum(MarginValueT),2),
                round(sum(MarginCallT),2),
                round(sum(Avail_Cash),2),
                round(sum(Market_value),2),
                round(sum(MarginValue),2),
                round(sum(MarginCall),2)
            from tmp_balance where Currency = v_currency;
        end if;

        set v_done = 0; 
        fetch cur_balance into v_currency; 
    end while; 
    close cur_balance;

    select * from tmp_export a;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportOptionsPosition
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportOptionsPosition`;
delimiter ;;
CREATE PROCEDURE `proExportOptionsPosition`(IN i_process_date DATE)
label:BEGIN
 
    declare v_done int; 
    declare v_hk_1t date;
    declare v_hk_t1 date; 
    declare v_hk_t2 date; 
    
    declare v_us_1t date;
    declare v_us_t1 date; 
    declare v_us_t2 date; 

    declare v_csc_1t date;
    declare v_csc_t1 date; 
    declare v_csc_t2 date; 

    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    select max(calendar_day) into v_hk_1t from calendar where calendar_day<DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and market_id = 1 and holiday in('N','S'); 
    select min(calendar_day) into v_hk_t1 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and market_id = 1 and holiday in('N','S'); 
    select min(calendar_day) into v_hk_t2 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(v_hk_t1,INTERVAL 0 DAY),'%Y%m%d') and market_id = 1 and holiday in('N','S'); 

    select max(calendar_day) into v_us_1t from calendar where calendar_day<DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and market_id in(2,16) and holiday in('N','S'); 
    select min(calendar_day) into v_us_t1 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and market_id in(2,16) and holiday in('N','S'); 
    select min(calendar_day) into v_us_t2 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(v_us_t1,INTERVAL 0 DAY),'%Y%m%d') and market_id in(2,16) and holiday in('N','S'); 

    select max(calendar_day) into v_csc_1t from calendar where calendar_day<DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and market_id in (4,8) and holiday in('N','S'); 
    select min(calendar_day) into v_csc_t1 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and market_id in (4,8) and holiday in('N','S'); 
    select min(calendar_day) into v_csc_t2 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(v_csc_t1,INTERVAL 0 DAY),'%Y%m%d') and market_id in (4,8) and holiday in('N','S'); 

    drop temporary table IF EXISTS tmp_export;
    CREATE TEMPORARY TABLE tmp_export 
    (
        process_date            VARCHAR(32) NULL DEFAULT NULL,
        `account`               VARCHAR(16) NULL DEFAULT NULL,
        `product_id`            VARCHAR(32) NULL DEFAULT NULL,
        `custodian_acc_id`      VARCHAR(32) NULL DEFAULT NULL,
        `buss_date`             VARCHAR(32) NULL DEFAULT NULL,
        `buss_date_1`           VARCHAR(32) NULL DEFAULT NULL,
        `buss_date_2`           VARCHAR(32) NULL DEFAULT NULL,
        `product_code`          VARCHAR(32) NULL DEFAULT NULL,
        `product_name`          VARCHAR(128) NULL DEFAULT NULL,
        `ccy`                   VARCHAR(16) NULL DEFAULT NULL,
        `closing_price`         VARCHAR(32) NULL DEFAULT NULL,
        `prev_close`            VARCHAR(32) NULL DEFAULT NULL,
        `prev_qty`              VARCHAR(32) NULL DEFAULT NULL,
        `t0_qty`                VARCHAR(32) NULL DEFAULT NULL,
        `t1_qty`                VARCHAR(32) NULL DEFAULT NULL,
        `t2_qty`                VARCHAR(32) NULL DEFAULT NULL,
        `t0_mv`                 VARCHAR(32) NULL DEFAULT NULL,
        `t1_mv`                 VARCHAR(32) NULL DEFAULT NULL,
        `t2_mv`                 VARCHAR(32) NULL DEFAULT NULL,
        `client_acc_name`       VARCHAR(128) NULL DEFAULT NULL
    );

    drop temporary table IF EXISTS tmp_position;
    CREATE TEMPORARY TABLE tmp_position 
    (
        process_date            date,
        `account`               VARCHAR(16) NULL DEFAULT NULL,
        `product_id`            VARCHAR(32) NULL DEFAULT NULL,
        `custodian_acc_id`      VARCHAR(32) NULL DEFAULT NULL,
        `buss_date`             DATE NULL DEFAULT NULL,
        `buss_date_1`           DATE NULL DEFAULT NULL,
        `buss_date_2`           DATE NULL DEFAULT NULL,
        `product_code`          VARCHAR(32) NULL DEFAULT NULL,
        `product_name`          VARCHAR(128) NULL DEFAULT NULL,
        `ccy`                   VARCHAR(16) NULL DEFAULT NULL,
        `closing_price`         DECIMAL(30,10) NULL DEFAULT 0.00,
        `prev_close`            DECIMAL(30,10) NULL DEFAULT 0.00,
        `prev_qty`              DECIMAL(30,10) NULL DEFAULT 0.00,
        `t0_qty`                DECIMAL(30,10) NULL DEFAULT 0.00,
        `t1_qty`                DECIMAL(30,10) NULL DEFAULT 0.00,
        `t2_qty`                DECIMAL(30,10) NULL DEFAULT 0.00,
        `t0_mv`                 DECIMAL(30,10) NULL DEFAULT 0.00,
        `t1_mv`                 DECIMAL(30,10) NULL DEFAULT 0.00,
        `t2_mv`                 DECIMAL(30,10) NULL DEFAULT 0.00,
        `client_acc_name`       VARCHAR(128) NULL DEFAULT NULL
    );

    drop temporary table if exists tmp; 
    create temporary table tmp 
    select account_id,product_id,custodian_code,custodian_account,
            sum(case buy_sell when 1 then 1 else -1 end * quantity) as qty, 
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as amt
        from account_trade where settle_date = v_hk_t1 and list_market_id = 1 and status = 'Confirmed'
        group by account_id,product_id,custodian_code,custodian_account; 
    create index idx on tmp(account_id, product_id, custodian_code, custodian_account);    

    drop temporary table if exists tmp2; 
    create temporary table tmp2 
    select account_id,product_id,custodian_code,custodian_account,
            sum(case buy_sell when 1 then 1 else -1 end * quantity) as qty, 
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as amt
        from account_trade 
        where settle_date = v_hk_t2 and list_market_id = 1 and status = 'Confirmed' group by account_id,product_id,custodian_code,custodian_account;
    create index idx on tmp2(account_id, product_id, custodian_code, custodian_account);

    -- HK
    insert into tmp_position
    select 
        i_process_date,
        a.account_id,
        concat(a.product_id,':',(case a.market_id when 1 then 'HK' when 2 then 'US' when 4 then 'SHA' when 8 then 'SZA' when 16 then 'OTC' end)) as product_id,
        concat(a.custodian_account,':',a.custodian_code) as custodian_acc_id,
        a.process_date as buss_date,
        v_hk_t1 as buss_date_1,
        v_hk_t2 as buss_date_2,
        a.product_id as product_code,
        replace(b.product_description,',','') as product_name,
        case a.currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end as ccy,
        a.closing_price as closing_price,
        ifnull(c.closing_price,0) as prev_close,
        ifnull(c.quantity,0) as prev_qty,
        a.quantity as t0_qty,
        a.quantity + ifnull(f.qty,0) as t1_qty,
        a.net_quantity as t2_qty,
        round(a.quantity * a.closing_price * b.price_factor,2) as t0_mv,
        round((a.quantity + ifnull(f.qty,0)) * a.closing_price * b.price_factor,2) as t1_mv,
        round((a.net_quantity *a.closing_price * b.price_factor),2) as t2_mv,
        replace(d.short_name,',',' ')
    from account_position a 
    inner join product b on a.market_id = b.list_market_id and a.product_id = b.product_id 
    left join account_position c on c.process_date = v_hk_1t and c.market_id = a.market_id and 
                c.product_id = a.product_id and c.account_id = a.account_id and 
                c.custodian_code = a.custodian_code and 
                c.custodian_account = a.custodian_account
    inner join account_profile d on d.account_id = a.account_id
    inner join capital_account e on e.account_id = a.account_id
    left join tmp f on f.account_id = a.account_id and f.product_id = a.product_id and f.custodian_code = a.custodian_code and f.custodian_account = a.custodian_account
    left join tmp2 g on g.account_id = a.account_id and g.product_id = a.product_id and g.custodian_code = a.custodian_code and g.custodian_account = a.custodian_account
    where a.process_date = i_process_date and a.market_id = 1 and a.product_type = 16
    order by a.currency,a.account_id,a.market_id,a.product_id,a.custodian_code,a.custodian_account;
    
    -- CSC
    drop temporary table if exists tmp; 
    create temporary table tmp 
    select account_id,product_id,custodian_code,custodian_account,
            sum(case buy_sell when 1 then 1 else -1 end * quantity) as qty, 
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as amt
        from account_trade where settle_date = v_csc_t1 and list_market_id in (4,8) and status = 'Confirmed' group by account_id,product_id,custodian_code,custodian_account; 
    create index idx on tmp(account_id, product_id, custodian_code, custodian_account);    

    drop temporary table if exists tmp2; 
    create temporary table tmp2 
    select account_id,product_id,custodian_code,custodian_account,
            sum(case buy_sell when 1 then 1 else -1 end * quantity) as qty, 
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as amt
        from account_trade 
        where settle_date = v_csc_t2 and list_market_id in (4,8) and status = 'Confirmed' group by account_id,product_id,custodian_code,custodian_account;
    create index idx on tmp2(account_id, product_id, custodian_code, custodian_account);


    insert into tmp_position
    select 
        i_process_date,
        a.account_id,
        concat(a.product_id,':',(case a.market_id when 1 then 'HK' when 2 then 'US' when 4 then 'SHA' when 8 then 'SZA' when 16 then 'OTC' end)) as product_id,
        concat(a.custodian_account,':',a.custodian_code) as custodian_acc_id,
        a.process_date as buss_date,
        v_hk_t1 as buss_date_1,
        v_hk_t2 as buss_date_2,
        a.product_id as product_code,
        replace(b.product_description,',','') as product_name,
        case a.currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end as ccy,
        a.closing_price as closing_price,
        ifnull(c.closing_price,0) as prev_close,
        ifnull(c.quantity,0) as prev_qty,
        a.quantity as t0_qty,
        a.quantity + ifnull(f.qty,0) as t1_qty,
        a.net_quantity as t2_qty,
        round(a.quantity * a.closing_price * b.price_factor,2) as t0_mv,
        round((a.quantity + ifnull(f.qty,0)) * a.closing_price * b.price_factor,2) as t1_mv,
        round((a.net_quantity *a.closing_price * b.price_factor),2) as t2_mv,
        replace(d.short_name,',',' ')
    from account_position a 
    inner join product b on a.market_id = b.list_market_id and a.product_id = b.product_id 
    left join account_position c on c.process_date = v_csc_1t and c.market_id = a.market_id and 
                c.product_id = a.product_id and c.account_id = a.account_id and 
                c.custodian_code = a.custodian_code and 
                c.custodian_account = a.custodian_account
    inner join account_profile d on d.account_id = a.account_id
    inner join capital_account e on e.account_id = a.account_id
    left join tmp f on f.account_id = a.account_id and f.product_id = a.product_id and f.custodian_code = a.custodian_code and f.custodian_account = a.custodian_account
    left join tmp2 g on g.account_id = a.account_id and g.product_id = a.product_id and g.custodian_code = a.custodian_code and g.custodian_account = a.custodian_account
    where a.process_date = i_process_date and a.market_id in (4,8) and a.product_type = 16
    order by a.currency,a.account_id,a.market_id,a.product_id,a.custodian_code,a.custodian_account;
    
    -- US
    drop temporary table if exists tmp; 
    create temporary table tmp 
    select account_id,product_id,custodian_code,custodian_account,
            sum(case buy_sell when 1 then 1 else -1 end * quantity) as qty, 
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as amt
        from account_trade where settle_date = v_us_t1 and list_market_id in (2,16) and status = 'Confirmed' group by account_id,product_id,custodian_code,custodian_account;
    create index idx on tmp(account_id, product_id, custodian_code, custodian_account);    

    drop temporary table if exists tmp2; 
    create temporary table tmp2 
    select account_id,product_id,custodian_code,custodian_account,
            sum(case buy_sell when 1 then 1 else -1 end * quantity) as qty, 
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as amt
        from account_trade 
        where settle_date = v_us_t2 and list_market_id in (2,16) and status = 'Confirmed' group by account_id,product_id,custodian_code,custodian_account;
    create index idx on tmp2(account_id, product_id, custodian_code, custodian_account);

    insert into tmp_position
    select 
        i_process_date,
        a.account_id,
        concat(a.product_id,':',(case a.market_id when 1 then 'HK' when 2 then 'US' when 4 then 'SHA' when 8 then 'SZA' when 16 then 'OTC' end)) as product_id,
        concat(a.custodian_account,':',a.custodian_code) as custodian_acc_id,
        a.process_date as buss_date,
        v_hk_t1 as buss_date_1,
        v_hk_t2 as buss_date_2,
        a.product_id as product_code,
        replace(b.product_description,',','') as product_name,
        case a.currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end as ccy,
        a.closing_price as closing_price,
        ifnull(c.closing_price,0) as prev_close,
        ifnull(c.quantity,0) as prev_qty,
        a.quantity as t0_qty,
        a.quantity + ifnull(f.qty,0) as t1_qty,
        a.net_quantity as t2_qty,
        round(a.quantity * a.closing_price * b.price_factor,2) as t0_mv,
        round((a.quantity + ifnull(f.qty,0)) * a.closing_price * b.price_factor,2) as t1_mv,
        round((a.net_quantity *a.closing_price * b.price_factor),2) as t2_mv,
        replace(d.short_name,',',' ')
    from account_position a 
    inner join product b on a.market_id = b.list_market_id and a.product_id = b.product_id 
    left join account_position c on c.process_date = v_us_1t and c.market_id = a.market_id and 
                c.product_id = a.product_id and c.account_id = a.account_id and c.custodian_code = a.custodian_code and 
                c.custodian_account = a.custodian_account
    inner join account_profile d on d.account_id = a.account_id
    inner join capital_account e on e.account_id = a.account_id
    left join tmp f on f.account_id = a.account_id and f.product_id = a.product_id and f.custodian_code = a.custodian_code and f.custodian_account = a.custodian_account
    left join tmp2 g on g.account_id = a.account_id and g.product_id = a.product_id and g.custodian_code = a.custodian_code and g.custodian_account = a.custodian_account
    where a.process_date = i_process_date and a.market_id in (2,16) and a.product_type = 16
    order by a.currency,a.account_id,a.market_id,a.product_id,a.custodian_code,a.custodian_account;

    drop temporary table IF EXISTS tmp_position_2;
    CREATE TEMPORARY TABLE tmp_position_2 as
    select * from tmp_position where (t0_qty <> 0 or t1_qty <> 0 or t2_qty <> 0);

    insert into tmp_export
    select * from tmp_position_2;

    insert into tmp_export(
        process_date,
        buss_date,buss_date_1,buss_date_2,
        t0_qty,t1_qty,t2_qty,
        t2_mv,t1_mv,t0_mv
    )
    select 
        'Total',
        buss_date,buss_date_1,buss_date_2,
        sum(t0_qty),sum(t1_qty),sum(t2_qty),
        sum(t2_mv),sum(t1_mv),sum(t0_mv)
    from tmp_position_2;

    select * from tmp_export; 

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportOptionsTrade
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportOptionsTrade`;
delimiter ;;
CREATE PROCEDURE `proExportOptionsTrade`(IN i_process_date   DATE)
label:BEGIN



drop temporary table IF EXISTS tmp_detail;
CREATE TEMPORARY TABLE tmp_detail as 
SELECT
    process_date,
    trade_id,
    MIN(trade_exec_id) AS trade_exec_id,
    exec_price AS price,
    SUM(exec_quantity)AS qty,
    SUM(trade_amount) AS trade_amount,
    SUM(commission) AS commission,
    SUM(charges) AS charges
FROM account_trade_detail
WHERE i_process_date = process_date GROUP BY process_date,trade_id,exec_price;
create index idx1 on tmp_detail(process_date, trade_id);

drop temporary table IF EXISTS tmp_charge;
CREATE TEMPORARY TABLE tmp_charge as 
SELECT
    process_date,
    external_id,
    SUM(charges) AS other_charges
FROM account_charge
WHERE formula_type <> 'COMM' AND IFNULL(external_id2,'') = ''
AND process_date = i_process_date GROUP BY process_date,external_id;
create index idx1 on tmp_charge(process_date, external_id);

SELECT
a.process_date,
a.trade_date,
a.settle_date,
case a.list_market_id when 1 then 'HK' when 2 then 'US' when 4 then 'SH' when 8 then 'SZ' when 16 then 'OTC' end,
a.product_id,
REPLACE(a.product_description,',',' ') AS product_description,
a.account_id,
REPLACE(b.short_name,',',' ') AS short_name,
(CASE b.account_class WHEN'1'THEN b.party_country WHEN'3'THEN b.photo_country ELSE NULL END) AS nationality,
(CASE b.account_class WHEN'1'THEN b.partyid       WHEN'3'THEN b.photoid       ELSE NULL END) AS id_code,
IF(a.buy_sell=1,c.qty,NULL)AS bought, -- IF(a.buy_sell=1,a.quantity,NULL)AS Bought,
IF(a.buy_sell=2,c.qty,NULL)AS sold, -- IF(a.buy_sell=2,a.quantity,NULL)AS Sold,
c.price, -- a.avg_price AS price,
c.trade_amount,
CASE c.trade_exec_id WHEN 1 THEN a.commission ELSE 0 END AS commission,
CASE c.trade_exec_id WHEN 1 THEN IFNULL(d.other_charges,0) ELSE 0 END AS other_charges,
c.charges AS charges,
b.phone1 AS contact_phone_no,
REPLACE(IFNULL(b.address1,b.mailing_address),',','') AS address_of_ultimat_client,
ifnull(a.broker,'') AS broker_for_farm_out_trade,
ifnull(case ca.account_type when 1 then 'Cash' when 2 then 'Margin' when 0 then 'House' end,'') AS account_type,
ifnull(dict.value,'') AS input_channel
FROM jcbms.account_trade a 
LEFT JOIN jcbms.capital_account ca ON a.account_id=ca.account_id
LEFT JOIN jcbms.account_profile b ON a.account_id=b.account_id
LEFT JOIN jcbms.dict dict on dict.class = 'ORDER' and dict.sub_class = 'CHANNEL' and dict.item = a.input_channel
LEFT JOIN tmp_detail c ON a.process_date=c.process_date AND a.trade_id=c.trade_id
LEFT JOIN tmp_charge d ON a.process_date=d.process_date AND a.trade_id=d.external_id
WHERE a.process_date = i_process_date 
        AND a.status = 'Confirmed'
        AND a.list_market_id in (2,16)
        AND a.product_type = 16 
ORDER BY a.process_date,a.account_id,a.list_market_id,a.product_id,a.buy_sell,c.price;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportPendingSettlementFundListingBR016
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportPendingSettlementFundListingBR016`;
delimiter ;;
CREATE PROCEDURE `proExportPendingSettlementFundListingBR016`(IN i_process_date DATE)
label:BEGIN
 
    declare v_done int; 
    DECLARE v_currency varchar(16);
    DECLARE v_ccy varchar(16);
    declare v_t1 date; 
    declare v_t2 date; 
    declare v_t3 date; 
    declare v_hk_1t date; 

    DECLARE cur_balance CURSOR FOR 
    select currency
    from account_balance 
    where process_date = i_process_date
    group by currency;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1; 
    
    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    select min(calendar_day) into v_t1 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and holiday <> 'Y'; 
    select min(calendar_day) into v_t2 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(v_t1,INTERVAL 0 DAY),'%Y%m%d') and holiday <> 'Y'; 
    select min(calendar_day) into v_t3 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(v_t2,INTERVAL 0 DAY),'%Y%m%d') and holiday <> 'Y'; 

    drop temporary table IF EXISTS tmp_export;
    CREATE TEMPORARY TABLE tmp_export 
    (
        `Client_AC` VARCHAR(16) NULL DEFAULT NULL,
        `Client_Name` VARCHAR(128) NULL DEFAULT NULL,
        `AE` varchar(32) NULL DEFAULT NULL,
        `Balance` varchar(32) NULL DEFAULT NULL,
        `Settle1` CHAR(32) NULL DEFAULT NULL,
        `Balance1` varchar(32) NULL DEFAULT NULL,
        `Settle2` CHAR(32) NULL DEFAULT NULL,
        `Balance2` varchar(32) NULL DEFAULT NULL,
        `Settle3` CHAR(32) NULL DEFAULT NULL,
        `Balance3` varchar(32) NULL DEFAULT NULL,
        `Settle4` CHAR(32) NULL DEFAULT NULL,
        `Balance4` varchar(32) NULL DEFAULT NULL
    );

    drop temporary table IF EXISTS tmp_balance;
    CREATE TEMPORARY TABLE tmp_balance 
    (
        `Client_AC` VARCHAR(16) NULL DEFAULT NULL,
        `Currency` varchar(16) NULL DEFAULT NULL,
        `Client_Name` VARCHAR(128) NULL DEFAULT NULL,
        `AE` varchar(32) NULL DEFAULT NULL,
        `Balance` DECIMAL(30,10) NULL DEFAULT 0.00,
        `Settle1` DECIMAL(30,10) NULL DEFAULT 0.00,
        `Balance1` DECIMAL(30,10) NULL DEFAULT 0.00,
        `Settle2` DECIMAL(30,10) NULL DEFAULT 0.00,
        `Balance2` DECIMAL(30,10) NULL DEFAULT 0.00,
        `Settle3` DECIMAL(30,10) NULL DEFAULT 0.00,
        `Balance3` DECIMAL(30,10) NULL DEFAULT 0.00,
        `Settle4` DECIMAL(30,10) NULL DEFAULT 0.00,
        `Balance4` DECIMAL(30,10) NULL DEFAULT 0.00
    );

    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    open cur_balance; 
    set v_done = 0; 
    fetch cur_balance into v_currency; 
    while v_done <> 1 do 

        set v_ccy = case v_currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end;
        
        insert into tmp_export
        select 
            '','','',
            i_process_date,
            v_t1,'',
            v_t2,'',
            v_t3,'',
            concat('> ',v_t3),'';

        insert into tmp_export
        select
            'Client A/C',
            '',
            'AE',
            'Balance(T)',
            'Pending Settle',
            'Balance',
            'Pending Settle',
            'Balance',
            'Pending Settle',
            'Balance',
            'Pending Settle',
            'Balance';

        insert into tmp_export
        select 
            'Currency',v_ccy,
            '','','','','','','','','','';

        insert into tmp_balance
        select 
            a.account_id,
            a.currency,
            replace(b.short_name,',',' '),
            c.ae_id,
            a.settle_balance,
            ifnull(d.settle_balance,0.00),
            a.settle_balance + ifnull(d.settle_balance,0.00),
            ifnull(e.settle_balance,0.00),
            a.settle_balance + ifnull(d.settle_balance,0.00) + ifnull(e.settle_balance,0.00),
            ifnull(f.settle_balance,0.00),
            a.settle_balance + ifnull(d.settle_balance,0.00) + ifnull(e.settle_balance,0.00) + ifnull(f.settle_balance,0.00),
            ifnull(g.settle_balance,0.00),
            a.settle_balance + ifnull(d.settle_balance,0.00) + ifnull(e.settle_balance,0.00) + ifnull(f.settle_balance,0.00) + ifnull(g.settle_balance,0.00)
        from account_balance a 
        left join account_profile b on a.account_id = b.account_id
        left join capital_account c on c.account_id = a.account_id
        left join (
            select process_date,settle_date,account_id,clearing_currency as currency,
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as settle_balance
            from account_trade 
            where process_date <= i_process_date and settle_date = v_t1 and status = 'Confirmed' group by settle_date,account_id,clearing_currency
        ) d on d.account_id = a.account_id and d.currency = a.currency
        left join (
            select process_date,settle_date,account_id,clearing_currency as currency,
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as settle_balance
            from account_trade 
            where process_date <= i_process_date and settle_date = v_t2 and status = 'Confirmed' group by settle_date,account_id,clearing_currency
        ) e on e.account_id = a.account_id and e.currency = a.currency
        left join (
            select process_date,settle_date,account_id,clearing_currency as currency,
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as settle_balance
            from account_trade 
            where process_date <= i_process_date and settle_date = v_t3 and status = 'Confirmed' group by settle_date,account_id,clearing_currency
        ) f on f.account_id = a.account_id and f.currency = a.currency
        left join (
            select process_date,settle_date,account_id,clearing_currency as currency,
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as settle_balance
            from account_trade 
            where process_date <= i_process_date and settle_date > v_t3 and status = 'Confirmed' group by settle_date,account_id,clearing_currency
        ) g on g.account_id = a.account_id and g.currency = a.currency
        left join (
                    select account_id,currency,sum(case purpose when 1 then 1 else -1 end * amount) as amount
                    from cash_flow_cit 
                    where process_date <= i_process_date group by account_id,currency
        ) h on h.account_id = a.account_id and h.currency = a.currency
        where a.process_date = i_process_date and a.currency = v_currency and (a.settle_balance <> 0 or (a.trade_balance - h.amt) <> 0)
        order by a.account_id;

        insert into tmp_export
        select 
            Client_AC,
            Client_Name,
            AE,
            round(Balance,2),
            round(Settle1,2),
            round(Balance1,2),
            round(Settle2,2),
            round(Balance2,2),
            round(Settle3,2),
            round(Balance3,2),
            round(Settle4,2),
            round(Balance4,2)
        from tmp_balance where Currency = v_currency order by Client_AC;

        insert into tmp_export
        select 
            '','',
            concat('Debit ', v_ccy),
            round(sum(case when Balance < 0 then 1 else 0 end * Balance),2),
            round(sum(case when Settle1 < 0 then 1 else 0 end * Settle1),2),
            round(sum(case when Balance1 < 0 then 1 else 0 end * Balance1),2),
            round(sum(case when Settle2 < 0 then 1 else 0 end * Settle2),2),
            round(sum(case when Balance2 < 0 then 1 else 0 end * Balance2),2),
            round(sum(case when Settle3 < 0 then 1 else 0 end * Settle3),2),
            round(sum(case when Balance3 < 0 then 1 else 0 end * Balance3),2),
            round(sum(case when Settle4 < 0 then 1 else 0 end * Settle4),2),
            round(sum(case when Balance4 < 0 then 1 else 0 end * Balance4),2)
        from tmp_balance where Currency = v_currency;

        insert into tmp_export
        select 
            '','',
            concat('Credit ', v_ccy),
            round(sum(case when Balance > 0 then 1 else 0 end * Balance),2),
            round(sum(case when Settle1 > 0 then 1 else 0 end * Settle1),2),
            round(sum(case when Balance1 > 0 then 1 else 0 end * Balance1),2),
            round(sum(case when Settle2 > 0 then 1 else 0 end * Settle2),2),
            round(sum(case when Balance2 > 0 then 1 else 0 end * Balance2),2),
            round(sum(case when Settle3 > 0 then 1 else 0 end * Settle3),2),
            round(sum(case when Balance3 > 0 then 1 else 0 end * Balance3),2),
            round(sum(case when Settle4 > 0 then 1 else 0 end * Settle4),2),
            round(sum(case when Balance4 > 0 then 1 else 0 end * Balance4),2)
        from tmp_balance where Currency = v_currency;

        update tmp_export a
        inner join (
        select sum(case buy_sell when 1 then -1 else 0 end * net_amount) as amt
        from account_trade  
        where settle_date = v_t1 and 
            clearing_currency = v_currency and buy_sell = 1 and status = 'Confirmed'
        ) buy1
        inner join (
        select sum(case buy_sell when 1 then -1 else 0 end * net_amount) as amt
        from account_trade  
        where settle_date = v_t2 and 
            clearing_currency = v_currency and buy_sell = 1 and status = 'Confirmed'
        ) buy2
        inner join (
        select sum(case buy_sell when 1 then -1 else 0 end * net_amount) as amt
        from account_trade  
        where settle_date = v_t3 and 
            clearing_currency = v_currency and buy_sell = 1 and status = 'Confirmed'
        ) buy3
        set Settle1 = round(ifnull(buy1.amt,0),2),
            Settle2 = round(ifnull(buy2.amt,0),2),
            Settle3 = round(ifnull(buy3.amt,0),2)
        where a.AE = concat('Debit ', v_ccy);

        update tmp_export a
        inner join (
        select sum(case buy_sell when 1 then 0 else 1 end * net_amount) as amt
        from account_trade 
        where settle_date = v_t1 and 
                clearing_currency = v_currency and buy_sell = 2 and status = 'Confirmed'
        ) sell1
        inner join (
        select sum(case buy_sell when 1 then 0 else 1 end * net_amount) as amt
        from account_trade 
        where settle_date = v_t2 and 
                clearing_currency = v_currency and buy_sell = 2 and status = 'Confirmed'
        ) sell2
        inner join (
        select sum(case buy_sell when 1 then 0 else 1 end * net_amount) as amt
        from account_trade 
        where settle_date = v_t3 and 
                clearing_currency = v_currency and buy_sell = 2 and status = 'Confirmed'
        ) sell3
        set Settle1 = round(ifnull(sell1.amt,0),2),
            Settle2 = round(ifnull(sell2.amt,0),2),
            Settle3 = round(ifnull(sell3.amt,0),2)
        where a.AE = concat('Credit ', v_ccy);

        insert into tmp_export
        select 
            '','',
            concat('Sub Total ', v_ccy),
            round(sum(Balance),2),
            round(sum(Settle1),2),
            round(sum(Balance1),2),
            round(sum(Settle2),2),
            round(sum(Balance2),2),
            round(sum(Settle3),2),
            round(sum(Balance3),2),
            round(sum(Settle4),2),
            round(sum(Balance4),2)
        from tmp_balance where Currency = v_currency;

        set v_done = 0; 
        fetch cur_balance into v_currency; 
    end while; 
    close cur_balance;

    insert into tmp_export
    select 
        '','',
        'Sub Total HKD',
        round(sum(a.Balance*case when ifnull(b.exchange_rate,'') = '' then c.exchange_rate else b.exchange_rate end),2),
        round(sum(a.Settle1*case when ifnull(b.exchange_rate,'') = '' then c.exchange_rate else b.exchange_rate end),2),
        round(sum(a.Balance1*case when ifnull(b.exchange_rate,'') = '' then c.exchange_rate else b.exchange_rate end),2),
        round(sum(a.Settle2*case when ifnull(b.exchange_rate,'') = '' then c.exchange_rate else b.exchange_rate end),2),
        round(sum(a.Balance2*case when ifnull(b.exchange_rate,'') = '' then c.exchange_rate else b.exchange_rate end),2),
        round(sum(a.Settle3*case when ifnull(b.exchange_rate,'') = '' then c.exchange_rate else b.exchange_rate end),2),
        round(sum(a.Balance3*case when ifnull(b.exchange_rate,'') = '' then c.exchange_rate else b.exchange_rate end),2),
        round(sum(a.Settle4*case when ifnull(b.exchange_rate,'') = '' then c.exchange_rate else b.exchange_rate end),2),
        round(sum(a.Balance4*case when ifnull(b.exchange_rate,'') = '' then c.exchange_rate else b.exchange_rate end),2)
    from tmp_balance a
    left join currency_history b on b.process_date = i_process_date and b.currency = a.currency
    left join currency c on c.currency = a.currency;

    select * from tmp_export a;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportPositionMarketValueSummary
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportPositionMarketValueSummary`;
delimiter ;;
CREATE PROCEDURE `proExportPositionMarketValueSummary`(in i_process_date date)
label:begin

    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    
    drop temporary table if exists tmp_position_market_value_summary;
    create temporary table tmp_position_market_value_summary
    (
       process_date date,
       account_id varchar(16),
       market_value decimal(30,10),
       market_value_after_haircut decimal(30,10),
       index idx1(process_date,account_id)
    );

    
    insert into tmp_position_market_value_summary
    (
        process_date, 
        account_id, 
        market_value, 
        market_value_after_haircut
    )
    select 
        a.process_date,
        a.account_id, 
        round(sum(a.market_value), 2) as market_value,
        round(sum(a.market_value_after_haircut), 2 ) as market_value_after_haircut
        from v_account_position_market_value_after_haircut a 
        where a.process_date = i_process_date 
        group by process_date,account_id;

    SELECT * FROM tmp_position_market_value_summary;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportProductConcentrationReport
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportProductConcentrationReport`;
delimiter ;;
CREATE PROCEDURE `proExportProductConcentrationReport`(IN i_process_date DATE)
label:BEGIN
DECLARE v_market_value_total DECIMAL(30,10) DEFAULT 0;
DECLARE v_market_value_cmv   DECIMAL(30,10) DEFAULT 0;
DECLARE v_market_value_omv   DECIMAL(30,10) DEFAULT 0;

IF i_process_date IS NULL THEN
    SELECT buss_date INTO i_process_date FROM sys_info;
END IF;

drop temporary table IF EXISTS tmp_rpt_product_concentration_report;
CREATE TEMPORARY TABLE tmp_rpt_product_concentration_report
(
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    process_date       DATE,
    market_id          INT,
    product_id         VARCHAR(32),
    product_name       VARCHAR(256),
    frr_grade          VARCHAR(32),
    client_holding_qty INT,
    closing_price      DECIMAL(30,4),
    market_value       DECIMAL(30,4),
    conc_percent       DECIMAL(30,4),
    CDF                DECIMAL(30,4)
);

SELECT SUM(ROUND(abs(ap.net_quantity)*ap.closing_price*round(ifnull(b.exchange_rate,c.exchange_rate),6),2))  INTO v_market_value_total
FROM account_position ap 
LEFT JOIN currency c ON ap.currency=c.currency 
left join currency_history b on b.process_date = i_process_date and b.currency = ap.currency
inner join product d on d.product_id = ap.product_id
WHERE ap.process_date=i_process_date and ap.account_type='2';

INSERT INTO tmp_rpt_product_concentration_report(process_date,market_id,product_id,client_holding_qty,closing_price,market_value,conc_percent,CDF)
SELECT
process_date,market_id,product_id,client_holding_qty,closing_price,market_value,conc_percent,ROUND(v_market_value_total*conc_percent/100.0/market_value,4)
FROM
(
SELECT process_date,market_id,product_id,SUM(abs(net_quantity))AS client_holding_qty,closing_price,SUM(ROUND(abs(ap.net_quantity)*ap.closing_price*c.exchange_rate,2)) AS market_value,
CASE WHEN product_id IN('00001','00002','00003','00005','00006','00011','00012','00016','00017','00019','00027','00066','00083','00101','00151','00175','00267','00288','00386','00388','00669','00688','00700','00762','00823','00857','00883','00939','00941','01038','01044','01088','01093','01109','01113','01177','01299','01398','01928','01997','02007','02018','02313','02318','02319','02382','02388','02628','03328','03988')THEN 20
     ELSE 10 END AS conc_percent  
FROM account_position ap LEFT JOIN currency c ON ap.currency=c.currency
WHERE account_type='2' AND process_date=i_process_date
GROUP BY process_date,market_id,product_id
ORDER BY process_date,market_id,product_id
)t WHERE v_market_value_total*conc_percent/100.0/market_value<1.0;

UPDATE tmp_rpt_product_concentration_report a, product b 
  SET a.product_name=b.product_description WHERE a.market_id=b.list_market_id AND a.product_id=b.product_id;

SELECT IFNULL(SUM(market_value),0) INTO v_market_value_cmv FROM tmp_rpt_product_concentration_report;
SET v_market_value_omv = v_market_value_total - v_market_value_cmv;

INSERT INTO tmp_rpt_product_concentration_report(process_date,product_id,product_name,market_value)VALUES
(i_process_date,  'CMV','Concentrated Market Value (CDF < 1)',v_market_value_cmv),
(i_process_date,  'OMV','Other Market Value'                 ,v_market_value_omv),
(i_process_date,'Total','Total'                              ,v_market_value_total);

SELECT * FROM tmp_rpt_product_concentration_report;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportRollingBalanceCashClientAnalysis
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportRollingBalanceCashClientAnalysis`;
delimiter ;;
CREATE PROCEDURE `proExportRollingBalanceCashClientAnalysis`(in i_process_date date)
label:begin

    


    if i_process_date  is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    drop temporary table if EXISTS tmp_rpt_rolling_balance_cash_client_analysis; 
    create temporary table tmp_rpt_rolling_balance_cash_client_analysis
    (
        id bigint primary key auto_increment,    
        group_id     bigint,  
        process_date date, 
        account_id  varchar(16), 
        account_name varchar(128),
        tran_code    varchar(32),  
        net_balance  DECIMAL(30,10) DEFAULT NULL,
        market_id    int ,
        product_id   varchar(32), 
        product_desc varchar(255), 
        market_value decimal(30,10) default 0, 
        haircut_percent decimal(30,10) default 0, 
        market_value_after_haircut decimal(30,10), 
        adjusted_value DECIMAL(30,10) DEFAULT NULL,
        type      int ,  
        index idx1(type, process_date, account_id),
        index idx2(type, process_date, account_id, market_id )
    );

    
    insert into tmp_rpt_rolling_balance_cash_client_analysis
    (
        id,
        process_date, 
        account_id, 
        account_name, 
        tran_code,
        net_balance, 
        market_value,
        type
    )
       select
        NULL,
        a.process_date,
        a.account_id,
        ifnull(replace(account_profile.short_name,',',' '),'') as short_name,
        'B/F', 
        round(sum((a.trade_balance-IFNULL(d.amt,0))*ifnull(b.exchange_rate,c.exchange_rate)), 2) as net_balance, 
        round(sum( ifnull(e.market_value,0) *ifnull(b.exchange_rate, c.exchange_rate)), 2) as market_value,
        2
    from 
    account_balance a 
    left join currency_history b on a.process_date = b.process_date and a.currency = b.currency 
    left join currency c on a.currency = c.currency
    left join account_profile on account_profile.account_id = a.account_id
    LEFT JOIN (
    SELECT account_id, currency, SUM(IF(purpose=1,amount,0)-IF(purpose=2,amount,0))AS amt FROM cash_flow_cit WHERE process_date<=i_process_date GROUP BY account_id,currency
    )d ON a.account_id=d.account_id AND a.currency=d.currency
    left join (
        select 
            po.account_id,
            po.currency,
            sum(po.net_quantity * po.closing_price) as market_value
        from account_position po
        inner join product pr on pr.product_id = po.product_id
        where po.process_date = i_process_date group by po.account_id,po.currency
    ) e on e.account_id = a.account_id and e.currency = a.currency
    where 
        a.process_date = i_process_date and 
        a.account_type in('1')
        group by a.process_date, a.account_id, account_profile.short_name
        having net_balance <0  
        order by net_balance, account_id; 

    
    update tmp_rpt_rolling_balance_cash_client_analysis 
    set group_id = id; 
        
    
    drop temporary table if exists rolling_balance_cash_client_analysis_accounts; 
    create temporary table rolling_balance_cash_client_analysis_accounts
    (
        account_id varchar(16), 
        group_id bigint,
        index idx1(account_id)
    ); 
    insert into rolling_balance_cash_client_analysis_accounts
    (
        account_id,
        group_id
    )
    select 
        account_id, 
        MAX(id) 
    from tmp_rpt_rolling_balance_cash_client_analysis
    group by process_date, account_id; 

    
    insert into tmp_rpt_rolling_balance_cash_client_analysis
    (
        group_id,
        process_date, 
        account_id, 
        market_id, 
        product_id, 
        product_desc,
        market_value, 
        haircut_percent, 
        market_value_after_haircut, 
        type
    )
    select  
        c.group_id,
        a.process_date, 
        a.account_id, 
        a.market_id, 
        a.product_id, 
        replace(b.product_description,',',' '),
        ROUND(a.market_value,2), 
        a.haircut_percent, 
        ROUND(a.market_value_after_haircut,2),
        1
    from v_account_position_market_value_after_haircut a 
    left join product b on a.market_id = b.list_market_id and a.product_id = b.product_id
    inner join rolling_balance_cash_client_analysis_accounts  c on a.account_id = c.account_id
    where a.process_date = i_process_date and 
          a.market_value <> 0 
    order by product_id; 

    
    drop temporary table if exists tmp_rpt_rolling_balance_cash_client_analysis_market_value; 
    create temporary table tmp_rpt_rolling_balance_cash_client_analysis_market_value
    (
        process_date date, 
        account_id varchar(16), 
        market_value decimal(30,10), 
        market_value_after_haircut decimal(30,10) ,
        index idx1(process_date, account_id)
    ); 

    insert into tmp_rpt_rolling_balance_cash_client_analysis_market_value
    (
        process_date,
        account_id, 
        market_value, 
        market_value_after_haircut
    )
    select
        process_date, 
        account_id, 
        sum(market_value), 
        sum(market_value_after_haircut)
    from 
        tmp_rpt_rolling_balance_cash_client_analysis
    where type = 1 
    group by process_date, account_id;


    update tmp_rpt_rolling_balance_cash_client_analysis a 
    left join tmp_rpt_rolling_balance_cash_client_analysis_market_value b on a.process_date = b.process_date and a.account_id = b.account_id 
    set a.market_value = ifnull(b.market_value, 0), 
        a.market_value_after_haircut = ifnull(b.market_value_after_haircut, 0)
    where a.type  = 2; 

    
    update tmp_rpt_rolling_balance_cash_client_analysis
    set adjusted_value = funMax(net_balance, -1*market_value_after_haircut)
    where type = 2;

drop temporary table IF EXISTS tmp_rpt_rolling_balance_cash_client_analysis_summary;
CREATE TEMPORARY TABLE tmp_rpt_rolling_balance_cash_client_analysis_summary SELECT * FROM tmp_rpt_rolling_balance_cash_client_analysis WHERE 1=2;

INSERT INTO tmp_rpt_rolling_balance_cash_client_analysis_summary(group_id,process_date,account_id,net_balance,market_value,market_value_after_haircut,adjusted_value)
SELECT 0,i_process_date,'top_20_clients',SUM(net_balance),SUM(market_value),SUM(market_value_after_haircut),SUM(adjusted_value) 
  FROM (SELECT * FROM tmp_rpt_rolling_balance_cash_client_analysis WHERE `type`=2 ORDER BY net_balance ASC LIMIT 20)t;

INSERT INTO tmp_rpt_rolling_balance_cash_client_analysis_summary(group_id,process_date,account_id,net_balance,market_value,market_value_after_haircut,adjusted_value)
SELECT 0,i_process_date,'other_clients',SUM(net_balance),SUM(market_value),SUM(market_value_after_haircut),SUM(adjusted_value) 
  FROM (SELECT * FROM tmp_rpt_rolling_balance_cash_client_analysis WHERE `type`=2 ORDER BY net_balance ASC LIMIT 20,999999999)t;

INSERT INTO tmp_rpt_rolling_balance_cash_client_analysis_summary(group_id,process_date,account_id,net_balance,market_value,market_value_after_haircut,adjusted_value)
SELECT 0,i_process_date,'grand_total',SUM(net_balance),SUM(market_value),SUM(market_value_after_haircut),SUM(adjusted_value) 
  FROM tmp_rpt_rolling_balance_cash_client_analysis WHERE `type`=2;

INSERT INTO tmp_rpt_rolling_balance_cash_client_analysis SELECT * FROM tmp_rpt_rolling_balance_cash_client_analysis_summary;

    select * from tmp_rpt_rolling_balance_cash_client_analysis
    order by group_id, type, id; 

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportShortPosition
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportShortPosition`;
delimiter ;;
CREATE PROCEDURE `proExportShortPosition`(IN i_process_date DATE)
label:BEGIN
 
    declare v_done int; 
    declare v_hk_1t date;
    declare v_hk_t1 date; 
    declare v_hk_t2 date; 
    
    declare v_us_1t date;
    declare v_us_t1 date; 
    declare v_us_t2 date; 

    declare v_csc_1t date;
    declare v_csc_t1 date; 
    declare v_csc_t2 date; 

    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    select max(calendar_day) into v_hk_1t from calendar where calendar_day<DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and market_id = 1 and holiday in('N','S'); 
    select min(calendar_day) into v_hk_t1 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and market_id = 1 and holiday in('N','S'); 
    select min(calendar_day) into v_hk_t2 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(v_hk_t1,INTERVAL 0 DAY),'%Y%m%d') and market_id = 1 and holiday in('N','S'); 

    select max(calendar_day) into v_us_1t from calendar where calendar_day<DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and market_id in(2,16) and holiday in('N','S'); 
    select min(calendar_day) into v_us_t1 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and market_id in(2,16) and holiday in('N','S'); 
    select min(calendar_day) into v_us_t2 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(v_us_t1,INTERVAL 0 DAY),'%Y%m%d') and market_id in(2,16) and holiday in('N','S'); 

    select max(calendar_day) into v_csc_1t from calendar where calendar_day<DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and market_id in (4,8) and holiday in('N','S'); 
    select min(calendar_day) into v_csc_t1 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(i_process_date,INTERVAL 0 DAY),'%Y%m%d') and market_id in (4,8) and holiday in('N','S'); 
    select min(calendar_day) into v_csc_t2 from calendar where calendar_day>DATE_FORMAT(DATE_SUB(v_csc_t1,INTERVAL 0 DAY),'%Y%m%d') and market_id in (4,8) and holiday in('N','S'); 

    drop temporary table IF EXISTS tmp_export;
    CREATE TEMPORARY TABLE tmp_export 
    (
        process_date            VARCHAR(32) NULL DEFAULT NULL,
        `account`               VARCHAR(16) NULL DEFAULT NULL,
        `product_id`            VARCHAR(32) NULL DEFAULT NULL,
        `custodian_acc_id`      VARCHAR(32) NULL DEFAULT NULL,
        `buss_date`             VARCHAR(32) NULL DEFAULT NULL,
        `buss_date_1`           VARCHAR(32) NULL DEFAULT NULL,
        `buss_date_2`           VARCHAR(32) NULL DEFAULT NULL,
        `product_code`          VARCHAR(32) NULL DEFAULT NULL,
        `product_name`          VARCHAR(128) NULL DEFAULT NULL,
        `ccy`                   VARCHAR(16) NULL DEFAULT NULL,
        `closing_price`         VARCHAR(32) NULL DEFAULT NULL,
        `prev_close`            VARCHAR(32) NULL DEFAULT NULL,
        `prev_qty`              VARCHAR(32) NULL DEFAULT NULL,
        `t0_qty`                VARCHAR(32) NULL DEFAULT NULL,
        `t1_qty`                VARCHAR(32) NULL DEFAULT NULL,
        `t2_qty`                VARCHAR(32) NULL DEFAULT NULL,
        `t0_mv`                 VARCHAR(32) NULL DEFAULT NULL,
        `t1_mv`                 VARCHAR(32) NULL DEFAULT NULL,
        `t2_mv`                 VARCHAR(32) NULL DEFAULT NULL,
        `client_acc_name`       VARCHAR(128) NULL DEFAULT NULL
    );

    drop temporary table IF EXISTS tmp_position;
    CREATE TEMPORARY TABLE tmp_position 
    (
        process_date            date,
        `account`               VARCHAR(16) NULL DEFAULT NULL,
        `product_id`            VARCHAR(32) NULL DEFAULT NULL,
        `custodian_acc_id`      VARCHAR(32) NULL DEFAULT NULL,
        `buss_date`             DATE NULL DEFAULT NULL,
        `buss_date_1`           DATE NULL DEFAULT NULL,
        `buss_date_2`           DATE NULL DEFAULT NULL,
        `product_code`          VARCHAR(32) NULL DEFAULT NULL,
        `product_name`          VARCHAR(128) NULL DEFAULT NULL,
        `ccy`                   VARCHAR(16) NULL DEFAULT NULL,
        `closing_price`         DECIMAL(30,10) NULL DEFAULT 0.00,
        `prev_close`            DECIMAL(30,10) NULL DEFAULT 0.00,
        `prev_qty`              DECIMAL(30,10) NULL DEFAULT 0.00,
        `t0_qty`                DECIMAL(30,10) NULL DEFAULT 0.00,
        `t1_qty`                DECIMAL(30,10) NULL DEFAULT 0.00,
        `t2_qty`                DECIMAL(30,10) NULL DEFAULT 0.00,
        `t0_mv`                 DECIMAL(30,10) NULL DEFAULT 0.00,
        `t1_mv`                 DECIMAL(30,10) NULL DEFAULT 0.00,
        `t2_mv`                 DECIMAL(30,10) NULL DEFAULT 0.00,
        `client_acc_name`       VARCHAR(128) NULL DEFAULT NULL
    );

    drop temporary table if exists tmp; 
    create temporary table tmp 
    select account_id,product_id,custodian_code,custodian_account,
            sum(case buy_sell when 1 then 1 else -1 end * quantity) as qty, 
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as amt
        from account_trade where settle_date = v_hk_t1 and list_market_id = 1 and status = 'Confirmed'
        group by account_id,product_id,custodian_code,custodian_account; 
    create index idx on tmp(account_id, product_id, custodian_code, custodian_account);    

    drop temporary table if exists tmp2; 
    create temporary table tmp2 
    select account_id,product_id,custodian_code,custodian_account,
            sum(case buy_sell when 1 then 1 else -1 end * quantity) as qty, 
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as amt
        from account_trade 
        where settle_date = v_hk_t2 and list_market_id = 1 and status = 'Confirmed' group by account_id,product_id,custodian_code,custodian_account;
    create index idx on tmp2(account_id, product_id, custodian_code, custodian_account);

    -- HK
    insert into tmp_position
    select 
        i_process_date,
        a.account_id,
        concat(a.product_id,':',(case a.market_id when 1 then 'HK' when 2 then 'US' when 4 then 'SHA' when 8 then 'SZA' when 16 then 'OTC' end)) as product_id,
        concat(a.custodian_account,':',a.custodian_code) as custodian_acc_id,
        a.process_date as buss_date,
        v_hk_t1 as buss_date_1,
        v_hk_t2 as buss_date_2,
        a.product_id as product_code,
        replace(b.product_description,',','') as product_name,
        case a.currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end as ccy,
        a.closing_price as closing_price,
        ifnull(c.closing_price,0) as prev_close,
        ifnull(c.quantity,0) as prev_qty,
        a.quantity as t0_qty,
        a.quantity + ifnull(f.qty,0) as t1_qty,
        a.net_quantity as t2_qty,
        round(a.quantity * a.closing_price * b.price_factor,2) as t0_mv,
        round((a.quantity + ifnull(f.qty,0)) * a.closing_price * b.price_factor,2) as t1_mv,
        round((a.net_quantity *a.closing_price * b.price_factor),2) as t2_mv,
        replace(d.short_name,',',' ')
    from account_position a 
    inner join product b on a.market_id = b.list_market_id and a.product_id = b.product_id 
    left join account_position c on c.process_date = v_hk_1t and c.market_id = a.market_id and 
                c.product_id = a.product_id and c.account_id = a.account_id and 
                c.custodian_code = a.custodian_code and 
                c.custodian_account = a.custodian_account
    inner join account_profile d on d.account_id = a.account_id
    inner join capital_account e on e.account_id = a.account_id
    left join tmp f on f.account_id = a.account_id and f.product_id = a.product_id and f.custodian_code = a.custodian_code and f.custodian_account = a.custodian_account
    left join tmp2 g on g.account_id = a.account_id and g.product_id = a.product_id and g.custodian_code = a.custodian_code and g.custodian_account = a.custodian_account
    where a.process_date = i_process_date and a.market_id = 1 and a.quantity < 0
    order by a.currency,a.account_id,a.market_id,a.product_id,a.custodian_code,a.custodian_account;
    
    -- CSC
    drop temporary table if exists tmp; 
    create temporary table tmp 
    select account_id,product_id,custodian_code,custodian_account,
            sum(case buy_sell when 1 then 1 else -1 end * quantity) as qty, 
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as amt
        from account_trade where settle_date = v_csc_t1 and list_market_id in (4,8) and status = 'Confirmed' group by account_id,product_id,custodian_code,custodian_account; 
    create index idx on tmp(account_id, product_id, custodian_code, custodian_account);    

    drop temporary table if exists tmp2; 
    create temporary table tmp2 
    select account_id,product_id,custodian_code,custodian_account,
            sum(case buy_sell when 1 then 1 else -1 end * quantity) as qty, 
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as amt
        from account_trade 
        where settle_date = v_csc_t2 and list_market_id in (4,8) and status = 'Confirmed' group by account_id,product_id,custodian_code,custodian_account;
    create index idx on tmp2(account_id, product_id, custodian_code, custodian_account);


    insert into tmp_position
    select 
        i_process_date,
        a.account_id,
        concat(a.product_id,':',(case a.market_id when 1 then 'HK' when 2 then 'US' when 4 then 'SHA' when 8 then 'SZA' when 16 then 'OTC' end)) as product_id,
        concat(a.custodian_account,':',a.custodian_code) as custodian_acc_id,
        a.process_date as buss_date,
        v_hk_t1 as buss_date_1,
        v_hk_t2 as buss_date_2,
        a.product_id as product_code,
        replace(b.product_description,',','') as product_name,
        case a.currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end as ccy,
        a.closing_price as closing_price,
        ifnull(c.closing_price,0) as prev_close,
        ifnull(c.quantity,0) as prev_qty,
        a.quantity as t0_qty,
        a.quantity + ifnull(f.qty,0) as t1_qty,
        a.net_quantity as t2_qty,
        round(a.quantity * a.closing_price * b.price_factor,2) as t0_mv,
        round((a.quantity + ifnull(f.qty,0)) * a.closing_price * b.price_factor,2) as t1_mv,
        round((a.net_quantity *a.closing_price * b.price_factor),2) as t2_mv,
        replace(d.short_name,',',' ')
    from account_position a 
    inner join product b on a.market_id = b.list_market_id and a.product_id = b.product_id 
    left join account_position c on c.process_date = v_csc_1t and c.market_id = a.market_id and 
                c.product_id = a.product_id and c.account_id = a.account_id and 
                c.custodian_code = a.custodian_code and 
                c.custodian_account = a.custodian_account
    inner join account_profile d on d.account_id = a.account_id
    inner join capital_account e on e.account_id = a.account_id
    left join tmp f on f.account_id = a.account_id and f.product_id = a.product_id and f.custodian_code = a.custodian_code and f.custodian_account = a.custodian_account
    left join tmp2 g on g.account_id = a.account_id and g.product_id = a.product_id and g.custodian_code = a.custodian_code and g.custodian_account = a.custodian_account
    where a.process_date = i_process_date and a.market_id in (4,8) and a.quantity < 0
    order by a.currency,a.account_id,a.market_id,a.product_id,a.custodian_code,a.custodian_account;
    
    -- US
    drop temporary table if exists tmp; 
    create temporary table tmp 
    select account_id,product_id,custodian_code,custodian_account,
            sum(case buy_sell when 1 then 1 else -1 end * quantity) as qty, 
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as amt
        from account_trade where settle_date = v_us_t1 and list_market_id in (2,16) and status = 'Confirmed' group by account_id,product_id,custodian_code,custodian_account;
    create index idx on tmp(account_id, product_id, custodian_code, custodian_account);    

    drop temporary table if exists tmp2; 
    create temporary table tmp2 
    select account_id,product_id,custodian_code,custodian_account,
            sum(case buy_sell when 1 then 1 else -1 end * quantity) as qty, 
            sum(case buy_sell when 1 then -1 else 1 end * net_amount) as amt
        from account_trade 
        where settle_date = v_us_t2 and list_market_id in (2,16) and status = 'Confirmed' group by account_id,product_id,custodian_code,custodian_account;
    create index idx on tmp2(account_id, product_id, custodian_code, custodian_account);

    insert into tmp_position
    select 
        i_process_date,
        a.account_id,
        concat(a.product_id,':',(case a.market_id when 1 then 'HK' when 2 then 'US' when 4 then 'SHA' when 8 then 'SZA' when 16 then 'OTC' end)) as product_id,
        concat(a.custodian_account,':',a.custodian_code) as custodian_acc_id,
        a.process_date as buss_date,
        v_hk_t1 as buss_date_1,
        v_hk_t2 as buss_date_2,
        a.product_id as product_code,
        replace(b.product_description,',','') as product_name,
        case a.currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end as ccy,
        a.closing_price as closing_price,
        ifnull(c.closing_price,0) as prev_close,
        ifnull(c.quantity,0) as prev_qty,
        a.quantity as t0_qty,
        a.quantity + ifnull(f.qty,0) as t1_qty,
        a.net_quantity as t2_qty,
        round(a.quantity * a.closing_price * b.price_factor,2) as t0_mv,
        round((a.quantity + ifnull(f.qty,0)) * a.closing_price * b.price_factor,2) as t1_mv,
        round((a.net_quantity *a.closing_price * b.price_factor),2) as t2_mv,
        replace(d.short_name,',',' ')
    from account_position a 
    inner join product b on a.market_id = b.list_market_id and a.product_id = b.product_id 
    left join account_position c on c.process_date = v_us_1t and c.market_id = a.market_id and 
                c.product_id = a.product_id and c.account_id = a.account_id and c.custodian_code = a.custodian_code and 
                c.custodian_account = a.custodian_account
    inner join account_profile d on d.account_id = a.account_id
    inner join capital_account e on e.account_id = a.account_id
    left join tmp f on f.account_id = a.account_id and f.product_id = a.product_id and f.custodian_code = a.custodian_code and f.custodian_account = a.custodian_account
    left join tmp2 g on g.account_id = a.account_id and g.product_id = a.product_id and g.custodian_code = a.custodian_code and g.custodian_account = a.custodian_account
    where a.process_date = i_process_date and a.market_id in (2,16) and a.quantity < 0
    order by a.currency,a.account_id,a.market_id,a.product_id,a.custodian_code,a.custodian_account;

    drop temporary table IF EXISTS tmp_position_2;
    CREATE TEMPORARY TABLE tmp_position_2 as
    select * from tmp_position where (t0_qty <> 0 or t1_qty <> 0 or t2_qty <> 0);

    insert into tmp_export
    select * from tmp_position_2;

    insert into tmp_export(
        process_date,
        buss_date,buss_date_1,buss_date_2,
        t0_qty,t1_qty,t2_qty,
        t2_mv,t1_mv,t0_mv
    )
    select 
        'Total',
        buss_date,buss_date_1,buss_date_2,
        sum(t0_qty),sum(t1_qty),sum(t2_qty),
        sum(t2_mv),sum(t1_mv),sum(t0_mv)
    from tmp_position_2;

    select * from tmp_export; 

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportStampDutyLedgerForTheMonth
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportStampDutyLedgerForTheMonth`;
delimiter ;;
CREATE PROCEDURE `proExportStampDutyLedgerForTheMonth`(IN i_process_date DATE)
label:BEGIN
DECLARE v_month_day_begin DATE DEFAULT NULL;
DECLARE v_month_day_end   DATE DEFAULT NULL;

IF i_process_date IS NULL THEN
    SELECT buss_date INTO i_process_date FROM sys_info;
END IF;

SELECT DATE_ADD(i_process_date, interval - DAY(i_process_date) + 1 day) INTO v_month_day_begin;
SELECT LAST_DAY(i_process_date) INTO v_month_day_end;

drop temporary table IF EXISTS tmp_rpt;
CREATE TEMPORARY TABLE tmp_rpt
(
  process_date DATE PRIMARY KEY,
  total_stamp_duty_payable DECIMAL(30,10),
  stamp_duty_paid_through_hkex DECIMAL(30,10)
);
drop temporary table IF EXISTS tmp_rpt_summary; 
CREATE TEMPORARY TABLE tmp_rpt_summary SELECT * FROM tmp_rpt WHERE 1=2;

INSERT INTO tmp_rpt(process_date, total_stamp_duty_payable, stamp_duty_paid_through_hkex)
SELECT 
process_date,
SUM(charges) AS total_stamp_duty_payable, 
SUM(charges) AS stamp_duty_paid_through_hkex
FROM account_charge WHERE v_month_day_begin<=process_date AND process_date<=v_month_day_end AND charge_code='STAMP_HK:HK' GROUP BY process_date ORDER BY process_date ASC;

INSERT INTO tmp_rpt_summary(process_date, total_stamp_duty_payable, stamp_duty_paid_through_hkex)
SELECT '0000-00-00',SUM(total_stamp_duty_payable),SUM(stamp_duty_paid_through_hkex) FROM tmp_rpt;

INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_summary;

SELECT * FROM tmp_rpt;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportTopMarginClientAnalysis
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportTopMarginClientAnalysis`;
delimiter ;;
CREATE PROCEDURE `proExportTopMarginClientAnalysis`(in i_process_date date)
label:begin

/*
1.margin客户(account_type in('2','3,'))
2.top 20 
*/

declare v_done int default  0;

declare v_rpt_process_date date; 
declare v_rpt_id bigint; 
declare v_rpt_account_id varchar(16); 
declare v_position_market_id int;
declare v_position_product_id varchar(32); 
declare v_position_product_desc varchar(255);
declare v_position_market_value decimal(30,10); 
declare v_times int; 

-- 遍历rpt所有的客户
declare cur_account cursor  for 
    select id,process_date,account_id
    from tmp_rpt_margin_client_analysis
    order by id ; 

-- 遍历客户的前三持仓市值
declare cur_position cursor for 
    select 
    a.market_id, 
    a.product_id, 
    max(replace(replace(b.product_description,',',' '),'''',' ')), 
    round(sum(a.market_value*ifnull(d.exchange_rate,c.exchange_rate)), 2)
    from account_position a 
    left join product b on a.market_id = b.list_market_id and a.product_id = b.product_id
    left join currency c on a.currency = c.currency 
    left join currency_history d on v_rpt_process_date = d.process_date and a.currency  = d.currency
    where a.process_date = v_rpt_process_date and 
          a.account_id  = v_rpt_account_id
    group by a.market_id,a.product_id
    having sum(a.market_value*ifnull(d.exchange_rate,c.exchange_rate)) <> 0 
    order by sum(a.market_value*ifnull(d.exchange_rate,c.exchange_rate)) desc limit 3; 

DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done=1;

if i_process_date is null then 
    select buss_date into i_process_date from sys_info; 
end if; 

drop temporary table if exists tmp_rpt_margin_client_analysis; 
create temporary table tmp_rpt_margin_client_analysis
(
    id bigint primary key auto_increment,
    process_date date,
    account_id varchar(16), 
    account_name varchar(128), 
    net_balance decimal(30,10) default 0.0, 
    market_value decimal(30,10) default 0.0,
    market_value_after_haircut decimal(30,10) default 0.0, 
    adjusted_loan_balance decimal(30,10) default 0.0, 
    market1 int, 
    product1 varchar(32), 
    product_desc1 varchar(255), 
    product_market_value1 decimal(30,10),
    market2 int, 
    product2 varchar(32), 
    product_desc2 varchar(255), 
    product_market_value2 decimal(30,10),
    market3 int, 
    product3 varchar(32), 
    product_desc3 varchar(255), 
    product_market_value3 decimal(30,10),
    data_type INT,
    index idx1(process_date, account_id)
);


    -- 筛选出满足条件的负资产的客户
    insert into tmp_rpt_margin_client_analysis
    (
        process_date, 
        account_id, 
        account_name, 
        net_balance, 
        market_value
    )
    select 
        a.process_date,
        a.account_id,
        ifnull(replace(account_profile.short_name,',',' '),'') as short_name,
        round(sum((a.trade_balance - ifnull(f.amount,0)) * round(ifnull(b.exchange_rate,c.exchange_rate),6)), 2) as net_balance, 
        round(sum(ifnull(d.market_value,0) * ifnull(b.exchange_rate, c.exchange_rate)), 2) as market_value
    from 
    account_balance a 
    left join currency_history b on a.process_date = b.process_date and a.currency = b.currency 
    left join currency c on a.currency = c.currency
    left join account_profile on account_profile.account_id = a.account_id
    left join (
        select 
            po.account_id,
            po.currency,
            sum(po.net_quantity * po.closing_price) as market_value
        from account_position po
        inner join product pr on pr.product_id = po.product_id
        where po.process_date = i_process_date group by po.account_id,po.currency
    ) d on d.account_id = a.account_id and d.currency = a.currency
    left join (
        select account_id,currency,sum(case purpose when 1 then 1 else -1 end * amount) as amount
        from cash_flow_cit 
        where process_date <= i_process_date group by account_id,currency
    ) f on f.account_id = a.account_id and f.currency = a.currency
    where 
        a.process_date = i_process_date and 
        a.account_type in('2','3')
        group by a.process_date, a.account_id, account_profile.short_name
        having net_balance <0  
        order by net_balance, account_id
    ; -- limit 20; 
    UPDATE tmp_rpt_margin_client_analysis SET data_type = 1 WHERE id<=20;
    UPDATE tmp_rpt_margin_client_analysis SET data_type = 2 WHERE id>=21;

    call proPositionMarketValueSummary(i_process_date); 

    -- 维护市值信息
    update tmp_rpt_margin_client_analysis a
    inner join tmp_position_market_value_summary b on a.process_date = b.process_date and a.account_id = b.account_id
    set a.market_value = b.market_value, 
        a.market_value_after_haircut  = b.market_value_after_haircut, 
        a.adjusted_loan_balance = funMax(a.net_balance, -1*a.market_value_after_haircut); 

    -- 持仓处理
    open cur_account; 

    set v_done = 0; 
    fetch cur_account into v_rpt_id,v_rpt_process_date, v_rpt_account_id; 
    while v_done <> 1 do 

        -- 遍历市值前三持仓
        open cur_position;
        set v_done = 0; 
        set v_times = 0; 
        fetch cur_position into v_position_market_id, v_position_product_id, v_position_product_desc, v_position_market_value; 
        while v_done <> 1 do 
            set v_times = v_times + 1; 
            set @str =concat(
                "update tmp_rpt_margin_client_analysis set ", 
                "market", v_times, "=", v_position_market_id, ",",
                "product",v_times,"='",v_position_product_id,"',",
                "product_desc",v_times,"='",v_position_product_desc,"',",
                "product_market_value",v_times,"=",v_position_market_value,
                " where id = ", v_rpt_id
            );
            PREPARE  stmt from @str;
            EXECUTE stmt; 

            set v_done = 0; 
            fetch cur_position into v_position_market_id, v_position_product_id, v_position_product_desc, v_position_market_value; 
        end while;
        close cur_position;

        set v_done = 0; 
        fetch cur_account into v_rpt_id,v_rpt_process_date, v_rpt_account_id; 
    end while; 
    close cur_account;

drop temporary table IF EXISTS   tmp_rpt_margin_client_analysis_2;
CREATE TEMPORARY TABLE tmp_rpt_margin_client_analysis_2 SELECT * FROM tmp_rpt_margin_client_analysis WHERE 1=2;
INSERT INTO tmp_rpt_margin_client_analysis_2(account_name,    net_balance ,    market_value ,    market_value_after_haircut ,    adjusted_loan_balance)
                                 SELECT 'SubTotal(top20)',SUM(net_balance),SUM(market_value),SUM(market_value_after_haircut),SUM(adjusted_loan_balance) FROM tmp_rpt_margin_client_analysis WHERE data_type=1;
INSERT INTO tmp_rpt_margin_client_analysis_2(account_name,    net_balance ,    market_value ,    market_value_after_haircut ,    adjusted_loan_balance)
                                          SELECT 'Others',SUM(net_balance),SUM(market_value),SUM(market_value_after_haircut),SUM(adjusted_loan_balance) FROM tmp_rpt_margin_client_analysis WHERE data_type=2;
INSERT INTO tmp_rpt_margin_client_analysis_2(account_name,    net_balance ,    market_value ,    market_value_after_haircut ,    adjusted_loan_balance)
                                          SELECT  'Total',SUM(net_balance),SUM(market_value),SUM(market_value_after_haircut),SUM(adjusted_loan_balance) FROM tmp_rpt_margin_client_analysis;
INSERT INTO tmp_rpt_margin_client_analysis SELECT * FROM tmp_rpt_margin_client_analysis_2;

    select * from tmp_rpt_margin_client_analysis WHERE id<=20 OR account_id IS NULL;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportTransactionLevyAndTradingFeeReport
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportTransactionLevyAndTradingFeeReport`;
delimiter ;;
CREATE PROCEDURE `proExportTransactionLevyAndTradingFeeReport`(IN i_process_date DATE)
label:BEGIN
DECLARE v_month_day_begin DATE DEFAULT NULL;
DECLARE v_month_day_end   DATE DEFAULT NULL;

IF i_process_date IS NULL THEN
    SELECT buss_date INTO i_process_date FROM sys_info;
END IF;

SELECT DATE_ADD(i_process_date, interval - DAY(i_process_date) + 1 day) INTO v_month_day_begin;
SELECT LAST_DAY(i_process_date) INTO v_month_day_end;

drop temporary table IF EXISTS tmp_rpt;
CREATE TEMPORARY TABLE tmp_rpt
(
  process_date DATE,
  currency_group INT,
  gross_buy_amount DECIMAL(30,10),
  gross_sell_amount DECIMAL(30,10),
  levy DECIMAL(30,10),
  trading_fee DECIMAL(30,10),
  total_fee DECIMAL(30,10),
  PRIMARY KEY (process_date,currency_group)
);
drop temporary table IF EXISTS tmp_rpt_summary; 
CREATE TEMPORARY TABLE tmp_rpt_summary SELECT * FROM tmp_rpt WHERE 1=2;

delete from tmp_rpt_summary;
INSERT INTO tmp_rpt_summary(process_date,currency_group,gross_buy_amount) 
SELECT a.process_date,
       clearing_currency, 
       ifnull(SUM(ROUND(trade_amount*(case when ifnull(c.exchange_rate,'') = '' then b.exchange_rate else c.exchange_rate end),2)),0.00) 
FROM account_trade a 
left join currency b on a.clearing_currency = b.currency
left join currency_history c on c.process_date = a.process_date and c.currency = a.clearing_currency
WHERE v_month_day_begin<=a.process_date AND a.process_date<=v_month_day_end AND market_id=1 AND buy_sell=1 AND status='Confirmed' GROUP BY a.process_date,clearing_currency;
INSERT INTO tmp_rpt(process_date,currency_group,gross_buy_amount)SELECT process_date,currency_group,gross_buy_amount FROM tmp_rpt_summary ON DUPLICATE KEY UPDATE tmp_rpt.gross_buy_amount=tmp_rpt_summary.gross_buy_amount;

delete from tmp_rpt_summary;
INSERT INTO tmp_rpt_summary(process_date,currency_group,gross_sell_amount) 
SELECT a.process_date,
       clearing_currency, 
       ifnull(SUM(ROUND(trade_amount*(case when ifnull(b.exchange_rate,'') = '' then c.exchange_rate else b.exchange_rate end),2)),0.00)
FROM account_trade a 
left join currency b on a.clearing_currency = b.currency
left join currency_history c on c.process_date = a.process_date and c.currency = a.clearing_currency
WHERE v_month_day_begin<= a.process_date AND a.process_date<=v_month_day_end AND market_id=1 AND buy_sell=2 AND status='Confirmed' GROUP BY a.process_date,clearing_currency;
INSERT INTO tmp_rpt(process_date,currency_group,gross_sell_amount)SELECT process_date,currency_group,gross_sell_amount FROM tmp_rpt_summary ON DUPLICATE KEY UPDATE tmp_rpt.gross_sell_amount=tmp_rpt_summary.gross_sell_amount;

delete from tmp_rpt_summary;
INSERT INTO tmp_rpt_summary(process_date,currency_group,levy) 
SELECT ac.process_date,
       ac.currency,
       SUM(ROUND(ac.charges*ch.exchange_rate,2)) FROM account_charge ac
  LEFT JOIN currency_history ch ON ac.process_date=ch.process_date AND ac.currency=ch.currency
  WHERE v_month_day_begin<=ac.process_date AND ac.process_date<=v_month_day_end AND ac.charge_code='LEVY_HK:HK' GROUP BY ac.process_date,ac.currency;

INSERT INTO tmp_rpt(process_date,currency_group,levy)SELECT process_date,currency_group,levy FROM tmp_rpt_summary ON DUPLICATE KEY UPDATE tmp_rpt.levy=tmp_rpt_summary.levy;

delete from tmp_rpt_summary;
INSERT INTO tmp_rpt_summary(process_date,currency_group,trading_fee) 
SELECT ac.process_date,
       ac.currency,
       SUM(ROUND(ac.charges*ch.exchange_rate,2)) FROM account_charge ac
  LEFT JOIN currency_history ch ON ac.process_date=ch.process_date AND ac.currency=ch.currency
  WHERE v_month_day_begin<=ac.process_date AND ac.process_date<=v_month_day_end AND ac.charge_code='TFEE_HK:HK' GROUP BY ac.process_date,ac.currency;

INSERT INTO tmp_rpt(process_date,currency_group,trading_fee)SELECT process_date,currency_group,trading_fee FROM tmp_rpt_summary ON DUPLICATE KEY UPDATE tmp_rpt.trading_fee=tmp_rpt_summary.trading_fee;

delete from tmp_rpt_summary;
INSERT INTO tmp_rpt_summary(process_date,currency_group,total_fee) 
SELECT process_date,currency_group,levy+trading_fee FROM tmp_rpt;
INSERT INTO tmp_rpt(process_date,currency_group,total_fee)SELECT process_date,currency_group,total_fee FROM tmp_rpt_summary ON DUPLICATE KEY UPDATE tmp_rpt.total_fee=tmp_rpt_summary.total_fee;

delete from tmp_rpt_summary;
INSERT INTO tmp_rpt_summary(process_date, currency_group, gross_buy_amount, gross_sell_amount, levy, trading_fee, total_fee)
SELECT '0000-00-00',0,SUM(gross_buy_amount),SUM(gross_sell_amount),SUM(levy),SUM(trading_fee),SUM(total_fee) FROM tmp_rpt;
INSERT INTO tmp_rpt SELECT * FROM tmp_rpt_summary;

select *from tmp_rpt;

SELECT
  process_date,
  case currency_group when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' else 'HKD' end as currency_group,
  ifnull(gross_buy_amount,0.00) as gross_buy_amount,
  ifnull(gross_sell_amount,0.00) as gross_sell_amount,
  ifnull(levy,0.00) as levy,
  ifnull(trading_fee,0.00) as trading_fee,
  ifnull(total_fee,0.00) as total_fee
FROM tmp_rpt;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proExportVoucher
-- ----------------------------
DROP PROCEDURE IF EXISTS `proExportVoucher`;
delimiter ;;
CREATE PROCEDURE `proExportVoucher`(IN i_process_date DATE)
label:BEGIN

IF i_process_date IS NULL THEN
    SELECT buss_date INTO i_process_date FROM sys_info;
END IF;


REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_24', '1-2591 BOC(HK) HKD CA 01287500594152', NOW(), ifnull(sum(b.charges*ifnull(c.exchange_rate,d.exchange_rate)),0)
from account_trade a
inner join account_charge b on a.trade_id = b.external_id and b.charge_code = 'STAMP_HK:HK'
left join currency_history c on a.process_date = c.process_date and a.clearing_currency = c.currency 
left join currency d on a.clearing_currency = d.currency
where a.settle_date = i_process_date and  
  a.market_id = 1 AND input_channel <> '5' and a.status = 'Confirmed';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_25', '1-2315 Cash Rece-SEHK-China A-RMB', NOW(), ifnull(SUM(round(a.amount*ifnull(b.exchange_rate,c.exchange_rate),2)),0)
FROM jcbms.cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency  
left join currency c on a.currency = c.currency 
WHERE a.process_date=i_process_date AND a.dividend_market_id in ('4','8') and  
  a.remark LIKE '%CorpAction%' and purpose=1;

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_26', '2-2405 Clients Dividend Payable', NOW(), ifnull(SUM(round(a.amount*ifnull(b.exchange_rate,c.exchange_rate),2)),0)
FROM jcbms.cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency  
left join currency c on a.currency = c.currency 
WHERE a.process_date=i_process_date AND a.dividend_market_id in ('4','8') and  
  a.remark LIKE '%CorpAction%' and purpose=2;

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_27', '1-2310 Cash client rece.- SEHK - HKD', NOW(), ifnull(SUM(round(case when a.remark like '%CorpAction-Scrip Fee%' then 0 else a.amount end *ifnull(b.exchange_rate,c.exchange_rate),2)),0)
FROM jcbms.cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency
left join currency c on a.currency = c.currency
WHERE a.process_date=i_process_date AND a.account_type = 1 and a.dividend_market_id =1 and  
  a.remark LIKE '%CorpAction%' AND purpose=1;

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_28', '1-2310 Cash client rece.- SEHK - HKD', NOW(), ifnull(SUM(round(case when a.remark like '%CorpAction-Scrip Fee%' then 0 else a.amount end *ifnull(b.exchange_rate,c.exchange_rate),2)),0)
FROM jcbms.cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency
left join currency c on a.currency = c.currency
WHERE a.process_date=i_process_date AND a.account_type = 1 and a.dividend_market_id =1 and  
  a.remark LIKE '%CorpAction%' AND purpose=2;

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_29', '1-2310 Cash client rece.- SEHK - HKD', NOW(), ifnull(SUM(round( a.amount *ifnull(b.exchange_rate,c.exchange_rate),2)),0)
FROM jcbms.cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency  
left join currency c on a.currency = c.currency 
WHERE a.process_date=i_process_date AND a.account_type = 1 and a.dividend_market_id =1 and  
  a.remark LIKE '%CorpAction-Scrip Fee%' AND purpose=2;

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_30', '1-2320 Margin client rece.-SEHK - HKD', NOW(), ifnull(SUM(round(case when a.remark like '%CorpAction-Scrip Fee%' then 0 else a.amount end *ifnull(b.exchange_rate,c.exchange_rate),2)),0)
FROM jcbms.cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency
left join currency c on a.currency = c.currency
WHERE a.process_date=i_process_date AND a.account_type = 2 and a.dividend_market_id =1 and  
  a.remark LIKE '%CorpAction%' AND purpose=1;

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_31', '1-2320 Margin client rece.-SEHK - HKD', NOW(), ifnull(SUM(round(case when a.remark like '%CorpAction-Scrip Fee%' then 0 else a.amount end *ifnull(b.exchange_rate,c.exchange_rate),2)),0)
FROM jcbms.cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency
left join currency c on a.currency = c.currency
WHERE a.process_date=i_process_date AND a.account_type = 2 and a.dividend_market_id =1 and  
  a.remark LIKE '%CorpAction%' AND purpose=1;

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_32', '1-2320 Margin client rece.-SEHK - HKD', NOW(), ifnull(SUM(round( a.amount *ifnull(b.exchange_rate,c.exchange_rate),2)),0)
FROM jcbms.cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency
left join currency c on a.currency = c.currency
WHERE a.process_date=i_process_date AND a.account_type =2 and a.dividend_market_id =1 and  
  a.remark LIKE '%CorpAction-Scrip Fee%' AND purpose=2;


REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
select 
i_process_date,'note_33','Cash client rece.- SEHK - HKD', now(),ifnull(sum(case purpose when 1 then 1 else -1 end *round(a.amount*ifnull(b.exchange_rate,c.exchange_rate), 2)),0)
from cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency
left join currency c on a.currency = c.currency 
where a.process_date = i_process_date and
   a.remark = 'Monthly Interest Received' and 
   a.account_type = 1  and  
   date_format(a.update_time,'%H:%m:%s')<='17:00:00';  

 
 REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
select 
i_process_date,'note_34','Margin client rece.-SEHK - HKD',now(),ifnull(sum(case purpose when 1 then 1 else -1 end *round(a.amount*ifnull(b.exchange_rate,c.exchange_rate), 2)),0)
from cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency
left join currency c on a.currency = c.currency 
where a.process_date = i_process_date and
   a.remark = 'Monthly Interest Received' and 
   a.account_type = 2  and  
   date_format(a.update_time,'%H:%m:%s')<='17:00:00'; 


REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
select 
i_process_date,'note_35','Cash client rece.- SEHK - HKD',now(),ifnull(abs(sum(case purpose when 1 then 1 else -1 end *round(a.amount*ifnull(b.exchange_rate,c.exchange_rate), 2))),0)
from cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency
left join currency c on a.currency = c.currency 
where a.process_date = i_process_date and
	a.currency = 2 and 
   a.remark = 'Monthly Interest Paid' and 
   a.account_type = 1  and  
   date_format(a.update_time,'%H:%m:%s')>='17:00:00';


REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
select 
i_process_date,'note_36','Cash clt rec- US mkt -USD',now(),ifnull(abs(sum(case purpose when 1 then 1 else -1 end *round(a.amount*ifnull(b.exchange_rate,c.exchange_rate), 2))),0)
from cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency
left join currency c on a.currency = c.currency 
where a.process_date = i_process_date and
	a.currency = 4 and 
   a.remark = 'Monthly Interest Paid' and 
   a.account_type = 1  and  
   date_format(a.update_time,'%H:%m:%s')>='17:00:00';


REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
select 
i_process_date,'note_37','Cash Rece-SEHK-China A-RMB',now(),ifnull(abs(sum(case purpose when 1 then 1 else -1 end *round(a.amount*ifnull(b.exchange_rate,c.exchange_rate), 2))),0)
from cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency
left join currency c on a.currency = c.currency 
where a.process_date = i_process_date and
	a.currency = 1 and 
   a.remark = 'Monthly Interest Received' and 
   a.account_type = 1  and  
   date_format(a.update_time,'%H:%m:%s')>='17:00:00';


REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
select 
i_process_date,'note_38','Cash client rece.- SEHK - HKD',now(),ifnull(abs(sum(case purpose when 1 then 1 else -1 end *round(a.amount*ifnull(b.exchange_rate,c.exchange_rate), 2))),0)
from cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency
left join currency c on a.currency = c.currency 
where a.process_date = i_process_date and
	a.currency = 2 and 
   a.remark = 'Monthly Interest Received' and 
   a.account_type = 1  and  
   date_format(a.update_time,'%H:%m:%s')>='17:00:00';


REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
select 
i_process_date,'note_39','Cash clt rec- US mkt -USD',now(),ifnull(abs(sum(case purpose when 1 then 1 else -1 end *round(a.amount*ifnull(b.exchange_rate,c.exchange_rate), 2))),0)
from cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency
left join currency c on a.currency = c.currency 
where a.process_date = i_process_date and
	a.currency = 4 and 
   a.remark = 'Monthly Interest Received' and 
   a.account_type = 1  and  
   date_format(a.update_time,'%H:%m:%s')>='17:00:00';
   

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
select
i_process_date,'note_40','Cash clt rec- US mkt -USD',now(),ifnull(abs(sum(round(case when a.purpose = 1 then 1 else -1 end * a.amount*ifnull(b.exchange_rate,c.exchange_rate),2))),0)
from cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency 
left join currency c on a.currency = c.currency
where a.process_date = i_process_date and 
		a.account_type = 1 and 
		a.currency = 4 and 
		a.purpose = 1 
		and (
				a.remark like 'in;%' or 
				a.remark like 'conversion;%' or 
				a.remark like '%自动货币兑换%'
			);


REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
select
i_process_date,'note_41','Margin clt rec -US market- USD',now(),ifnull(abs(sum(round(case when a.purpose = 1 then 1 else -1 end * a.amount*ifnull(b.exchange_rate,c.exchange_rate),2))),0)
from cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency 
left join currency c on a.currency = c.currency
where a.process_date = i_process_date and 
		a.account_type = 2 and 
		a.currency = 4 and 
		a.purpose = 1 
		and (
				a.remark like 'in;%' or 
				a.remark like 'conversion;%' or 
				a.remark like '%自动货币兑换%'
			);



REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
select
i_process_date,'note_42','MarginRec-SEHK-China A-RMB',now(),ifnull(abs(sum(round(case when a.purpose = 1 then 1 else -1 end * a.amount*ifnull(b.exchange_rate,c.exchange_rate),2))),0)
from cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency 
left join currency c on a.currency = c.currency
where a.process_date = i_process_date and 
		a.account_type = 2 and 
		a.currency = 1 and 
		a.purpose = 1 
		and (
				a.remark like 'in;%' or 
				a.remark like 'conversion;%' or 
				a.remark like '%自动货币兑换%'
			);



REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_43_cash', '1-2310 Cash client rece.- SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND account_type='1'
AND remark LIKE '%IPO Apply%' AND remark NOT LIKE '%IPO Apply Handling Fee%';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_43_margin', '1-2320 Margin client rece.-SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND account_type='2'
AND remark LIKE '%IPO Apply%' AND remark NOT LIKE '%IPO Apply Handling Fee%';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_43_total', '1-2390 Clt Sub. shares', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date
AND remark LIKE '%IPO Apply%' AND remark NOT LIKE '%IPO Apply Handling Fee%';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_44_cash', '1-2310 Cash client rece.- SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND remark LIKE '%IPO Loan 1_%' AND account_type='1';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_44_margin', '1-2320 Margin client rece.-SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND remark LIKE '%IPO Loan 1_%' AND account_type='2';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_44_total', '1-2395 Clt Sub. shares - Financing', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND remark LIKE '%IPO Loan 1_%';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_45_cash', '1-2310 Cash client rece.- SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND remark LIKE '%IPO Apply Handling Fee%' AND account_type='1';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_45_margin', '1-2320 Margin client rece.-SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND remark LIKE '%IPO Apply Handling Fee%' AND account_type='2';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_45_total', '4-3300 IPO Financing Interest', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND remark LIKE '%IPO Apply Handling Fee%';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_46_cash', '1-2310 Cash client rece.- SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND remark LIKE '%IPO Refund%' AND account_type='1';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_46_margin', '1-2320 Margin client rece.-SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND remark LIKE '%IPO Refund%' AND account_type='2';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_46_total', '1-2390 Clt Sub. shares', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND remark LIKE '%IPO Refund%';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_47_cash', '1-2310 Cash client rece.- SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND remark LIKE '%IPO Loan Return%' AND account_type='1';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_47_margin', '1-2320 Margin client rece.-SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND remark LIKE '%IPO Loan Return%' AND account_type='2';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_47_total', '1-2395 Clt Sub. shares - Financing', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND remark LIKE '%IPO Loan Return%';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_48_cash', '1-2310 Cash client rece.- SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND remark LIKE '%IPO Loan Interest%' AND account_type='1';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_48_margin', '1-2320 Margin client rece.-SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND remark LIKE '%IPO Loan Interest%' AND account_type='2';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_48_total', '4-3300 IPO Financing Interest', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND remark LIKE '%IPO Loan Interest%';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_49', '1-2310 Cash client rece.- SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND remark LIKE '%Portfolio Fee%' AND account_type='1';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_50', '1-2320 Margin client rece.-SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND remark LIKE '%Portfolio Fee%' AND account_type='2';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_51', '1-2320 Margin client rece.-SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND remark LIKE 'Monthly Interest Paid' AND account_type='2' AND currency=2;

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_52', '1-2325 Margin clt rec -US market- USD', NOW(), ifnull(ROUND(SUM(amount*exchange_rate),2),0)
FROM jcbms.cash_flow cf LEFT JOIN jcbms.currency_history ch ON cf.process_date=ch.process_date AND cf.currency=ch.currency
  WHERE cf.process_date=i_process_date AND cf.remark LIKE 'Monthly Interest Paid' AND cf.account_type='2' AND cf.currency=4;

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_53', '1-2323 MarginRec-SEHK-China A-RMB', NOW(), ifnull(ROUND(SUM(amount*exchange_rate),2),0)
FROM jcbms.cash_flow cf LEFT JOIN jcbms.currency_history ch ON cf.process_date=ch.process_date AND cf.currency=ch.currency
  WHERE cf.process_date=i_process_date AND cf.remark LIKE 'Monthly Interest Received' AND cf.account_type='2' AND cf.currency=1;

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
select 
i_process_date,'note_54','Margin client rece.-SEHK - HKD',now(),ifnull(abs(sum(case purpose when 1 then 1 else -1 end *round(a.amount*ifnull(b.exchange_rate,c.exchange_rate), 2))),0)
from cash_flow a
left join currency_history b on a.process_date = b.process_date and a.currency = b.currency
left join currency c on a.currency = c.currency 
where a.process_date = i_process_date and
	a.currency = 2 and 
   a.remark = 'Monthly Interest Received' and 
   a.account_type = 2  and  
   date_format(a.update_time,'%H:%m:%s')>='17:00:00';


REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_55', '1-2325 Margin clt rec -US market- USD', NOW(), ifnull(ROUND(SUM(amount*exchange_rate),2),0)
FROM jcbms.cash_flow cf LEFT JOIN jcbms.currency_history ch ON cf.process_date=ch.process_date AND cf.currency=ch.currency
  WHERE cf.process_date=i_process_date AND cf.remark LIKE 'Monthly Interest Received' AND cf.account_type='2' AND cf.currency=4;

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_56_cash', '1-2310 Cash client rece.- SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND account_type='1' AND currency=2 AND STATUS='Confirmed' AND remark LIKE '%全免账户费用回扣%月IPO融资利息%';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_56_margin', '1-2320 Margin client rece.-SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND account_type='2' AND currency=2 AND STATUS='Confirmed' AND remark LIKE '%全免账户费用回扣%月IPO融资利息%';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_56_total', '4-3300 IPO Financing Interest', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND account_type IN ('1','2') AND currency=2 AND STATUS='Confirmed' AND remark LIKE '%全免账户费用回扣%月IPO融资利息%';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_57_cash', '1-2310 Cash client rece.- SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND account_type='1' AND currency=2 AND STATUS='Confirmed' AND remark LIKE '%全免账户费用回扣%月IPO手续费%';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_57_margin', '1-2320 Margin client rece.-SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND account_type='2' AND currency=2 AND STATUS='Confirmed' AND remark LIKE '%全免账户费用回扣%月IPO手续费%';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_57_total', '4-5095 Clt Sub handling fee-Financing', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND account_type IN ('1','2') AND currency=2 AND STATUS='Confirmed' AND remark LIKE '%全免账户费用回扣%月IPO手续费%';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_58', '1-2310 Cash client rece.- SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND account_type='1' AND currency=2 AND STATUS='Confirmed' AND remark LIKE '%员工费用回扣%月IPO手续费%';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_59', '1-2320 Margin client rece.-SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND account_type='2' AND currency=2 AND STATUS='Confirmed' AND remark LIKE '%提款小于1000元手续费%';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_60_cash', '1-2310 Cash client rece.- SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND account_type='1' AND currency=2 AND purpose=2 AND STATUS='Confirmed' AND remark='提款';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_60_margin', '1-2320 Margin client rece.-SEHK - HKD', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND account_type='2' AND currency=2 AND purpose=2 AND STATUS='Confirmed' AND remark='提款';

REPLACE INTO voucher_data(process_date, voucher_key, voucher_desc, update_time, voucher_value)
SELECT i_process_date, 'note_60_total', '1-2581 BOC(HK) CT HKDCA01287500640206', NOW(), ifnull(SUM(amount),0)
FROM jcbms.cash_flow WHERE process_date=i_process_date AND account_type IN (1,2) AND currency=2 AND purpose=2 AND STATUS='Confirmed' AND remark='提款';












SELECT * FROM voucher_data WHERE process_date=i_process_date ORDER BY CAST(SUBSTRING_INDEX(SUBSTRING_INDEX(voucher_key,'_',2),'_',-1)AS SIGNED INTEGER);

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proFastBackup
-- ----------------------------
DROP PROCEDURE IF EXISTS `proFastBackup`;
delimiter ;;
CREATE PROCEDURE `proFastBackup`(in i_table_name varchar(128),
    in i_tag varchar(128), 
    in i_condition varchar(255), 
    out o_code int, 
    out o_msg varchar(128))
label:begin

/*
1. 创建备份表用于快速备份数据 
2. 生成的新表名称规则： i_table_tag
3. 只支持整表备份和还原 
*/

declare v_table_name varchar(255);

set o_code = 0 ; 
set o_msg  = "";

set v_table_name = concat(i_table_name,'_', i_tag );

-- 删除重复的备份表
set @sql  = concat('drop table if exists ', v_table_name);
PREPARE stmt from @sql; 
EXECUTE stmt;

-- 创建备份表和对应的数据
set @sql = concat('create table ', v_table_name, ' select * from ', i_table_name,' ', i_condition);
PREPARE stmt from @sql; 
EXECUTE stmt;


end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proFundPurchaseProcess
-- ----------------------------
DROP PROCEDURE IF EXISTS `proFundPurchaseProcess`;
delimiter ;;
CREATE PROCEDURE `proFundPurchaseProcess`(OUT o_ret_code int,
    OUT o_ret_msg varchar(256))
label: BEGIN
    DECLARE v_process_date date;
    DECLARE v_limit DECIMAL(30,10) DEFAULT 0.00;
    DECLARE v_multiple int(11) DEFAULT 0;
    DECLARE v_sum_result_amt DECIMAL(30,10) DEFAULT 0.00;
    DECLARE v_sum_apply_amt DECIMAL(30,10) DEFAULT 0.00;
    DECLARE v_sum_result_qty DECIMAL(30,10) DEFAULT 0.00;
    DECLARE v_sum_apply_qty DECIMAL(30,10) DEFAULT 0.00;
    
    DECLARE v_custodian_code    VARCHAR(16);
    DECLARE v_custodian_account VARCHAR(16);
    -- v_account_id,v_account_type,v_currency,v_product_id,v_product_type,v_qty,v_price,v_amount;
    declare v_account_id varchar(16);
    declare v_account_type int;
    declare v_currency varchar(1);
    declare v_product_id varchar(32);
    declare v_product_type int;
    declare v_qty DECIMAL(30,10) DEFAULT 0.00;
    declare v_price DECIMAL(30,10) DEFAULT 0.00;
    declare v_amount DECIMAL(30,10) DEFAULT 0.00;
    declare v_count int DEFAULT 0;

    declare v_qty_result DECIMAL(30,10) DEFAULT 0.00;
    declare v_amount_result DECIMAL(30,10) DEFAULT 0.00;

    declare v_done int default 0; 
    DECLARE v_id bigint DEFAULT 0;

    DECLARE cur_sum_amt CURSOR FOR
    SELECT
      product_id,sum(amount)
    FROM
      fund_purchase_redemption a
    where a.process_date = v_process_date and order_type = 3 and ifnull(status,'') <> 'Confirmed' group by a.product_id; 

    DECLARE cur_sum_qty CURSOR FOR
    SELECT
      product_id,sum(qty)
    FROM
      fund_purchase_redemption a
    where a.process_date = v_process_date and order_type = 3 and ifnull(status,'') <> 'Confirmed' group by a.product_id; 

    DECLARE cur_sum_result CURSOR FOR
    SELECT
      product_id,sum(qty),sum(amount)
    FROM
      fund_purchase_redemption a
    where a.process_date = v_process_date and order_type = 3 and ifnull(status,'') <> 'Confirmed' group by a.product_id;

    DECLARE cur_cash_product CURSOR FOR
    SELECT
      a.account_id,c.account_type,b.currency,a.product_id,b.product_type,a.qty,a.price,a.amount
    FROM fund_purchase_redemption a
    inner join product b on a.product_id = b.product_id
    inner join capital_account c on c.account_id = a.account_id
    where a.process_date = v_process_date and a.order_type = 3 and ifnull(a.status,'') <> 'Confirmed'; 


    DECLARE cur_dispath_HKD CURSOR FOR
    SELECT
      a.id
    FROM fund_purchase_redemption a
    where a.process_date = v_process_date and a.order_type = 3 and ifnull(a.status,'') <> 'Confirmed' and product_id = 'YFDHKD'
    order by qty desc;

    DECLARE cur_dispath_USD CURSOR FOR
    SELECT
      a.id
    FROM fund_purchase_redemption a
    where a.process_date = v_process_date and a.order_type = 3 and ifnull(a.status,'') <> 'Confirmed' and product_id = 'YFDUSD'
    order by qty desc;

    DECLARE CONTINUE HANDLER FOR NOT FOUND
        SET v_done = 1;

    START TRANSACTION;

    set v_limit = 0.0001;

    set v_multiple = 10000;

    SET o_ret_code = 0, o_ret_msg = "Success";
    
    select buss_date into v_process_date from sys_info;

    IF not EXISTS(SELECT 1 FROM fund_purchase_redemption WHERE process_date = v_process_date and order_type = 3 and ifnull(status,'') <> 'Confirmed') THEN
        rollback;
        SET o_ret_code = 1, o_ret_msg = "No data to process";
        LEAVE label;
    END IF;

    select count(1) into v_count from fund_result;
    -- 判断导入文件数据是否有异常，条数不能大于4
    if v_count > 4 then 
        rollback; 
        set o_ret_code = 1; 
        set o_ret_msg = concat('Result file incoming data exception'); 
        leave label; 
    end if;

    -- 判断产品是否存在
    IF EXISTS(SELECT 1 FROM fund_result WHERE product_id NOT IN (SELECT DISTINCT product_id FROM product) ) THEN
        SET o_ret_code = 1, o_ret_msg = "product id not exist";
        LEAVE label;
    END IF;

    -- 更新价格和数量到fund_purchase_redemption
    update fund_purchase_redemption a 
    inner join fund_result b on a.product_id = b.product_id
    set a.price = b.price,
        a.qty = floor_times(a.amount/b.price)
    where a.process_date = v_process_date and a.order_type = 3 and ifnull(status,'') <> 'Confirmed';

    -- 判断申请金额和结果金额是否相同
    OPEN cur_sum_amt;
        SET v_done = 0;
        FETCH cur_sum_amt INTO v_product_id,v_sum_apply_amt;
        WHILE v_done <> 1 DO
            
            select amount into v_sum_result_amt from fund_result where product_id = v_product_id and order_type = 3;

            if v_sum_result_amt <> v_sum_apply_amt then
                rollback; 
                set o_ret_code = 1; 
                set o_ret_msg = concat('Application amount is not equal to result amount ',v_product_id); 
                leave label; 
            end if;

            SET v_done = 0;
            FETCH cur_sum_amt INTO v_product_id,v_sum_apply_amt;
        END WHILE;
    CLOSE cur_sum_amt;


    select ifnull(sum(qty),0) into v_qty_result from fund_result where process_date = v_process_date and order_type = 3 and   product_id = 'YFDHKD';
    select ifnull(sum(qty),0) into v_qty from fund_purchase_redemption a
    where a.process_date = v_process_date and a.order_type = 3 and ifnull(a.status,'') <> 'Confirmed' and product_id = 'YFDHKD';  
    
    -- 分配股权 YFDHKD
    OPEN cur_dispath_HKD;
        SET v_done = 0;
        FETCH cur_dispath_HKD INTO v_id;
        WHILE v_done <> 1 and v_qty_result > v_qty DO
            set v_qty = v_qty+ 0.0001;  
            update fund_purchase_redemption
            set qty = qty+0.0001
            where id  = v_id; 

            SET v_done = 0;
            FETCH cur_dispath_HKD INTO v_id;
        END WHILE;
    CLOSE cur_dispath_HKD;


    select ifnull(sum(qty),0) into v_qty_result from fund_result where process_date = v_process_date and order_type = 3 and  product_id = 'YFDUSD';
    
    select ifnull(sum(qty),0) into v_qty from fund_purchase_redemption a
    where a.process_date = v_process_date and a.order_type = 3 and ifnull(a.status,'') <> 'Confirmed' and product_id = 'YFDUSD';  
    -- 分配股权 YFDUSD
    OPEN cur_dispath_USD;
        SET v_done = 0;
        FETCH cur_dispath_USD INTO v_id;
        WHILE v_done <> 1 and v_qty_result > v_qty DO
            set v_qty = v_qty+ 0.0001;  
            update fund_purchase_redemption
            set qty = qty+0.0001
            where id  = v_id; 

            SET v_done = 0;
            FETCH cur_dispath_USD INTO v_id;
        END WHILE;
    CLOSE cur_dispath_USD;

    -- OPEN cur_sum_qty;
    --     SET v_done = 0;
    --     FETCH cur_sum_qty INTO v_product_id,v_sum_apply_qty;
    --     WHILE v_done <> 1 DO
    --         select qty into v_sum_result_qty from fund_result where product_id = v_product_id and order_type = 3;
    --         if v_sum_apply_qty <> v_sum_result_qty then
                
    --             if abs(v_sum_result_qty - v_sum_apply_qty) > v_limit then 
    --                 rollback;
    --                 set o_ret_code = 1; 
    --                 set o_ret_msg = concat('Result quantity comparison application quantity is greater than 0.0001',v_product_id); 
    --                 leave label; 
    --             end if;
                
    --             update fund_purchase_redemption a
    --             inner join (
    --                 select account_id,product_id,max(qty) as qty from fund_purchase_redemption where process_date = v_process_date and product_id = v_product_id
    --             ) t on t.account_id = a.account_id and t.product_id = a.product_id
    --             set a.qty = a.qty + v_sum_result_qty - v_sum_apply_qty
    --             where a.process_date = v_process_date and a.product_id = v_product_id and order_type = 3 and ifnull(status,'') <> 'Confirmed';

    --         end if;

    --         SET v_done = 0;
    --         FETCH cur_sum_qty INTO v_product_id,v_sum_apply_qty;
    --     END WHILE;
    -- CLOSE cur_sum_qty;
    -- 检查最终派发数据是否一致
    OPEN cur_sum_result;
        SET v_done = 0;
        FETCH cur_sum_result INTO v_product_id,v_qty,v_amount;
        WHILE v_done <> 1 DO

            select qty,amount
            into v_qty_result,v_amount_result
            from fund_result where process_date = v_process_date and product_id = v_product_id and order_type = '3';

            if (v_qty <> v_qty_result) or (v_amount <> v_amount_result) then 
                rollback;
                set o_ret_code = 1; 
                set o_ret_msg = concat('Results inconsistent with application data:',v_product_id); 
                leave label; 
            end if;
            SET v_done = 0;
            FETCH cur_sum_result INTO v_product_id,v_qty,v_amount;
        END WHILE;
    CLOSE cur_sum_result;


    set v_qty = 0.00;
    set v_amount = 0.00;
    -- 出入金转仓
    OPEN cur_cash_product;
        SET v_done = 0;
        FETCH cur_cash_product INTO v_account_id,v_account_type,v_currency,v_product_id,v_product_type,v_qty,v_price,v_amount;
        WHILE v_done <> 1 DO
            if v_qty <> 0 and v_price <> 0 then 

                SELECT custodian_code,custodian_account INTO v_custodian_code,v_custodian_account 
                FROM account_type_custodian WHERE market_id=1 AND account_type=v_account_type;

                call proProductIn(NULL,v_account_id,v_account_type,1,v_product_id,v_qty,v_custodian_code,v_custodian_account,
                    v_qty,v_price,NULL,CONCAT(v_product_id,"申购转入"),NULL,now(),o_ret_code,o_ret_msg);
                IF o_ret_code <> 0 THEN
                    ROLLBACK;
                    LEAVE label;
                END IF;
            end if;

            if v_amount <> 0 then 
                call proCashOut (v_process_date,v_account_id,v_account_type,v_currency,v_amount,1,CONCAT(v_product_id,"申购出金"),
                    'remark2','','','','','','','','',1,v_product_id, NULL,NULL,NULL,NULL, NULL,now(),o_ret_code,o_ret_msg);
                IF o_ret_code <> 0 THEN
                    ROLLBACK;
                    LEAVE label;
                END IF;
            end if;

            -- 更新收盘价和市值
            update account_position
            set closing_price = avg_price1,
                market_value = round(net_quantity * closing_price,2)
            where process_date = v_process_date and account_id = v_account_id and market_id = 1 and product_id = v_product_id;

            update fund_purchase_redemption
            set status = 'Confirmed'
            where process_date = v_process_date and account_id = v_account_id and product_id = v_product_id and order_type = 3 and ifnull(status,'') <> 'Confirmed';

            SET v_done = 0;
            FETCH cur_cash_product INTO v_account_id,v_account_type,v_currency,v_product_id,v_product_type,v_qty,v_price,v_amount;
        END WHILE;
    CLOSE cur_cash_product;

    COMMIT;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proFundRedemptionProcess
-- ----------------------------
DROP PROCEDURE IF EXISTS `proFundRedemptionProcess`;
delimiter ;;
CREATE PROCEDURE `proFundRedemptionProcess`(OUT o_ret_code int,
    OUT o_ret_msg varchar(256))
label: BEGIN
    DECLARE v_process_date date;
    DECLARE v_limit DECIMAL(30,10) DEFAULT 0.00;
    DECLARE v_multiple int(11) DEFAULT 0;
    DECLARE v_sum_result_amt DECIMAL(30,10) DEFAULT 0.00;
    DECLARE v_sum_apply_amt DECIMAL(30,10) DEFAULT 0.00;
    DECLARE v_sum_result_qty DECIMAL(30,10) DEFAULT 0.00;
    DECLARE v_sum_apply_qty DECIMAL(30,10) DEFAULT 0.00;
    
    DECLARE v_custodian_code    VARCHAR(16);
    DECLARE v_custodian_account VARCHAR(16);
    declare v_account_id varchar(16);
    declare v_account_type int;
    declare v_currency varchar(1);
    declare v_product_id varchar(32);
    declare v_product_type int;
    declare v_qty DECIMAL(30,10) DEFAULT 0.00;
    declare v_price DECIMAL(30,10) DEFAULT 0.00;
    declare v_amount DECIMAL(30,10) DEFAULT 0.00;
    declare v_count int DEFAULT 0;
    declare v_id bigint default 0; 

    declare v_qty_result DECIMAL(30,10) DEFAULT 0.00;
    declare v_amount_result DECIMAL(30,10) DEFAULT 0.00;

    declare v_done int default 0; 

    DECLARE cur_sum_qty CURSOR FOR
    SELECT
      product_id,sum(qty)
    FROM
      fund_purchase_redemption a
    where a.process_date = v_process_date and order_type = '4' and ifnull(status,'') <> 'Confirmed' group by a.product_id; 

    DECLARE cur_sum_result CURSOR FOR
    SELECT
      product_id,sum(qty),sum(amount)
    FROM
      fund_purchase_redemption a
    where a.process_date = v_process_date and order_type = '4' and ifnull(status,'') <> 'Confirmed' group by a.product_id;

    DECLARE cur_cash_product CURSOR FOR
    SELECT
      a.account_id,c.account_type,b.currency,a.product_id,b.product_type,a.qty,a.price,a.amount
    FROM fund_purchase_redemption a
    inner join product b on a.product_id = b.product_id
    inner join capital_account c on a.account_id= c.account_id 
    where a.process_date = v_process_date and a.order_type = '4' and ifnull(a.status,'') <> 'Confirmed'; 

    DECLARE cur_dispath_HKD CURSOR FOR
    SELECT
      a.id
    FROM fund_purchase_redemption a
    where a.process_date = v_process_date and a.order_type = 4 and ifnull(a.status,'') <> 'Confirmed' and product_id = 'YFDHKD'
    order by qty desc;

    DECLARE cur_dispath_USD CURSOR FOR
    SELECT
      a.id
    FROM fund_purchase_redemption a
    where a.process_date = v_process_date and a.order_type = 4 and ifnull(a.status,'') <> 'Confirmed' and product_id = 'YFDUSD'
    order by qty desc;

    DECLARE CONTINUE HANDLER FOR NOT FOUND
        SET v_done = 1;

    START TRANSACTION;

    set v_limit = 0.0001;

    set v_multiple = 100;

    SET o_ret_code = 0, o_ret_msg = "Success";
    
    select buss_date into v_process_date from sys_info;

    IF not EXISTS(SELECT 1 FROM fund_purchase_redemption WHERE process_date = v_process_date and order_type = 4 and ifnull(status,'') <> 'Confirmed') THEN
        rollback;
        SET o_ret_code = 1, o_ret_msg = "No data to process";
        LEAVE label;
    END IF;

    select count(1) into v_count from fund_result;
    
    if v_count > 4 then 
        rollback; 
        set o_ret_code = 1; 
        set o_ret_msg = concat('Result file incoming data exception'); 
        leave label; 
    end if;

    
    IF EXISTS(SELECT 1 FROM fund_result WHERE product_id NOT IN (SELECT DISTINCT product_id FROM product) ) THEN
        SET o_ret_code = 1, o_ret_msg = "product id not exist";
        LEAVE label;
    END IF;
    
    update fund_purchase_redemption a 
    inner join fund_result b on a.product_id = b.product_id
    inner join product c on c.product_id = a.product_id
    set a.price = b.price,
        
        a.amount = floor(v_multiple*b.price * a.qty)/v_multiple
    where a.process_date = v_process_date and a.order_type = 4 and ifnull(a.status,'') <> 'Confirmed';

    
    select ifnull(sum(amount),0) into v_amount_result from fund_result where process_date = v_process_date and order_type = 4 and   product_id = 'YFDHKD';
    select ifnull(sum(amount),0) into v_amount from fund_purchase_redemption a
    where a.process_date = v_process_date and a.order_type = 4 and ifnull(a.status,'') <> 'Confirmed' and product_id = 'YFDHKD';  
    
    
    OPEN cur_dispath_HKD;
        SET v_done = 0;
        FETCH cur_dispath_HKD INTO v_id;
        WHILE v_done <> 1 and v_amount_result > v_amount DO
            set v_amount = v_amount+ 0.01;  
            update fund_purchase_redemption
            set amount = amount+0.01
            where id  = v_id; 

            SET v_done = 0;
            FETCH cur_dispath_HKD INTO v_id;
        END WHILE;
    CLOSE cur_dispath_HKD;


    
    select ifnull(sum(amount),0) into v_amount_result from fund_result where process_date = v_process_date and order_type = 4 and   product_id = 'YFDUSD';
    select ifnull(sum(amount),0) into v_amount from fund_purchase_redemption a
    where a.process_date = v_process_date and a.order_type = 4 and ifnull(a.status,'') <> 'Confirmed' and product_id = 'YFDUSD';  

    OPEN cur_dispath_USD;
        SET v_done = 0;
        FETCH cur_dispath_USD INTO v_id;
        WHILE v_done <> 1 and v_amount_result > v_amount DO
            set v_amount = v_amount+ 0.01;  
            update fund_purchase_redemption
            set amount = amount+0.01
            where id  = v_id; 

            SET v_done = 0;
            FETCH cur_dispath_USD INTO v_id;
        END WHILE;
    CLOSE cur_dispath_USD;

    
    OPEN cur_sum_qty;
        SET v_done = 0;
        FETCH cur_sum_qty INTO v_product_id,v_sum_apply_qty;
        WHILE v_done <> 1 DO
            
            select qty into v_sum_result_qty from fund_result where product_id = v_product_id and order_type = 4;
            if v_sum_apply_qty <> v_sum_result_qty then
                
                if v_sum_result_qty <> v_sum_apply_qty then 
                    rollback;
                    set o_ret_code = 1; 
                    set o_ret_msg = concat('Application quantity is not equal to result quantity',v_product_id); 
                    leave label; 
                end if;

            end if;

            SET v_done = 0;
            FETCH cur_sum_qty INTO v_product_id,v_sum_apply_qty;
        END WHILE;
    CLOSE cur_sum_qty;

    
    OPEN cur_sum_result;
        SET v_done = 0;
        FETCH cur_sum_result INTO v_product_id,v_qty,v_amount;
        WHILE v_done <> 1 DO

            select qty,amount
            into v_qty_result,v_amount_result
            from fund_result where process_date = v_process_date and product_id = v_product_id and order_type = '4';
            if (v_qty <> v_qty_result) or (v_amount <> v_amount_result) then 
                rollback;
                set o_ret_code = 1; 
                set o_ret_msg = concat('Results inconsistent with application data:',v_product_id); 
                leave label; 
            end if;
            SET v_done = 0;
            FETCH cur_sum_result INTO v_product_id,v_qty,v_amount;
        END WHILE;
    CLOSE cur_sum_result;

    set v_qty = 0.00;
    set v_amount = 0.00;
    
    OPEN cur_cash_product;
        SET v_done = 0;
        FETCH cur_cash_product INTO v_account_id,v_account_type,v_currency,v_product_id,v_product_type,v_qty,v_price,v_amount;
        WHILE v_done <> 1 DO
            if v_qty <> 0 and v_price <> 0 then 

                SELECT custodian_code,custodian_account INTO v_custodian_code,v_custodian_account 
                FROM account_type_custodian WHERE market_id=1 AND account_type=v_account_type;
                
                call proProductOut(NULL,v_account_id,v_account_type,1,v_product_id,v_qty,v_custodian_code,v_custodian_account,
                    v_qty,v_price,NULL,CONCAT(v_product_id,"赎回转出"),NULL,now(),o_ret_code,o_ret_msg);
                IF o_ret_code <> 0 THEN
                    ROLLBACK;
                    LEAVE label;
                END IF;
            end if;

            if v_amount <> 0 then 
                call proCashIn (v_process_date,v_account_id,v_account_type,v_currency,v_amount,1,CONCAT(v_product_id,"赎回入金"),
                    'remark2','','','','','','','','',1,v_product_id, NULL,NULL,NULL,NULL, NULL,now(),o_ret_code,o_ret_msg);
                IF o_ret_code <> 0 THEN
                    ROLLBACK;
                    LEAVE label;
                END IF;
            end if;
            
            
            update account_position
            set closing_price = avg_price1,
                market_value = round(net_quantity * closing_price,2)
            where process_date = v_process_date and account_id = v_account_id and market_id = 1 and product_id = v_product_id;

            update fund_purchase_redemption
            set status = 'Confirmed'
            where process_date = v_process_date and account_id = v_account_id and product_id = v_product_id and order_type = 4 and ifnull(status,'') <> 'Confirmed';

            SET v_done = 0;
            FETCH cur_cash_product INTO v_account_id,v_account_type,v_currency,v_product_id,v_product_type,v_qty,v_price,v_amount;
        END WHILE;
    CLOSE cur_cash_product;
            
    COMMIT;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proFutureBalance
-- ----------------------------
DROP PROCEDURE IF EXISTS `proFutureBalance`;
delimiter ;;
CREATE PROCEDURE `proFutureBalance`(IN  i_market_id int,
    OUT o_ret_code int,
    OUT o_ret_msg char(128))
label:begin

    declare v_process_date date;
    declare v_product_type int default 8;   

    set o_ret_code = 0; 
    set o_ret_msg = "更新余额信息完成"; 
    start transaction; 

    select buss_date into v_process_date from sys_info;
    drop temporary table IF EXISTS tmp_trade_summary;
    create  table  tmp_trade_summary(
          account_id char(16),
          account_type int,
          currency   int,
          trade_balance decimal(30, 10) default 0,
          settle_balance decimal(30, 10) default 0,   
          charges decimal(30, 10) default 0,
          margin_amt decimal(30, 10) default 0,
          profit_loss decimal(30, 10) default 0, 
          real_profit_loss decimal(30 , 10) default 0,
          processed  char(1) default 'N', 
          index idx1(account_id,account_type,currency),
          index idx2(processed)
    ); 

    
    insert into tmp_trade_summary(
        account_id,
        account_type,
        currency,
        charges,
        processed
    )
    select 
        a.account_id, 
        a.account_type, 
        a.currency,
        sum(ifnull(a.charges,0)),
        'N'
    from account_charge a
    inner join tmp_account_trade b on a.external_id = b.trade_id
    where a.status = 'Confirmed'
    group by account_id,account_type,a.currency;

    update account_balance a 
    inner join tmp_trade_summary b  on a.account_id  = b.account_id and a.account_type  = b.account_type and a.currency  = b.currency
    set    
            a.charges = a.charges + b.charges,
            a.trade_balance = a.trade_balance - b.charges, 
            a.settle_balance = a.settle_balance - b.charges,
            b.processed = 'Y'
    where a.process_date = v_process_date; 

    INSERT
    INTO account_balance
    (
        process_date,
        account_id,
        account_type,
        currency,
        charges,
        trade_balance, 
        settle_balance
    )
    SELECT
        v_process_date,
        t.account_id, 
        t.account_type, 
        t.currency, 
        (ifnull(t.charges,0)), 
        -1*(ifnull(t.charges,0)), 
        -1*(ifnull(t.charges,0))
    from  tmp_trade_summary t 
    where t.processed = 'N'
    group by account_id,account_type,currency; 


    delete from tmp_trade_summary;

    
    insert into tmp_trade_summary(
        account_id,
        account_type,
        currency,
        margin_amt,
        profit_loss,
        processed
      )
    select account_id, 
           account_type, 
           currency, 
           sum(ifnull(margin_amt, 0)),
           sum(ifnull(profit_loss,0)),
           'N'
        from future_open_position 
        where closed = 'N'
        group by account_id,account_type,currency;
    
    update account_balance a
    inner join tmp_trade_summary b on a.account_id = b.account_id and a.account_type = b.account_type and a.currency  =b.currency 
    set a.margin_amt =a.margin_amt +  b.margin_amt, 
        a.unrealized_pnl =a.unrealized_pnl +  b.profit_loss, 
        b.processed  = 'Y'
    where a.process_date = v_process_date; 

    INSERT
    INTO account_balance
    (
        process_date,
        account_id,
        account_type,
        currency,
        unrealized_pnl,
        margin_amt
    )
    SELECT
        v_process_date,
        t.account_id, 
        t.account_type, 
        t.currency, 
        (ifnull(t.profit_loss,0)),
        (ifnull(t.margin_amt,0))
    from  tmp_trade_summary t 
    where t.processed = 'N';
    
    delete from tmp_trade_summary;  
    
     insert into tmp_trade_summary(
        account_id,
        account_type,
        currency,
        real_profit_loss,
        processed
      )
    select account_id, 
           account_type, 
           currency, 
           sum(ifnull(profit_loss,0)),
           'N'
        from future_close_position 
        where process_date = v_process_date
        group by account_id,account_type,currency;
        

    update account_balance a
    inner join tmp_trade_summary b on a.account_id = b.account_id and a.account_type = b.account_type and a.currency  =b.currency 
    set 
        a.realized_pnl = a.realized_pnl + b.real_profit_loss, 
        a.trade_balance = a.trade_balance + b.real_profit_loss, 
        a.settle_balance = a.settle_balance + b.real_profit_loss,
        b.processed  = 'Y'
    where a.process_date = v_process_date; 

    INSERT
    INTO account_balance
    (
        process_date,
        account_id,
        account_type,
        currency,
        realized_pnl,
        trade_balance, 
        settle_balance
    )
    SELECT
        v_process_date,
        t.account_id, 
        t.account_type, 
        t.currency, 
        (ifnull(t.real_profit_loss,0)),
        (ifnull(t.real_profit_loss,0)),
        (ifnull(t.real_profit_loss,0))
    from  tmp_trade_summary t 
    where t.processed = 'N';
    delete from tmp_trade_summary;
    

    
    update account_balance a
    set
        
        
        a.equity_balance = a.trade_balance  + a.unrealized_pnl + market_value  - accrued_interest + accrued_interest_credit,
        
        a.balance_avail =   funMax(a.trade_balance + funMin(accrued_interest_credit- a.accrued_interest,0)  -a.frozen_amount - a.margin_amt,0),
        
        a.balance_extract = funMax(a.settle_balance +  + funMIN(a.unsettled_amount,0) + funMin(a.accrued_interest_credit- a.accrued_interest,0) - a.margin_amt  + funMIN(0,a.market_value) - a.frozen_amount,0),
        
        
        a.equity = a.equity_balance  - a.margin_amt - a.frozen_amount
    where a.process_date = v_process_date and account_type = '4';

    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proFutureMargin
-- ----------------------------
DROP PROCEDURE IF EXISTS `proFutureMargin`;
delimiter ;;
CREATE PROCEDURE `proFutureMargin`(In i_market_id int,
   OUT o_ret_code int,
   OUT o_ret_msg char(128))
label:begin
    declare v_process_date  date;
    set o_ret_code = 0; 
    set o_ret_msg = "更新新加坡期货保证金完成"; 
    start transaction; 
    select buss_date into v_process_date from sys_info;
    
    drop temporary table if EXISTS tmp_margin;
    CREATE temporary TABLE `tmp_margin` (
        id               bigint,
        account_id     char(16),
        account_type    int DEFAULT 0,
        market_id        int DEFAULT 0,
        `product_class` char(16) DEFAULT NULL,
        `product_id` char(32) DEFAULT NULL,
        lot              int DEFAULT 0,
        price_factor decimal(31, 10) DEFAULT 1,
        contract_size decimal(31, 10) DEFAULT 1,
        settle_price  decimal(31, 10) DEFAULT 0,
        floating_model    int DEFAULT 0,
        margin_amt      decimal(30, 10) DEFAULT 0,
        `exchange_initial_margin` decimal(30,10) DEFAULT NULL,
        `exchange_maint_margin` decimal(30,10) DEFAULT NULL,
        `exchange_initial_rate` decimal(30,10) DEFAULT '0.0000000000',
        `exchange_maint_rate` decimal(30,10) DEFAULT '0.0000000000',
        `company_initial_margin` decimal(30,10) DEFAULT NULL,
        `company_maint_margin` decimal(30,10) DEFAULT NULL,
        `company_initial_rate` decimal(30,10) DEFAULT '0.0000000000',
        `company_maint_rate` decimal(30,10) DEFAULT '0.0000000000',
        PRIMARY KEY (`id`),
        index idx1(floating_model)
    ) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;

    insert into tmp_margin
    (
        id,
        account_id,
        account_type,
        market_id,
        product_class,
        product_id,
        price_factor,
        contract_size,
        settle_price,
        lot
    )
    select 
        a.id,
        a.account_id,
        a.account_type,
        a.market_id,
        a.product_class,
        a.product_id,
        b.price_factor,
        b.contract_size,
        a.settle_price,
        a.unclosed_qty
    from  future_open_position a
    inner join  product b on a.market_id = b.list_market_id and a.product_id = b.product_id 
    where 
          a.closed = 'N' and 
          a.market_id = i_market_id and 
          a.process_date = v_process_date;


    
    
    update tmp_margin a, product_class_future_margin b
    set a.exchange_initial_margin =  b.exchange_initial_margin,
        a.exchange_maint_margin = b.exchange_maint_margin,
        a.exchange_initial_rate = b.exchange_initial_rate,
        a.exchange_maint_rate  = b.exchange_maint_rate,
        a.company_initial_margin = b.company_initial_margin,
        a.company_maint_margin = b.company_maint_margin,
        a.company_initial_rate = b.company_initial_rate,
        a.company_maint_rate = b.company_maint_rate,
        a.floating_model = b.floating_model
    where a.product_class = b.product_class;


    update tmp_margin a, product_future_margin b
    set a.exchange_initial_margin =  b.exchange_initial_margin,
        a.exchange_maint_margin = b.exchange_maint_margin,
        a.exchange_initial_rate = b.exchange_initial_rate,
        a.exchange_maint_rate  = b.exchange_maint_rate,
        a.company_initial_margin = b.company_initial_margin,
        a.company_maint_margin = b.company_maint_margin,
        a.company_initial_rate = b.company_initial_rate,
        a.company_maint_rate = b.company_maint_rate,
        a.floating_model = b.floating_model
    where a.market_id = b.market_id and
          a.product_id = b.product_id;


    update tmp_margin a
       set  a.company_initial_margin =a.company_initial_margin + a.exchange_initial_margin,
        a.company_maint_margin =a.company_maint_margin + a.exchange_maint_margin,
        a.company_initial_rate =a.company_initial_rate + a.exchange_initial_rate,
        a.company_maint_rate = a.company_maint_rate + a.exchange_maint_rate,
        a.margin_amt = (a.settle_price*a.price_factor*a.contract_size*a.company_initial_rate + a.company_initial_margin)*a.lot 
        where a.floating_model = 1; 

    
    update tmp_margin a
       set a.margin_amt = ((a.settle_price*a.price_factor*a.contract_size*a.exchange_initial_rate + a.exchange_initial_margin)*a.lot)*(1+a.company_initial_rate)+ a.company_initial_margin
        where a.floating_model = 2; 

    update  tmp_margin a
       set  a.margin_amt = (a.settle_price*a.price_factor*a.contract_size*a.company_initial_rate + a.company_initial_margin)*a.lot 
        where a.floating_model = 3;     

    
    update future_open_position a, tmp_margin b set a.margin_amt = b.margin_amt where a.id = b.id;  

    drop temporary table if EXISTS tmp_margin;

    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proFutureOpenProfitLoss
-- ----------------------------
DROP PROCEDURE IF EXISTS `proFutureOpenProfitLoss`;
delimiter ;;
CREATE PROCEDURE `proFutureOpenProfitLoss`(In i_market_id int,
   OUT o_ret_code int,
   OUT o_ret_msg char(128))
label:begin 
    declare v_process_date date;

        
    set o_ret_code = 0; 
    set o_ret_msg = "浮动盈亏计算完成";

    start transaction; 
    select buss_date into v_process_date from sys_info;
    update future_open_position a  
    left join product_market_data b on a.trade_date = b.trade_date and a.market_id = b.list_market_id and a.product_id = b.product_id 
    left join product c on a.market_id = c.list_market_id and a.product_id = c.product_id
    set a.settle_price = ifnull(b.settle_price , 0 ),
        a.profit_loss = a.unclosed_qty*c.contract_size*(a.settle_price - a.price)*(case a.buy_sell when 1 then 1 when 2 then -1 end)
    where 
         a.closed = 'N' and 
         a.market_id = i_market_id and 
         a.process_date = v_process_date; 

   commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proGenenrateCalendar
-- ----------------------------
DROP PROCEDURE IF EXISTS `proGenenrateCalendar`;
delimiter ;;
CREATE PROCEDURE `proGenenrateCalendar`(i_market_id int,
   i_begin date,
   i_end   date,
   i_holidays char(32),  
   i_update_user varchar(32))
label:begin
    declare l_done int; 
    declare v_day date; 


    DECLARE CONTINUE HANDLER FOR NOT FOUND SET l_done=1;
    
    delete from calendar where calendar_day>=i_begin and calendar_day<=i_end and market_id = i_market_id; 
    set v_day = i_begin;
    while  v_day <=i_end do
        insert into calendar(
               market_id,
               calendar_day,
               holiday,
               description
            )
        select 
            i_market_id,
            v_day,
            'N',
            'Working Day'; 
    set v_day  = date_add(v_day,interval 1 day);
    end while; 

    set i_holidays = replace(i_holidays,'7','0');
    update calendar set  Holiday = 'Y',Description  = 'Weekend' where locate(date_format(calendar_day,'%w'),i_holidays); 

    update calendar set update_time = now(), update_user = i_update_user; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proGenerateAutoExcerciseOption
-- ----------------------------
DROP PROCEDURE IF EXISTS `proGenerateAutoExcerciseOption`;
delimiter ;;
CREATE PROCEDURE `proGenerateAutoExcerciseOption`(in  i_trade_date date,
    in  i_user varchar(32),
    out o_ret_code int, 
    out o_ret_message varchar(64))
label:begin
    
    declare  v_process_date date; 
    select buss_date into v_process_date from sys_info ; 

    set o_ret_code = 0; 
    set o_ret_message  = "";

    if i_trade_date  is null then 
        set i_trade_date = v_process_date;
    end if; 

    drop temporary table if exists tmp_exercise; 
    create temporary table tmp_exercise
    (
        id bigint primary key auto_increment, 
        market_id int default 0, 
        product_id varchar(32) default '', 
        account_id varchar(16) default '',
        quantity decimal(30,10) default 0,
        multiplier decimal(30,10) default 0,
        underlying_list_market int default 0, 
        underlying_product_id varchar(32) default '',
        call_put varchar(1) default '',
        exercise_date date, 
        closing_price decimal(30,10) default 0,
        strike_price decimal(30,10) default 0, 
        underlying_quantity decimal(30,10) default 0,
        profit varchar(1) default 'N', 
        enough_underlying_quantity varchar(1) default 'N',
        auto_excercise varchar(1) default 'N',
        index idx(market_id,product_id, account_id), 
        index idx1(underlying_list_market, underlying_product_id, account_id)
    ); 

    -- 插入持仓
    insert into tmp_exercise 
    (
        market_id, 
        product_id,
        account_id, 
        quantity,
        multiplier,
        underlying_list_market, 
        underlying_product_id,
        strike_price,
        call_put,
        exercise_date
    )
    select 
        a.market_id, 
        a.product_id, 
        a.account_id,
        sum(net_quantity),
        b.price_factor,
        underlying_list_market,
        underlying_product_id,
        strike_price, 
        call_put, 
        exercise_date
    from account_position a  
    inner join product b on a.market_id = b.list_market_id and a.product_id = b.product_id and b.exercise_date=i_trade_date
    where process_date = v_process_date  and 
          a.market_id = 2 and 
          a.product_type = 16
    group by market_id ,product_id, account_id
    having sum(net_quantity)>0;

    -- 更新标的持仓相关信息
    update tmp_exercise a 
    inner join product_market_data b on b.trade_date = i_trade_date and  a.underlying_list_market = b.list_market_id and a.underlying_product_id = b.product_id 
    set a.closing_price = b.closing_price;

    -- 更新标的持仓信息
    drop temporary table if exists tmp_position; 
    create temporary  table tmp_position
    (
        id bigint primary key auto_increment, 
        market_id int default 0,
        product_id varchar(32) default '',
        account_id varchar(32) default '', 
        quantity decimal(30,10) default 0, 
        index idx(market_id, product_id, account_id)
    );
    insert into tmp_position
    (
        market_id, 
        product_id, 
        account_id, 
        quantity
    )
    select 
        a.market_id, 
        a.product_id, 
        a.account_id, 
        sum(a.net_quantity)
    from account_position a 
    inner join tmp_exercise b on a.market_id = b.underlying_list_market and  a.product_id = b.underlying_product_id and a.account_id = b.account_id
    where a.process_date = v_process_date; 

    update tmp_exercise a 
    inner join tmp_position b on a.underlying_list_market = b.market_id  and a.underlying_product_id = b.product_id and a.account_id = b.account_id 
    set a.underlying_quantity = b.quantity; 

    -- 盈亏
    update tmp_exercise a
    set a.profit  = case when (a.call_put = 'C'  and a.strike_price < a.closing_price ) or (a.call_put = 'P' and a.strike_price > a.closing_price) then 'Y' else 'N' end ; 

    -- 买put是否有足够的标的
    update tmp_exercise a
    set a.enough_underlying_quantity = case when a.underlying_quantity >= a.quantity*a.multiplier then 'Y' else 'N' end 
    where call_put = 'P';

    -- 程序判断自动行权
    update tmp_exercise a 
    set a.auto_excercise = case when call_put = 'C' then a.profit 
                                when call_put = 'P' and a.enough_underlying_quantity = 'Y' then a.profit 
                           else  'N' end; 

    delete from auto_exercise_option where process_date  = v_process_date; 
    insert into auto_exercise_option
    (
        process_date,
        market_id,
        product_id,
        account_id,
        quantity,
        multiplier,
        underlying_list_market,
        underlying_product_id,
        call_put,
        exercise_date,
        closing_price,
        strike_price,
        underlying_quantity,
        profit,
        enough_underlying_quantity,
        auto_exercise,
        update_user,
        update_time
    )
    select 
        v_process_date,
        market_id,
        product_id,
        account_id,
        quantity,
        multiplier,
        underlying_list_market,
        underlying_product_id,
        call_put,
        exercise_date,
        closing_price,
        strike_price,
        underlying_quantity,
        profit,
        enough_underlying_quantity,
        auto_excercise,
        i_user,
        now()
    from tmp_exercise; 



end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proGenerateAutoexerciseOption
-- ----------------------------
DROP PROCEDURE IF EXISTS `proGenerateAutoexerciseOption`;
delimiter ;;
CREATE PROCEDURE `proGenerateAutoexerciseOption`(in  i_trade_date date,
    in  i_user varchar(32),
    out o_ret_code int, 
    out o_ret_message varchar(64))
label:begin
    
    declare  v_process_date date; 
    declare  v_t0 date; 
    select buss_date into v_process_date from sys_info ; 
    select t0 into v_t0 from market where market_id = 2; 

    set o_ret_code = 0; 
    set o_ret_message  = "";

    if i_trade_date  is null then 
        set i_trade_date = v_t0;
    end if; 



    drop temporary table if exists tmp_exercise; 
    create temporary table tmp_exercise
    (
        id bigint primary key auto_increment, 
        market_id int default 0, 
        product_id varchar(32) default '', 
        account_id varchar(16) default '',
        quantity decimal(30,10) default 0,
        multiplier decimal(30,10) default 0,
        underlying_list_market int default 0, 
        underlying_product_id varchar(32) default '',
        call_put varchar(1) default '',
        exercise_date date, 
        closing_price decimal(30,10) default 0,
        strike_price decimal(30,10) default 0, 
        underlying_quantity decimal(30,10) default 0,
        profit varchar(1) default 'N', 
        enough_underlying_quantity varchar(1) default 'N',
        auto_exercise varchar(1) default 'N',
        index idx(market_id,product_id, account_id), 
        index idx1(underlying_list_market, underlying_product_id, account_id)
    ); 

    -- 插入持仓
    insert into tmp_exercise 
    (
        market_id, 
        product_id,
        account_id, 
        quantity,
        multiplier,
        underlying_list_market, 
        underlying_product_id,
        strike_price,
        call_put,
        exercise_date
    )
    select 
        a.market_id, 
        a.product_id, 
        a.account_id,
        sum(net_quantity),
        b.price_factor,
        underlying_list_market,
        underlying_product_id,
        strike_price, 
        call_put, 
        exercise_date
    from account_position a  
    inner join product b on a.market_id = b.list_market_id and a.product_id = b.product_id and b.exercise_date=i_trade_date
    where process_date = v_process_date  and 
          a.market_id = 2 and 
          a.product_type = 16
    group by market_id ,product_id, account_id
    having sum(net_quantity)>0;

    -- 更新标的持仓相关信息
    update tmp_exercise a 
    inner join product_market_data b on b.trade_date = i_trade_date and  a.underlying_list_market = b.list_market_id and a.underlying_product_id = b.product_id 
    set a.closing_price = b.closing_price;

    -- 更新标的持仓信息
    drop temporary table if exists tmp_position; 
    create temporary  table tmp_position
    (
        id bigint primary key auto_increment, 
        market_id int default 0,
        product_id varchar(32) default '',
        account_id varchar(32) default '', 
        quantity decimal(30,10) default 0, 
        index idx(market_id, product_id, account_id)
    );
    insert into tmp_position
    (
        market_id, 
        product_id, 
        account_id, 
        quantity
    )
    select 
        a.market_id, 
        a.product_id, 
        a.account_id, 
        sum(a.net_quantity)
    from account_position a 
    inner join tmp_exercise b on a.market_id = b.underlying_list_market and  a.product_id = b.underlying_product_id and a.account_id = b.account_id
    where a.process_date = v_process_date
    group by a.market_id, a.product_id, a.account_id;

    update tmp_exercise a 
    inner join tmp_position b on a.underlying_list_market = b.market_id  and a.underlying_product_id = b.product_id and a.account_id = b.account_id 
    set a.underlying_quantity = b.quantity; 

    -- 盈亏
    update tmp_exercise a
    set a.profit  = case when (a.call_put = 'C'  and a.strike_price < a.closing_price ) or (a.call_put = 'P' and a.strike_price > a.closing_price) then 'Y' else 'N' end ; 

    -- 买put是否有足够的标的
    update tmp_exercise a
    set a.enough_underlying_quantity = case when a.underlying_quantity >= a.quantity*a.multiplier then 'Y' else 'N' end 
    where call_put = 'P';

    -- 程序判断自动行权
    update tmp_exercise a 
    set a.auto_exercise = case when call_put = 'C' then a.profit 
                                when call_put = 'P' and a.enough_underlying_quantity = 'Y' then a.profit 
                           else  'N' end; 

    delete from auto_exercise_option where process_date  = v_process_date; 
    insert into auto_exercise_option
    (
        process_date,
        market_id,
        product_id,
        account_id,
        quantity,
        multiplier,
        underlying_list_market,
        underlying_product_id,
        call_put,
        exercise_date,
        closing_price,
        strike_price,
        underlying_quantity,
        profit,
        enough_underlying_quantity,
        auto_exercise,
        update_user,
        update_time
    )
    select 
        v_process_date,
        market_id,
        product_id,
        account_id,
        quantity,
        multiplier,
        underlying_list_market,
        underlying_product_id,
        call_put,
        exercise_date,
        closing_price,
        strike_price,
        underlying_quantity,
        profit,
        enough_underlying_quantity,
        auto_exercise,
        i_user,
        now()
    from tmp_exercise; 



end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proGetAccountTradeDetailCharges
-- ----------------------------
DROP PROCEDURE IF EXISTS `proGetAccountTradeDetailCharges`;
delimiter ;;
CREATE PROCEDURE `proGetAccountTradeDetailCharges`(i_external_id varchar(32), 
   i_external_exec_id varchar(32),
   i_charge_code varchar(32),
   i_formula_type varchar(32))
label:begin
   select external_id,external_id2,charge_code,formula_type,charges,accrued_charges
   from account_charge t 
   where t.external_id =  i_external_id and 
         t.external_id2 = i_external_exec_id and 
         (i_charge_code = '' or t.charge_code =  i_charge_code) and 
         (i_formula_type = '' or t.formula_type = i_formula_type); 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proGetMarketData
-- ----------------------------
DROP PROCEDURE IF EXISTS `proGetMarketData`;
delimiter ;;
CREATE PROCEDURE `proGetMarketData`(i_market_id  varchar(16),
    i_product_id varchar(32), 
    i_trade_date varchar(16))
label:begin
    if i_trade_date = '' then 
        select a.* from product_market_data a
            inner join market b on a.list_market_id = b.market_id and a.trade_date = b.t0
            where (i_market_id  = '' or a.list_market_id = i_market_id) and 
                  (i_product_id = '' or a.product_id = i_product_id); 
    else 
        select a.* from product_market_data a
            where a.trade_date = i_trade_date and 
                  (i_market_id = '' or a.list_market_id = i_market_id) and 
                  (i_product_id = '' or a.product_id = i_product_id); 
    end if; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proHaircutPercent
-- ----------------------------
DROP PROCEDURE IF EXISTS `proHaircutPercent`;
delimiter ;;
CREATE PROCEDURE `proHaircutPercent`(in i_process_date date)
label:begin

    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    
    drop table if exists tmp_haircut_percent_summary;
    create temporary table tmp_haircut_percent_summary
    (
       process_date date,
       account_id varchar(16),
       market_value decimal(30,10),
       market_value_after_haircut decimal(30,10),
       index idx1(process_date,account_id)
    );

    
    insert into tmp_haircut_percent_summary
    (
        process_date, 
        account_id, 
        market_value, 
        market_value_after_haircut
    )
    select 
        a.process_date,
        a.account_id, 
        round(sum(a.market_value), 2) as market_value,
        round(sum(a.market_value_after_haircut), 2 ) as market_value_after_haircut
        from v_account_position_market_value_after_haircut a 
        where a.process_date = i_process_date 
        group by process_date,account_id;


END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proHaoWei
-- ----------------------------
DROP PROCEDURE IF EXISTS `proHaoWei`;
delimiter ;;
CREATE PROCEDURE `proHaoWei`(OUT o_ret_code int,
    OUT o_ret_msg varchar(256))
label: BEGIN

declare v_approved varchar(256);

START TRANSACTION;

SET o_ret_code = 0, o_ret_msg = "Success";

    set @v_id = 0;
    set @v_serial_nbr = NULL;
    set v_approved = NULL;
    loop_sum: LOOP
        set v_approved = NULL;
        
        set @v_serial_nbr = NULL;
        select id,serial_nbr
        into @v_id,@v_serial_nbr
        from tmp_sum_flow where id > @v_id
        order by id limit 1;
            
        if @v_serial_nbr is null then 
            leave loop_sum;
        end if;

        set @v_d_id = 0;
        loop_detail:LOOP
            set @v_state = NULL;
            select id,state
            into @v_d_id,@v_state
            from (select max(id) as id,serial_nbr,state from tmp_detail group by serial_nbr,state) t
            where t.id > @v_d_id and t.serial_nbr = @v_serial_nbr and ifnull(t.state,'') <> ''
            order by id limit 1;

            if @v_state is null then 
                leave loop_detail;
            end if;

            set v_approved = if(v_approved is null,@v_state,concat(v_approved,',',@v_state));

        end LOOP;
        
        update tmp_sum_flow
        set approved = v_approved
        where serial_nbr = @v_serial_nbr;

    end LOOP;

    select * from tmp_sum_flow;

COMMIT;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proHKMarketBoughtSoldJournal
-- ----------------------------
DROP PROCEDURE IF EXISTS `proHKMarketBoughtSoldJournal`;
delimiter ;;
CREATE PROCEDURE `proHKMarketBoughtSoldJournal`(in i_process_date date)
label:begin
    

    
    drop table if exists tmp_group; 
    create temporary table tmp_group
    (
        id bigint primary key auto_increment,
        buy_sell int, 
        trade_date date, 
        settle_date date, 
        currency int, 
        index idx(buy_sell, trade_date, settle_date, currency)
    ); 
    insert into tmp_group
    (
        buy_sell, 
        trade_date, 
        settle_date, 
        currency
    )
    select 
        buy_sell, 
        trade_date, 
        settle_date, 
        clearing_currency 
    from account_trade 
    where process_date = i_process_date
    and market_id = 1 
    group by buy_sell, trade_date, settle_date,clearing_currency
    order by buy_sell, trade_date, settle_date, clearing_currency; 

    drop table if exists tmp_rpt; 
    create temporary table tmp_rpt
    (
        
        id bigint primary key  auto_increment, 
        group_id int, 
        type int, 
        trade_id varchar(32), 
        show_order_id bigint, 
        trade_date date, 
        settle_date date, 
        market_id int, 
        product_id varchar(16), 
        product_desc varchar(64), 
        currency int, 
        account_id varchar(16), 
        account_name varchar(128), 
        input_channel int, 
        buy_sell int, 
        avg_price decimal(30,10), 
        quantity decimal(30,10), 
        turnover decimal(30,10), 
        stamp decimal(30,10), 
        ccass_clearing_fee decimal(30,10), 
        trading_fee decimal(30,10), 
        levy decimal(30,10), 
        others decimal(30,10), 
        commission decimal(30,10), 
        net_amount decimal(30,10), 
        index idx(buy_sell, trade_date, settle_date, currency), 
        index idx2(trade_id,group_id)
    ); 

    
    insert into tmp_rpt
    (
       type, 
       trade_id, 
       trade_date, 
       settle_date, 
       market_id, 
       product_id, 
       product_desc, 
       currency, 
       account_id, 
       account_name, 
       input_channel, 
       buy_sell, 
       avg_price, 
       quantity, 
       turnover, 
       commission, 
       net_amount
    )
    select 
        1,  
        a.trade_id, 
        a.trade_date, 
        a.settle_date, 
        a.market_id, 
        a.product_id, 
        ifnull(b.product_description,''),
        a.clearing_currency, 
        a.account_id,
        ifnull(c.short_name,''), 
        a.input_channel, 
        a.buy_sell, 
        a.avg_price, 
        a.quantity,
        a.trade_amount, 
        a.commission, 
        case  when a.buy_sell = 1 then -1 else 1 end *a.net_amount
    from account_trade a  
    left join product b on a.market_id = b.list_market_id and a.product_id= b.product_id
    left join account_profile c on a.account_id = c.account_id
    where a.process_date = i_process_date
    and market_id = 1 
    order by a.market_id,a.product_id,a.account_id,a.trade_id; 

    
    update tmp_rpt a 
    left join tmp_group b on a.buy_sell = b.buy_sell and a.trade_date = b.trade_date and a.settle_date = b.settle_date and a.currency = b.currency
    set a.group_id =b.id,
        a.show_order_id = a.id;

    
    drop table if exists tmp_charges; 
    create temporary table tmp_charges
    (
        trade_id varchar(32), 
        ccass_clearing_fee decimal(30,10), 
        stamp decimal(30,10),
        trading_fee decimal(30,10), 
        levy decimal(30,10), 
        others decimal(30,10), 
        index idx1(trade_id)
    ); 

    insert into tmp_charges
    select 
        a.trade_id,
        sum(round(case when b.charge_code = 'CCASS_HK:HK' then b.charges else 0 end *ifnull(d.exchange_rate,c.exchange_rate) ,2)) as ccass_clearing_fee,
        sum(round(case when b.charge_code = 'STAMP_HK:HK' then b.charges else 0 end *ifnull(d.exchange_rate,c.exchange_rate) ,2)) as stamp,
        sum(round(case when b.charge_code = 'TFEE_HK:HK' then b.charges else 0 end *ifnull(d.exchange_rate,c.exchange_rate) ,2)) as trading_fee,
        sum(round(case when b.charge_code = 'LEVY_HK:HK' then b.charges else 0 end *ifnull(d.exchange_rate,c.exchange_rate) ,2)) as levy,
        sum(round(case when b.charge_code not in ('CCASS_HK:HK','STAMP_HK:HK','TFEE_HK:HK','LEVY_HK:HK','HK_DEFAULT_COMMISSION') then b.charges else 0 end *ifnull(d.exchange_rate,c.exchange_rate) ,2)) as others
    from account_trade a 
    inner join account_charge b on a.trade_id = b.external_id
    left join currency c on b.currency = c.currency 
    left join currency_history d on a.process_date = d.process_date and b.currency = d.currency
    where a.process_date = i_process_date and a.market_id  = 1
    group by a.trade_id;


    update tmp_rpt a  
    left join tmp_charges b on a.trade_id = b.trade_id
    set 
        a.stamp = ifnull(b.stamp,0), 
        a.ccass_clearing_fee = ifnull(b.ccass_clearing_fee,0), 
        a.trading_fee = ifnull(b.trading_fee,0), 
        a.levy = ifnull(b.levy,0), 
        a.others = ifnull(b.others,0); 


    
    drop table if exists tmp_rpt_detail_id;
    create table tmp_rpt_detail_id
    (
        group_id int, 
        trade_id varchar(64), 
        show_order_id bigint,
        index idx1(trade_id)
    );

    insert into tmp_rpt_detail_id
    select group_id,trade_id,show_order_id
    from tmp_rpt 
    group by trade_id,group_id,show_order_id;

    insert into tmp_rpt
    (
        type, 
        group_id, 
        show_order_id,
        trade_id, 
        avg_price, 
        quantity
    ) 
    select 
        2,
        c.group_id, 
        c.show_order_id,
        c.trade_id,
        ifnull(b.exec_price,0), 
        ifnull(b.exec_quantity,0)
    from account_trade a 
    left join account_trade_detail b on a.trade_id = b.trade_id
    inner join tmp_rpt_detail_id c on a.trade_id = c.trade_id
    order by a.trade_id, b.trade_exec_id; 
    
    select * 
    from tmp_rpt
    order by group_id, show_order_id, type; 
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proHKTradeSummary
-- ----------------------------
DROP PROCEDURE IF EXISTS `proHKTradeSummary`;
delimiter ;;
CREATE PROCEDURE `proHKTradeSummary`(in i_process_date date)
label:begin
    

    
    drop table if exists tmp_charges; 
    create temporary table tmp_charges
    (
        account_type int, 
        buy_sell int, 
        ccass_clearing_fee decimal(30,10), 
        stamp decimal(30,10),
        trading_fee decimal(30,10), 
        levy decimal(30,10), 
        others decimal(30,10), 
        index idx1(account_type, buy_sell)
    ); 

    insert into tmp_charges
    select 
        a.account_type,
        a.buy_sell,
        sum(round(case when b.charge_code = 'CCASS_HK:HK' then b.charges else 0 end *ifnull(d.exchange_rate,c.exchange_rate) ,2)) as ccass_clearing_fee,
        sum(round(case when b.charge_code = 'STAMP_HK:HK' then b.charges else 0 end *ifnull(d.exchange_rate,c.exchange_rate) ,2)) as stamp,
        sum(round(case when b.charge_code = 'TFEE_HK:HK' then b.charges else 0 end *ifnull(d.exchange_rate,c.exchange_rate) ,2)) as trading_fee,
        sum(round(case when b.charge_code = 'LEVY_HK:HK' then b.charges else 0 end *ifnull(d.exchange_rate,c.exchange_rate) ,2)) as levy,
        sum(round(case when b.charge_code not in ('CCASS_HK:HK','STAMP_HK:HK','TFEE_HK:HK','LEVY_HK:HK','HK_DEFAULT_COMMISSION') then b.charges else 0 end *ifnull(d.exchange_rate,c.exchange_rate) ,2)) as others
    from account_trade a 
    inner join account_charge b on a.trade_id = b.external_id
    left join currency c on b.currency = c.currency 
    left join currency_history d on a.process_date = d.process_date and b.currency = d.currency
    where a.process_date = i_process_date and a.market_id  = 1
    group by a.account_type,a.buy_sell;

    drop table if exists tmp_rpt; 
    create temporary table tmp_rpt
    (
        account_type int, 
        buy_sell int,
        broker_payable_receivable decimal(30,10), 
        commission_income decimal(30,10), 
        ae_commission decimal(30,10), 
        net_income decimal(30,10),
        stamp decimal(30,10), 
        ccass_clearing_fee decimal(30,10), 
        trading_fee decimal(30,10), 
        levy decimal(30,10), 
        others decimal(30,10), 
        client_receivalbe_payable decimal(30,10), 
        index idx(account_type, buy_sell)
    );

    insert into tmp_rpt
    (
        account_type, 
        buy_sell, 
        broker_payable_receivable, 
        commission_income, 
        ae_commission, 
        client_receivalbe_payable
    )
    select 
        a.account_type,
        buy_sell,
        sum(round(a.trade_amount*ifnull(c.exchange_rate,b.exchange_rate),2)) as broker_payable_receivable, 
        sum(round(a.commission*ifnull(c.exchange_rate,b.exchange_rate),2)) as commission_income,
        0 as ae_income, 
        sum(round(a.net_amount*ifnull(c.exchange_rate,b.exchange_rate),2)) as client_receivalbe_payable
    from account_trade a 
    left join currency b on a.clearing_currency = b.currency 
    left join currency_history c on a.process_date = c.process_date and a.clearing_currency = c.currency
    where a.process_date = i_process_date
    and a.market_id = '1'
    group by a.account_type, buy_sell; 

    update tmp_rpt a  
    left join tmp_charges b on a.account_type = b.account_type and a.buy_sell = b.buy_sell
    set a.net_income = a.commission_income+ a.ae_commission, 
        a.stamp = ifnull(b.stamp,0), 
        a.ccass_clearing_fee = ifnull(b.ccass_clearing_fee,0), 
        a.trading_fee = ifnull(b.trading_fee,0), 
        a.levy = ifnull(b.levy,0), 
        a.others = ifnull(b.others,0); 

    select *from tmp_rpt;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proHousePosition
-- ----------------------------
DROP PROCEDURE IF EXISTS `proHousePosition`;
delimiter ;;
CREATE PROCEDURE `proHousePosition`(in i_process_date date,
    in i_account_id varchar(32),
    OUT o_ret_code int,
    OUT o_ret_msg char(128))
label:begin
/*
文件名的格式为 XYZ_Position_YYYYMMDD.txt，XYZ 表示机构客人的标识，YYYYMMDD 表示香港的业务日期
*/

    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    -- 创建临时表
    drop temporary table if exists tmp_Final_Table;
    create temporary table tmp_Final_Table
    (
        AccountID   varchar(8),
        MarketID varchar(8),
        Symbol varchar(31),
        SymbolName varchar(128),
        Currency varchar(3),
        Volume decimal(30,4) default 0.0,
        SettledVolume decimal(30,4) default 0.0,
        AvgCostPrice decimal(30,5) default 0.0,
        ClosePrice decimal(30,4) default 0.0,
        MarketValue decimal(30,2) default 0.0,
        index idx1(AccountID,Currency)
    );

    -- 取满足条件的账户的其他币种数据
    insert into tmp_Final_Table
    (
        AccountID,
        MarketID,
        Symbol,
        SymbolName,
        Currency,
        Volume, 
        SettledVolume, 
        AvgCostPrice,
        ClosePrice,
        MarketValue
    )
    select
       a.account_id,
       funMarketID(a.market_id) as MarketID,
       a.product_id,
       d.product_description,
       b.currency_desc,
       round(a.net_quantity,4),
       round(a.quantity,4),
       round(a.avg_price1,5),
       round(a.closing_price,4),
       round(a.market_value,2)
    from account_position a 
    left join product d on d.list_market_id = a.market_id and d.product_id = a.product_id
    left join currency b on b.currency = d.currency 
    where a.process_date = i_process_date and 
          a.account_id in (select account_id from account_profile where /*account_class in (1,2,5,7) and*/ length(account_id) = 8 and (ifnull(i_account_id,'') = '' or account_id = i_account_id)); 

    select * from tmp_Final_Table order by AccountID,MarketID,Symbol; 
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proImportCorpaction
-- ----------------------------
DROP PROCEDURE IF EXISTS `proImportCorpaction`;
delimiter ;;
CREATE PROCEDURE `proImportCorpaction`(OUT o_ret_code int,
    OUT o_ret_msg varchar(32))
label:begin
start transaction; 
    set o_ret_code = 0, o_ret_msg ="Success";

    
    
    

    update tmp_corp_action a, market_product_mapping b 
        set a.product_id = b.to_product_id 
        where a.market_id = b.market_id  and a.product_id = b.product_id; 
    

    

    
    
    
    
    
    
    
    update tmp_corp_action a, market_product_mapping b 
    set a.to_product_id = b.to_product_id 
    where a.market_id = b.market_id  and a.to_product_id = b.product_id and a.to_product_id <> '00000';
    

    
    
    
    

    
    insert into corp_action
    (
        event_id,
        event_type,
        market_id,
        product_id,
        external_product_id,
        description,
        ex_date,
        register_date,
        bc_date_from,
        bc_date_to,
        pay_date,
        scrip_fee,
        announce_ccy,
        dividend_ccy,
        dividend_rate,
        tax_rate,
        net_dividend_rate,
        base_ccy,
        convert_ccy,
        exchange_rate,
        scrip_price,
        to_product_id,
        to_external_product_id,
        ratio_from,
        ratio_to,
        charge_id1,
        charge_id2,
        optional,
        m_default,
        elect_time_from,
        elect_time_to,
        sub_time_from,
        sub_time_to,
        sub_ccy,
        sub_price,
        trade_time_from,
        trade_time_to,
        remark, 
        book_closed , 
        posted , 
        record_count ,          
        update_user , 
        update_time , 
        nominee
    )
    select 
        event_id,
        event_type,
        market_id,
        product_id,
        external_product_id,
        description,
        ex_date,
        register_date,
        bc_date_from,
        bc_date_to,
        pay_date,
        scrip_fee,
        announce_ccy,
        dividend_ccy,
        dividend_rate,
        tax_rate,
        net_dividend_rate,
        base_ccy,
        convert_ccy,
        exchange_rate,
        scrip_price,
        to_product_id,
        to_external_product_id,
        ratio_from,
        ratio_to,
        charge_id1,
        charge_id2,
        optional,
        m_default,
        elect_time_from,
        elect_time_to,
        sub_time_from,
        sub_time_to,
        sub_ccy,
        sub_price,
        trade_time_from,
        trade_time_to,
        remark, 
        'N',
        'N',
         0,
        update_user,  
        update_time,  
        case when t.to_product_id <> '' then 'Y' else 'N' end 
    from tmp_corp_action t 
    where not exists(select 1 from corp_action a where a.event_id = t.event_id);

    
    update corp_action a, tmp_corp_action b 
        set 
            a.event_id = b.event_id,
            a.event_type = b.event_type,
            a.market_id = b.market_id,
            a.product_id = b.product_id,
            a.external_product_id = b.external_product_id,
            a.description = b.description,
            a.ex_date = b.ex_date,
            a.register_date = b.register_date,
            a.bc_date_from = b.bc_date_from,
            a.bc_date_to = b.bc_date_to,
            a.pay_date = b.pay_date,
            a.scrip_fee = b.scrip_fee,
            a.announce_ccy = b.announce_ccy,
            a.dividend_ccy = b.dividend_ccy,
            a.dividend_rate = b.dividend_rate,
            a.tax_rate = b.tax_rate,
            a.net_dividend_rate = b.net_dividend_rate,
            a.base_ccy = b.base_ccy,
            a.convert_ccy = b.convert_ccy,
            a.exchange_rate = b.exchange_rate,
            a.scrip_price = b.scrip_price,
            a.to_product_id = b.to_product_id,
            a.to_external_product_id = b.to_external_product_id,
            a.ratio_from = b.ratio_from,
            a.ratio_to = b.ratio_to,
            a.charge_id1 = b.charge_id1,
            a.charge_id2 = b.charge_id2,
            a.optional = b.optional,
            a.m_default = b.m_default,
            a.elect_time_from = b.elect_time_from,
            a.elect_time_to = b.elect_time_to,
            a.sub_time_from = b.sub_time_from,
            a.sub_time_to = b.sub_time_to,
            a.sub_ccy = b.sub_ccy,
            a.sub_price = b.sub_price,
            a.trade_time_from = b.trade_time_from,
            a.trade_time_to = b.trade_time_to,
            a.remark = b.remark,
            
            
            
            a.update_user  = b.update_user,
            a.update_time = b.update_time,
            a.nominee = case when b.to_product_id<> '' then 'Y' else 'N' end
        where a.event_id = b.event_id; 

    	update corp_action a, market_corp_action b
		set a.charge_id1 = b.charge_id1,
		 a.charge_id2 = b.charge_id2,
		 a.charge_id3 = b.charge_id3,
		 a.charge_id4 = b.charge_id4,
		 a.subscribe_charge_id1 = b.subscribe_charge_id1,
		 a.subscribe_charge_id2 = b.subscribe_charge_id2,
		 a.subscribe_charge_id3 = b.subscribe_charge_id3,
		 a.subscribe_charge_id4 = b.subscribe_charge_id4
	where a.market_id = b.market and a.event_type = b.event_type and a.event_id not like '%-%-%-%';
    
commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proImportCorpaction.sql
-- ----------------------------
DROP PROCEDURE IF EXISTS `proImportCorpaction.sql`;
delimiter ;;
CREATE PROCEDURE `proImportCorpaction.sql`(OUT o_ret_code int,
    OUT o_ret_msg varchar(32))
label:begin
start transaction; 
    set o_ret_code = 0, o_ret_msg ="Success";

    
     insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 1, 
           'batch_cash_in_out',
           market_id,
           product_id,
           '',
           "product not exists",
           update_user,
           update_time  
    from tmp_corp_action t where not EXISTS (
            select 1 from market_product_mapping a
                inner join market b on a.market_id = b.market_id and a.t0 = b.trading_date
                where a.mapping_code = 'CCASS' and a.market_id = t.market_id and a.product_id = t.product_id 
        ); 
    
    
    if EXISTS(select 1 from CheckWarnings) then 
        set o_ret_code = 1, o_ret_msg = "Product not exists";
        rollback;
        leave label;
    else 
        update tmp_corp_action a, market_product_mapping b 
            set a.product_id = b.to_product_id 
            where a.market_id = b.market_id  and a.product_id = b.product_id; 
    end if; 

    
    if EXISTS(select 1 from CheckWarnings) then 
        set o_ret_code = 1, o_ret_msg = "Account not exists";
        leave label;
    end if; 

    
    insert into cor_action
    (
        event_id,
        event_type,
        market_id,
        product_id,
        external_product_id,
        description,
        ex_date,
        register_date,
        bc_date_from,
        bc_date_to,
        pay_date,
        scrip_fee,
        announce_ccy,
        dividend_ccy,
        dividend_rate,
        tax_rate,
        net_dividend_rate,
        base_ccy,
        convert_ccy,
        exchange_rate,
        scrip_price,
        to_product_id,
        to_external_product_id,
        ratio_from,
        ratio_to,
        optional,
        m_default,
        elect_time_from,
        elect_time_to,
        sub_time_from,
        sub_time_to,
        sub_ccy,
        sub_price,
        trade_time_from,
        trade_time_to,
        remark, 
        book_closed , 
        posted , 
        record_count ,          
        update_user , 
        update_time 
    )
    select 
        event_id,
        event_type,
        market_id,
        product_id,
        external_product_id,
        description,
        ex_date,
        register_date,
        bc_date_from,
        bc_date_to,
        pay_date,
        scrip_fee,
        announce_ccy,
        dividend_ccy,
        dividend_rate,
        tax_rate,
        net_dividend_rate,
        base_ccy,
        convert_ccy,
        exchange_rate,
        scrip_price,
        to_product_id,
        to_external_product_id,
        ratio_from,
        ratio_to,
        optional,
        m_default,
        elect_time_from,
        elect_time_to,
        sub_time_from,
        sub_time_to,
        sub_ccy,
        sub_price,
        trade_time_from,
        trade_time_to,
        remark, 
        'N',
        'N',
        'N',
         0,
        update_user,  
        update_time   
    from tmp_corp_action t 
    where not exists(select 1 from corp_action a where a.event_id = t.event_id);

    
    update corp_action a, tmp_corp_action b 
        set 
            a.event_id = b.event_id,
            a.event_type = b.event_type,
            a.market_id = b.market_id,
            a.product_id = b.product_id,
            a.external_product_id = b.external_product_id,
            a.description = b.description,
            a.ex_date = b.ex_date,
            a.register_date = b.register_date,
            a.bc_date_from = b.bc_date_from,
            a.bc_date_to = b.bc_date_to,
            a.pay_date = b.pay_date,
            a.scrip_fee = b.scrip_fee,
            a.announce_ccy = b.announce_ccy,
            a.dividend_ccy = b.dividend_ccy,
            a.dividend_rate = b.dividend_rate,
            a.tax_rate = b.tax_rate,
            a.net_dividend_rate = b.net_dividend_rate,
            a.base_ccy = b.base_ccy,
            a.convert_ccy = b.convert_ccy,
            a.exchange_rate = b.exchange_rate,
            a.scrip_price = b.scrip_price,
            a.to_product_id = b.to_product_id,
            a.to_external_product_id = b.to_external_product_id,
            a.ratio_from = b.ratio_from,
            a.ratio_to = b.ratio_to,
            a.optional = b.optional,
            a.m_default = b.m_default,
            a.elect_time_from = b.elect_time_from,
            a.elect_time_to = b.elect_time_to,
            a.sub_time_from = b.sub_time_from,
            a.sub_time_to = b.sub_time_to,
            a.sub_ccy = b.sub_ccy,
            a.sub_price = b.sub_price,
            a.trade_time_from = b.trade_time_from,
            a.trade_time_to = b.trade_time_to,
            a.remark = b.remark,
            
            
            
            a.update_user  = b.update_user,
            a.update_time = b.update_time
        where a.event_id = b.event_id; 
commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proImportCustodianAccountPosition
-- ----------------------------
DROP PROCEDURE IF EXISTS `proImportCustodianAccountPosition`;
delimiter ;;
CREATE PROCEDURE `proImportCustodianAccountPosition`(OUT o_ret_code int,
    OUT o_ret_msg varchar(32))
label:begin

    set o_ret_code = 0, o_ret_msg ="Success";

    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    start transaction; 

    drop temporary table if exists tmp_market; 
    create temporary table tmp_market 
    (
        process_date date, 
        market_id int, 
        index idx1(process_date,market_id)
    ); 

    insert into tmp_market
    select process_date, 
           market_id 
           from tmp_custodian_account_position group by process_date,market_id; 

    delete a from custodian_account_position a 
    where exists (select 1 from tmp_market b where a.process_date = b.process_date and a.market_id = b.market_id);

    insert into custodian_account_position
    (
        process_date,
        market_id,
        product_id,
        custodian_code,
        custodian_account,
        quantity,
        currency,
        market_value,
        update_time,
        update_user
    )
    select 
        process_date,
        market_id,
        product_id,
        custodian_code,
        custodian_account,
        quantity,
        currency,
        market_value,
        update_time,
        update_user
    from tmp_custodian_account_position;

    UPDATE custodian_account_position cap 
	INNER JOIN market_product_mapping mpm ON cap.product_id=mpm.product_id
	INNER JOIN market m on m.1t = cap.process_date and m.market_id = cap.market_id
        SET cap.product_id=mpm.to_product_id;
commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proImportExchangeTrade
-- ----------------------------
DROP PROCEDURE IF EXISTS `proImportExchangeTrade`;
delimiter ;;
CREATE PROCEDURE `proImportExchangeTrade`(OUT o_ret_code int,
    OUT o_ret_msg varchar(32))
label:begin
    declare v_process_date  date;
    start transaction; 
    set o_ret_code = 0, o_ret_msg ="Success";

    select buss_date into v_process_date from sys_info; 

    insert into exchange_trade
	(
        trade_date,
        market_id,
        buy_sell,
        exec_quantity,
        exec_price,
        exec_broker,
        product_id,
        currency,
        product_desc,
        exec_time,
        contra_broker,
        trade_type,
        remark,
        exchange_reference_no
	)
    SELECT
        t.trade_date,
        t.market_id,
        t.buy_sell,
        t.exec_quantity,
        t.exec_price,
        t.exec_broker,
        t.product_id,
        t.currency,
        t.product_desc,
        t.exec_time,
        t.contra_broker,
        t.trade_type,
        t.remark,
        t.exchange_reference_no
    from import_exchange_trade t
	where not exists(select 1 from exchange_trade a where a.trade_date = v_process_date and a.exchange_reference_no = t.exchange_reference_no);

    commit; 

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proImportfundPurchaseRedemption
-- ----------------------------
DROP PROCEDURE IF EXISTS `proImportfundPurchaseRedemption`;
delimiter ;;
CREATE PROCEDURE `proImportfundPurchaseRedemption`(OUT o_ret_code int,
    OUT o_ret_msg varchar(256))
label: BEGIN
    DECLARE v_process_date date;

    START TRANSACTION;

    SET o_ret_code = 0, o_ret_msg = "Success";
    
    IF EXISTS(SELECT 1 FROM tmp_fund_purchase_redemption WHERE product_id IS NULL) THEN
        SET o_ret_code = 1, o_ret_msg = "product_id exist_null";
        LEAVE label;
    END IF;
    
    IF EXISTS(SELECT 1 FROM tmp_fund_purchase_redemption WHERE account_id NOT IN (SELECT DISTINCT account_id FROM capital_account) ) THEN
        SET o_ret_code = 1, o_ret_msg = "account_id not_exist in capital_account";
        LEAVE label;
    END IF;

    select buss_date into v_process_date from sys_info;

    
    DELETE from fund_purchase_redemption  
    WHERE process_date = v_process_date;
    
    replace INTO fund_purchase_redemption(
        id,process_date,trade_date,settle_date,account_id,account_type,product_id,order_type,
        apply_qty,
        qty,
        price,
        amount,
        fee,
        update_date,
        status
    )
    SELECT 
        NULL,v_process_date,a.trade_date,a.settle_date,a.account_id,a.account_type,a.product_id,
        a.order_type,
        a.apply_qty,
        case a.order_type when 4 then a.amount else 0 end,
        a.price,
        case a.order_type when 3 then a.amount else 0 end,
        a.fee,
        a.update_date,NULL
        FROM tmp_fund_purchase_redemption a;
    
    
    UPDATE fund_purchase_redemption a
    INNER JOIN capital_account c ON a.account_id = c.account_id
    SET
        a.account_type = c.account_type
    where a.process_date = v_process_date;

    COMMIT;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proImportInstrumentInfo
-- ----------------------------
DROP PROCEDURE IF EXISTS `proImportInstrumentInfo`;
delimiter ;;
CREATE PROCEDURE `proImportInstrumentInfo`()
label: BEGIN

    delete t from tmp_import_product_info t where not EXISTS(select 1 from market  a where t.list_market_id  = a.market_id);

    update tmp_import_product_info a, market b 
        set a.trade_date = b.t0 
        where a.list_market_id = b.market_id; 

    
    insert into product(
        
        list_market_id, 
        product_id, 
        product_description,
        product_class,
        product_type,
        settle_date,
        listing_date,
        last_trading_date, 
        price_factor,
        contract_size,
        quote_currency,
        currency,
        
        
        update_user,
        update_time
    )
    select 
        
        list_market_id, 
        product_id, 
        product_description,
        product_class,
        product_type,
        settle_day,
        listing_date,
        last_trading_date, 
        price_factor,
        contract_size,
        quote_currency,
        currency,
        
        
        update_user,
        now()
    from tmp_import_product_info t 
    where not EXISTS(select 1 from product t2 where t2.list_market_id = t.list_market_id and t2.product_id = t.product_id); 

    update product t
        inner join tmp_import_product_info b on t.list_market_id = b.list_market_id and t.product_id = b.product_id
        set 
        
        
        t.product_description =b.product_description,
        t.product_class = b.product_class,
        t.product_type = b.product_type,
        t.settle_date = b.settle_day,
        t.listing_date = b.listing_date,
        t.last_trading_date = b.last_trading_date, 
        t.price_factor = b.price_factor,
        t.contract_size = b.contract_size,
        t.quote_currency = b.quote_currency,
        t.currency = b.currency,
        
        
        t.update_user = b.update_user, 
        t.update_time = now(); 



    
    insert into product_market_data(
        trade_date, 
        list_market_id, 
        product_id, 
        product_description,
        product_class,
        product_type,
        settle_price,
        closing_price,
        update_user,
        update_time
    )
    select 
        trade_date, 
        list_market_id, 
        product_id, 
        product_description,
        product_class,
        product_type,
        settle_price,
        closing_price,
        update_user,
        now()
    from tmp_import_product_info t 
    where not EXISTS(select 1 from product_market_data t2 where t2.list_market_id = t.list_market_id and t2.product_id = t.product_id); 

    update product_market_data t
        inner join tmp_import_product_info b on t.list_market_id = b.list_market_id and t.product_id = b.product_id
        set
        t.trade_date = b.trade_date, 
        
        
        t.product_description =b.product_description,
        t.product_class = b.product_class,
        t.product_type = b.product_type,
        t.last_settle_price = t.settle_price,
        t.settle_price = b.settle_price,
        t.last_settle_price = t.settle_price,
        t.last_closing_price = t.closing_price,
        t.closing_price = b.closing_price,
        t.update_user = b.update_user, 
        t.update_time = now(); 


end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proImportIPOModifyResult
-- ----------------------------
DROP PROCEDURE IF EXISTS `proImportIPOModifyResult`;
delimiter ;;
CREATE PROCEDURE `proImportIPOModifyResult`(IN  i_ipo_id varchar(32),
    IN  i_list_market_id varchar(32),
    IN  i_product_id varchar(32),
    IN  i_account_id varchar(32),
    IN  i_allot_qty int,
    IN  i_allot_price decimal(30,10),
    IN  i_refund_amount decimal(30,10),
    OUT o_ret_code int,
    OUT o_ret_msg varchar(32))
label:BEGIN
START TRANSACTION;
    SET o_ret_code = 0, o_ret_msg ="Success";

    DELETE FROM tmp_product_ipo_allotation WHERE ipo_id=i_ipo_id AND account_id = i_account_id;

    INSERT INTO tmp_product_ipo_allotation
        (  ipo_id,  account_id,  list_market_id,  product_id,  allot_qty,  allot_price,  refund_amount,update_time)VALUES
        (i_ipo_id,i_account_id,i_list_market_id,i_product_id,i_allot_qty,i_allot_price,i_refund_amount,now());


    UPDATE product_ipo_app a, tmp_product_ipo_allotation b
    SET a.allot_price = b.allot_price,
        a.allot_qty = b.allot_qty,
        a.refund_amount = b.refund_amount 
    WHERE a.list_market_id = b.list_market_id AND
        a.product_id = b.product_id AND
        a.account_id = b.account_id AND
        a.ipo_id = b.ipo_id AND
        a.ipo_id = i_ipo_id AND
        a.account_id = i_account_id;


COMMIT;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proImportMarketProductMapping
-- ----------------------------
DROP PROCEDURE IF EXISTS `proImportMarketProductMapping`;
delimiter ;;
CREATE PROCEDURE `proImportMarketProductMapping`(OUT o_ret_code int,
    OUT o_ret_msg varchar(32))
begin
start transaction; 
    set o_ret_code = 0, o_ret_msg ="Success";
    
    
    update market_product_mapping a, tmp_market_product_mapping b 
        set 
            
            a.mapping_code=b.mapping_code,
            
            a.market_id=b.market_id,
            a.to_product_id=b.to_product_id,
            a.update_time=b.update_time,
            a.update_user=b.update_user
        where a.product_id=b.product_id;
    
    
    insert into market_product_mapping
    (
        
        mapping_code,
        market_id,
        product_id,
        to_product_id,
        update_time,
        update_user
    )
    select 
        
        mapping_code,
        market_id,
        product_id,
        to_product_id,
        update_time,
        update_user
    from tmp_market_product_mapping t 
    where not exists(select 1 from market_product_mapping a where a.product_id=t.product_id);
commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proImportOfficialProductCloseprice
-- ----------------------------
DROP PROCEDURE IF EXISTS `proImportOfficialProductCloseprice`;
delimiter ;;
CREATE PROCEDURE `proImportOfficialProductCloseprice`(OUT o_ret_code int,
    OUT o_ret_msg varchar(32))
begin
start transaction; 
    set o_ret_code = 0, o_ret_msg ="Success";
    
    
    update official_product_closeprice a, tmp_official_product_closeprice b 
        set 
            
            
            
            
            a.closing_price=b.closing_price,
            a.status = b.status,
            a.update_user=b.update_user,
            a.update_time=b.update_time
        where a.trade_date=b.trade_date AND a.market_id=b.market_id AND a.product_id=b.product_id;
    
    
    insert into official_product_closeprice
    (
        
        trade_date,
        market_id,
        product_id,
        closing_price,
        status,
        update_user,
        update_time
    )
    select 
        
        trade_date,
        market_id,
        product_id,
        closing_price,
        status,
        update_user,
        update_time
    from tmp_official_product_closeprice t 
    where not exists(select 1 from official_product_closeprice a where a.trade_date=t.trade_date AND a.market_id=t.market_id AND a.product_id=t.product_id);

    update product a
    inner join tmp_official_product_closeprice b on b.market_id = a.list_market_id and b.product_id = a.product_id
    set a.STATUS = case b.STATUS 
                    when 'A' then 1 
                    when 'S' then 3 
                    when 'B' then 4 
                    when 'U' then 2 
                    when 'Y' then 2
                    when 'N' then 1 
                    else 2 end;

commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proImportProductIpoApp
-- ----------------------------
DROP PROCEDURE IF EXISTS `proImportProductIpoApp`;
delimiter ;;
CREATE PROCEDURE `proImportProductIpoApp`(OUT o_ret_code int,
    OUT o_ret_msg varchar(256))
label: BEGIN
DECLARE v_ipo_id_cnt INT DEFAULT 0;

START TRANSACTION;

SET o_ret_code = 0, o_ret_msg = "Success";

IF EXISTS(SELECT 1 FROM tmp_product_ipo_app WHERE ipo_id IS NULL) THEN
    SET o_ret_code = 1, o_ret_msg = "ipo_id exist_null";
    LEAVE label;
END IF;

IF EXISTS(SELECT 1 FROM tmp_product_ipo_app WHERE account_id NOT IN (SELECT DISTINCT account_id FROM capital_account) ) THEN
    SET o_ret_code = 1, o_ret_msg = "account_id not_exist in capital_account";
    LEAVE label;
END IF;

IF EXISTS(SELECT 1 FROM tmp_product_ipo_app WHERE ipo_id NOT IN (SELECT DISTINCT ipo_id FROM product_ipo_announcement) ) THEN
    SET o_ret_code = 1, o_ret_msg = "ipo_id not_exist in base table";
    LEAVE label;
END IF;
DELETE FROM product_ipo_app WHERE ipo_id IN (SELECT DISTINCT ipo_id FROM tmp_product_ipo_app) and app_posted <> 'Y';

replace INTO product_ipo_app(
    ipo_id, account_id, account_type, list_market_id, product_id, quantity, amount, currency, loan_ratio, 
    loan_amount, interest_rate, interest,loan_charge, allot_qty, allot_price, refund_amount, remark, created_time, update_time, update_user,
    sub_status)
SELECT 
    a.ipo_id, a.account_id, a.account_type, a.list_market_id, a.product_id, a.quantity, a.amount, a.currency, a.loan_ratio, 
    a.loan_amount, a.interest_rate, a.interest,a.loan_charge, a.allot_qty, a.allot_price, a.refund_amount, a.remark, a.created_time, a.update_time, 
    a.update_user,a.sub_status
    FROM tmp_product_ipo_app a
    where a.account_id not in (select account_id from product_ipo_app b where b.ipo_id = a.ipo_id and b.app_posted = 'Y');

UPDATE product_ipo_app a
INNER JOIN product_ipo_announcement b ON a.ipo_id=b.ipo_id
INNER JOIN capital_account c ON a.account_id = c.account_id
SET
    a.account_type = c.account_type,
    a.list_market_id = b.list_market_id,
    a.product_id = b.product_id,
    a.currency = b.currency
WHERE a.ipo_id IN (SELECT DISTINCT ipo_id FROM tmp_product_ipo_app) and a.app_posted<>'Y';

UPDATE product_ipo_app a
INNER JOIN product_ipo_announcement b ON a.ipo_id=b.ipo_id
SET
    
    a.loan_amount = if(a.sub_status=1,ROUND(a.amount*a.loan_ratio/100,2),0),
    a.interest_rate = IFNULL(a.interest_rate, b.interest_rate) 
WHERE a.ipo_id IN (SELECT DISTINCT ipo_id FROM tmp_product_ipo_app) and a.app_posted<>'Y' ;

UPDATE product_ipo_app a
INNER JOIN product_ipo_announcement b ON a.ipo_id=b.ipo_id
SET
    
    
    
    a.interest = if(a.sub_status=1,ROUND(a.loan_amount*a.interest_rate/100/365*b.interest_day,2),0),
    a.charge = if(a.sub_status = 1,ROUND(b.charge_rate/100*a.amount+b.charge,2),0),
    
    a.loan_charge = case when a.loan_charge is null then IF(a.loan_amount<>0, ROUND(b.loan_charge_rate/100*a.loan_amount+b.loan_charge,2), 0) else a.loan_charge end
WHERE a.ipo_id IN (SELECT DISTINCT ipo_id FROM tmp_product_ipo_app) and a.app_posted<>'Y';

COMMIT;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proImportProductIpoQty
-- ----------------------------
DROP PROCEDURE IF EXISTS `proImportProductIpoQty`;
delimiter ;;
CREATE PROCEDURE `proImportProductIpoQty`(OUT o_ret_code int,
    OUT o_ret_msg varchar(256))
label: BEGIN
DECLARE v_ipo_id_cnt INT DEFAULT 0;

START TRANSACTION;

SET o_ret_code = 0, o_ret_msg = "Success";

IF EXISTS(SELECT 1 FROM tmp_product_ipo_qty WHERE ipo_id IS NULL) THEN
    
    SET o_ret_code = 1, o_ret_msg = "ipo_id exist_null";
    LEAVE label;
END IF;

IF EXISTS(SELECT 1 FROM tmp_product_ipo_qty WHERE ipo_id NOT IN (SELECT DISTINCT ipo_id FROM product_ipo_announcement) ) THEN
    SET o_ret_code = 1, o_ret_msg = "ipo_id not_exist in base table";
    LEAVE label;
END IF;
DELETE FROM product_ipo_qty WHERE ipo_id IN (SELECT DISTINCT ipo_id FROM tmp_product_ipo_qty);

INSERT INTO product_ipo_qty(ipo_id,qty,currency,amount,update_user,update_time) SELECT ipo_id,qty,currency,amount,update_user,update_time FROM tmp_product_ipo_qty;

COMMIT;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proImportTradeToTmpTable
-- ----------------------------
DROP PROCEDURE IF EXISTS `proImportTradeToTmpTable`;
delimiter ;;
CREATE PROCEDURE `proImportTradeToTmpTable`(IN  i_market_id int,
	IN  i_product_type int,
    OUT o_ret_code int,
    OUT o_ret_msg char(128))
label:begin

    truncate table tmp_account_trade_detail;

	start transaction;

    insert into tmp_account_trade_detail
    select id,
	trade_id,
	trade_exec_id,
	process_date,
	order_no,
	order_date,
	order_time,
	business_department,
	department_trading_group,
	account_id,
	account_type,
	trade_date,
	settle_date,
	market_id,
	list_market_id,
	product_type,
	product_sub_type,
	product_id,
	product_description,
	quote_currency,
	clearing_currency,
	exchange_rate,
	buy_sell,
	order_price,
	order_quantity,
	trade_quantity,
	status,
	open_close,
	hedge_flag,
	call_put,
	strike_price,
	contract_date,
	input_channel,
	remark,
	exec_time,
	exec_no,
	exchange_ref_no,
	exec_broker,
	contra_broker,
	exec_quantity,
	exec_price,
	code,
	mark,
	num_of_trades,
	trade_amount,
	net_amount,
    custodian_code,
    custodian_account,
    broker,
	is_odd_lot
	from import_account_trade_detail where (i_market_id = '' or i_market_id = market_id) and (i_product_type = '' or product_type = i_product_type) and ConfirmStatus = 'Pending';

    -- update import_account_trade_detail 
    --     set ConfirmStatus = "Confirmed"
    -- where ConfirmStatus = 'Pending' and (i_market_id = '' or i_market_id = market_id) and (i_product_type = '' or product_type = i_product_type);

    set o_ret_code = 0; 
    set o_ret_msg = '导入tmp_account_trade_detail完成';

    commit;
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proInitBalance
-- ----------------------------
DROP PROCEDURE IF EXISTS `proInitBalance`;
delimiter ;;
CREATE PROCEDURE `proInitBalance`(IN i_buss_date date,
    IN i_last_buss_date date,
    OUT o_ret_code INT , 
    OUt o_ret_msg VARCHAR(64))
label: BEGIN
    set o_ret_code = 0; 
    set o_ret_msg = 'Success';
    start transaction; 

    
    delete from account_balance where process_date = i_buss_date; 

    
    INSERT
    INTO account_balance
    (
    process_date,
    account_id,
    account_type,
    currency,
    trade_balance,
    settle_balance,
    balance_avail,
    balance_extract,
    market_value,
    long_market_value,
    short_market_value,
    equity,
    frozen_amount,
    uncleared_amount,
    unsettled_amount,
    portfolio_fee,       
    accrued_interest,
    accrued_interest_credit, 
    ipo_frozen_before_close,
    ipo_frozen_before_allot,
    debit_interest_rate, 
    credit_interest_rate
    )
    SELECT
    i_buss_date,
    a.account_id,
    a.account_type,
    b.currency,
    b.trade_balance,   
    b.settle_balance,  
    b.balance_avail,   
    b.balance_extract, 
    0,  
    0,  
    0,  
    0,  
    b.frozen_amount,  
    b.uncleared_amount,  
    0, 
    b.portfolio_fee,    
    b.accrued_interest, 
    b.accrued_interest_credit, 
    0, 
    0,  
    0, 
    0  
    from account_balance b 
    inner join capital_account a on a.account_id = b.account_id
    where b.process_date = i_last_buss_date ; 


    
    
    
    
    
    
    

  commit; 
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proInitFutureOpenPostion
-- ----------------------------
DROP PROCEDURE IF EXISTS `proInitFutureOpenPostion`;
delimiter ;;
CREATE PROCEDURE `proInitFutureOpenPostion`(IN i_buss_date date,
    IN i_last_buss_date date,
    OUT o_ret_code INT , 
    OUt o_ret_msg VARCHAR(64))
label: BEGIN
    set o_ret_code = 0; 
    set o_ret_msg = 'Success';
    start transaction; 

    
    delete from future_open_position where process_date = i_buss_date; 
    insert into future_open_position
    (
        trade_id,
        process_date,
        trade_date,
        settle_date,
        order_no,
        exec_no,
        account_id,
        account_type,
        market_id,
        product_class,
        product_id,
        buy_sell,
        currency,
        price,
        settle_price,
        quantity,
        unclosed_qty,
        profit_loss,
        margin_amt,
        closed,
        update_time,
        update_user
    )
    select 
        trade_id,
        i_buss_date,
        trade_date,
        settle_date,
        order_no,
        exec_no,
        account_id,
        account_type,
        market_id,
        product_class,
        product_id,
        buy_sell,
        currency,
        price,
        settle_price,
        quantity,
        unclosed_qty,
        profit_loss,
        margin_amt,
        closed,
        update_time,
        update_user
    from future_open_position
    where process_date = i_last_buss_date and 
        closed = 'N';

  commit; 
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proInitProductMarketData
-- ----------------------------
DROP PROCEDURE IF EXISTS `proInitProductMarketData`;
delimiter ;;
CREATE PROCEDURE `proInitProductMarketData`(IN i_market_id int,
    IN i_trade_date date,
    IN i_last_trade_date date,
    OUT o_ret_code INT , 
    OUt o_ret_msg VARCHAR(64))
label: BEGIN
    DECLARE v_buss_date date default NULL ; 
    set o_ret_code = 0; 
    set o_ret_msg = 'Success';
    start transaction; 
    
    select buss_date into v_buss_date from sys_info;

    
    delete from product_market_data where trade_date = i_trade_date and list_market_id = i_market_id; 

    
    INSERT
    INTO product_market_data
    (
    trade_date,
    list_market_id,
    product_class,
    product_type,
    product_id,
    product_description,
    closing_price,
    last_closing_price,
    settle_price,
    last_settle_price,
    openning_price,
    latest_price,
    status,
    update_user,
    update_time,
    process_date
    )
    SELECT
    i_trade_date,
    a.list_market_id,
    a.product_class,
    a.product_type,
    a.product_id,
    a.product_description,
    0, 
    a.closing_price	, 
    0, 
    a.settle_price	, 
    0, 
    a.openning_price, 
    a.status	, 
    "system", 
    now(),
    v_buss_date
    FROM product_market_data a
    where a.trade_date = i_last_trade_date and a.list_market_id = i_market_id; 

  commit; 
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proInitRegistCorpAction
-- ----------------------------
DROP PROCEDURE IF EXISTS `proInitRegistCorpAction`;
delimiter ;;
CREATE PROCEDURE `proInitRegistCorpAction`(IN  i_update_user varchar(32), 
  IN  i_update_time datetime,
  OUT o_ret_code int, 
  OUT o_ret_msg varchar(64))
label:begin
    
    declare v_event_id varchar(128) default NULL;
    declare v_account_id varchar(16) default NULL;
    declare v_process_date date default NULL;  
    declare v_done int default 0; 

    DECLARE cur_event CURSOR FOR
    SELECT
      a.event_id
    FROM
      corp_action a
    where a.book_closed <> 'Y' and a.register_date not in ('00000000','00010101', '99991231') and a.register_date <= v_process_date;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1; 

    set o_ret_code = 0, o_ret_msg ="Success";
    start transaction;      

    select buss_date into v_process_date from sys_info; 

    
    if v_process_date is NULL then 
        set o_ret_code = 1, o_ret_msg = "Bussness date not setting up"; 
        rollback; 
        leave label; 
    end if;

    OPEN cur_event;
        SET v_done = 0;
        FETCH cur_event INTO v_event_id;
        WHILE v_done <> 1 DO
            call proRegistCorpAction(
                v_event_id,
                '',
                '',
                i_update_user,
                i_update_time,
                o_ret_code,
                o_ret_msg
            );
            SET v_done = 0;
            FETCH cur_event INTO v_event_id;
        END WHILE;
    CLOSE cur_event;

    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proInsertAuditTrail
-- ----------------------------
DROP PROCEDURE IF EXISTS `proInsertAuditTrail`;
delimiter ;;
CREATE PROCEDURE `proInsertAuditTrail`(IN i_process_date DATE, 
    IN i_action VARCHAR(16), 
    IN i_control_id VARCHAR(32), 
    IN i_control_key_value VARCHAR(128), 
    IN i_table_id VARCHAR(64),
    IN i_table_key_value VARCHAR(128), 
    IN i_column_name VARCHAR(64),
    IN i_old_value VARCHAR(512),
    IN i_new_value VARCHAR(512),
    IN i_update_user VARCHAR(32),
    IN i_update_time DATETIME, 
    IN i_record_id VARCHAR(512))
label:BEGIN
IF i_process_date IS NULL THEN
    SELECT buss_date INTO i_process_date FROM jcbms.sys_info LIMIT 1;
END IF;
IF i_update_time IS NULL THEN
    SET i_update_time = NOW();
END IF;
INSERT INTO jcbms.audit_trail(process_date,action,control_id,control_key_value,
                                table_id,table_key_value,column_name,old_value,new_value,
                                update_user,update_time,record_id,status)
            VALUES(i_process_date,i_action,i_control_id,i_control_key_value,
                    i_table_id,i_table_key_value,i_column_name,i_old_value,i_new_value,
                    i_update_user,i_update_time,NULL,NULL);
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proInsertFutureMargin
-- ----------------------------
DROP PROCEDURE IF EXISTS `proInsertFutureMargin`;
delimiter ;;
CREATE PROCEDURE `proInsertFutureMargin`(level int, 
    market_id  int,
    product_class varchar(32),
    product_id varchar(32),
    exchange_initial_margin decimal(30,10),
    exchange_maint_margin decimal(30,10),
    exchange_initial_rate decimal(30,10),
    exchange_maint_rate decimal(30,10),
    company_initial_margin decimal(30,10),
    company_maint_margin decimal(30,10),
    company_initial_rate decimal(30,10),
    company_maint_rate decimal(30,10),
    floating_model int,  
    update_user varchar(64), 
    update_time datetime)
label:begin
   declare v_trade_date date default NULL; 
   select t0 into v_trade_date from market t where t.market_id = market_id; 
   if level = 1 then 
        if EXISTS(select 1 from product_class_future_margin t where t.trade_date = trade_date and t.market_id = market_id and t.product_class = product_class) then
            select 1 as ret_code,"market+product_class alread exists" as ret_msg; 
            leave label; 
        end if; 
        insert into product_class_future_margin
        (
            trade_date,
            product_class,
            market_id, 
            exchange_initial_margin, 
            exchange_maint_margin, 
            exchange_initial_rate, 
            exchange_maint_rate, 
            company_initial_margin, 
            company_maint_margin, 
            company_initial_rate, 
            company_maint_rate, 
            floating_model, 
            update_user, 
            update_time
        )
        select  
            v_trade_date,
            product_class,
            market_id, 
            exchange_initial_margin, 
            exchange_maint_margin, 
            exchange_initial_rate, 
            exchange_maint_rate, 
            company_initial_margin, 
            company_maint_margin, 
            company_initial_rate, 
            company_maint_rate, 
            floating_model, 
            update_user, 
            update_time; 

   elseif level = 2 then 
         if EXISTS(select 1 from product_future_margin t where t.trade_date = trade_date and t.market_id = market_id and t.product_id = product_id) then 
            select 1 as ret_code,"market+product alread exists" as ret_msg; 
            leave label; 
         end if; 
        insert into product_future_margin
        (
            trade_date,
            product_class,
            market_id, 
            product_id,
            exchange_initial_margin, 
            exchange_maint_margin, 
            exchange_initial_rate, 
            exchange_maint_rate, 
            company_initial_margin, 
            company_maint_margin, 
            company_initial_rate, 
            company_maint_rate, 
            floating_model, 
            update_user, 
            update_time
        )
        select  
            v_trade_date,
            product_class,
            market_id, 
            product_id,
            exchange_initial_margin, 
            exchange_maint_margin, 
            exchange_initial_rate, 
            exchange_maint_rate, 
            company_initial_margin, 
            company_maint_margin, 
            company_initial_rate, 
            company_maint_rate, 
            floating_model, 
            update_user, 
            update_time; 
   else
        select 1 as ret_code, "unkown level" as ret_msg; 
   end if; 
   select 0 as ret_code, "Success" as ret_msg; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proInsertImportAccountTradeDetail
-- ----------------------------
DROP PROCEDURE IF EXISTS `proInsertImportAccountTradeDetail`;
delimiter ;;
CREATE PROCEDURE `proInsertImportAccountTradeDetail`(OUT o_ret_code int,
    OUT o_ret_msg char(128))
label:begin

    declare v_process_date date default null;
    
    truncate table CheckWarnings;

    insert into tmp_import_account_trade_detail
    select 
	a.trade_id, a.trade_exec_id, a.process_date, a.order_no, a.order_date, a.order_time, 
    a.business_department, a.department_trading_group, 
    b.account_id, b.account_type, a.trade_date, 
    a.settle_date, a.market_id, a.list_market_id, a.product_type, a.product_sub_type, 
    a.product_id, a.product_description, a.quote_currency, a.clearing_currency, a.exchange_rate, 
    case when a.buy_sell = 1 then 2 else 1 end as buy_sell, 
    a.order_price, a.order_quantity, a.trade_quantity, a.status, a.open_close, a.hedge_flag, 
    a.call_put, a.strike_price, a.contract_date, a.input_channel, a.remark, a.exec_time, a.exec_no, 
    a.exchange_ref_no, a.exec_broker, a.contra_broker, a.exec_quantity, a.exec_price, a.code, a.mark, 
    a.num_of_trades, a.trade_amount, a.net_amount, a.update_time, a.update_user, a.ConfirmStatus, a.broker, 
    a.custodian_code, a.custodian_account, a.is_odd_lot
	from tmp_import_account_trade_detail a 
	inner join capital_account b on b.account_id = '11111113' 
	where broker = 'VELOX_ODD' and is_odd_lot = 'Y';


    
    update tmp_import_account_trade_detail 
    set ConfirmStatus = 'Pending' 
	where ifnull(ConfirmStatus,'') <> 'Canceled' and ifnull(ConfirmStatus,'') <> 'Confirmed';

    update tmp_import_account_trade_detail set code = 1, mark = '账号不存在';

    select buss_date into v_process_date from sys_info; 

    update tmp_import_account_trade_detail 
    set code = 0, mark = '账号存在'
    where account_id in (select account_id from capital_account);

    insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 
        1,
        'account_trade_detail',
        0,
        '',
        account_id,
        '账户不存在',
        'JC_clearing',
        now()
    from tmp_import_account_trade_detail
    where code = 1;

    if EXISTS (select 1 from tmp_import_account_trade_detail where code = 1) then 
        set o_ret_code = 1; 
        set o_ret_msg = '成交明细校验未完成';
        leave label;
    end if;


    update tmp_import_account_trade_detail set code = 2, mark = '产品不存在';
    update tmp_import_account_trade_detail 
    set code = 0, mark = '产品存在'
    where  (list_market_id, product_id) in (select list_market_id, product_id  from product);

    insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 
        1,
        'account_trade_detail',
        list_market_id,
        product_id,
        '',
        '产品代码不存在',
        'JC_clearing',
        now()
    from tmp_import_account_trade_detail
    where code = 2;

    if EXISTS (select 1 from tmp_import_account_trade_detail where code = 2) then 
        set o_ret_code = 1; 
        set o_ret_msg = '成交明细校验未完成';
        leave label;
    end if;

    start transaction;
    
    update tmp_import_account_trade_detail a 
    inner join capital_account b on a.account_id = b.account_id 
    set a.account_type = b.account_type;
      
    update tmp_import_account_trade_detail a, product b
    set a.product_type = b.product_type,
        a.product_sub_type = b.product_sub_type,
        a.product_description = b.product_description,
        a.quote_currency = b.quote_currency,
        a.clearing_currency = b.currency,
        a.trade_amount = (a.exec_price*a.exec_quantity*b.price_factor),
        a.net_amount = a.exec_price*a.exec_quantity*b.price_factor
	where   a.list_market_id = b.list_market_id and 
			a.product_id = b.product_id; 
    
    

    update tmp_import_account_trade_detail a  
    left join currency b on a.clearing_currency = b.currency
    set a.exchange_rate = b.exchange_rate; 

    
    update tmp_import_account_trade_detail a
    inner join  market b on a.list_market_id = b.market_id
    set trade_date = case when trade_date is null  or trade_date = '00000000' then 
        (case when v_process_date >b.t0 and v_process_date < b.t1 and a.input_channel <>'5' then b.t0 
        when v_process_date>=b.t0 then t0  else  '00000000' end) else trade_date end;

    
    
    update tmp_import_account_trade_detail a
    inner join calendar b on a.list_market_id = b.market_id and a.trade_date = b.calendar_day and b.holiday = 'H' 
    set a.trade_date = (select max(calendar_day) from calendar t where t.market_id = a.list_market_id and t.calendar_day<b.calendar_day and t.holiday = 'N');

    
    delete from CheckWarnings; 
    insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 
        1,
        'account_trade_detail',
        list_market_id,
        product_id,
        account_id,
        '非法交易日',
        'JC_clearing',
        now()
    from tmp_import_account_trade_detail
    where trade_date = '00000000'; 
    

    if  EXISTS (select 1 from CheckWarnings ) then 
        set o_ret_code = 1; 
        set o_ret_msg = '成交明细校验未完成[非法交易日]';
        leave label;
    end if;


    
    update tmp_import_account_trade_detail a
    left join market b on a.market_id = b.market_id 
    set a.settle_date = funIntervalSettleDay(a.market_id,a.trade_date, b.market_settle_days);

    
    update tmp_import_account_trade_detail a, sys_info b
    set a.process_date = b.buss_date,
        a.num_of_trades = 1; 
    
    
    update tmp_import_account_trade_detail a
    inner join market b on a.market_id = b.market_id
	set 
        a.broker = b.broker,
        a.custodian_code = b.custodian_code,
		a.custodian_account = b.custodian_account
    where ifnull(a.broker,'') = '' or ifnull(a.broker,'') = '0';

    update tmp_import_account_trade_detail a
    inner join broker_market b on a.market_id = b.market_id and a.broker = b.broker
	set a.custodian_code = b.custodian_code,
		 a.custodian_account = b.custodian_account;

    update tmp_import_account_trade_detail a
    inner join account_type_custodian b on a.market_id = b.market_id and a.account_type = b.account_type
	set a.custodian_code = b.custodian_code,
		 a.custodian_account = b.custodian_account; 

    set o_ret_code = 0; 
    set o_ret_msg = '校验完成';

    insert into import_account_trade_detail 
    select NULL,a.*
    from tmp_import_account_trade_detail a;


    commit;
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proInsertInstrumentInfo
-- ----------------------------
DROP PROCEDURE IF EXISTS `proInsertInstrumentInfo`;
delimiter ;;
CREATE PROCEDURE `proInsertInstrumentInfo`(trade_date date, 
    list_market_id int ,
    product_id varchar(32),
    product_description VARCHAR(255), 
    product_class varchar(32), 
    product_type int, 
    settle_datec varchar(16), 
    listing_datec varchar(16), 
    last_trading_datec varchar(16), 
    price_factor decimal(30,10),
    contract_size decimal(30,10),
    quote_currency int , 
    currency int , 
    settle_price decimal(30,10),
    closing_price decimal(30,10),
    update_user varchar(64))
label:begin
    declare settle_date date default NULL; 
    declare listing_date date default  NULL; 
    declare last_trading_date date default NULL; 

    if(length(settle_datec) = 8) then 
        set settle_date = date_format(settle_datec,'%Y%m%d');
    end if; 

    if(length(settle_datec) = 8) then 
        set listing_date = date_format(listing_datec,'%Y%m%d');
    end if; 

    if(length(settle_datec) = 8) then 
        set last_trading_date = date_format(last_trading_datec,'%Y%m%d');
    end if;     

    if EXISTS(select 1 from product t where t.list_market_id = list_market_id and t.product_id = product_id) then 
        insert into product 
        (
            
            list_market_id,
            product_id,
            product_description, 
            product_class, 
            product_type, 
            settle_date, 
            listing_date, 
            last_trading_date, 
            price_factor,
            contract_size,
            quote_currency, 
            currency, 
            
            
            update_user,
            update_time
        )
        select 
            
            list_market_id,
            product_id,
            product_description, 
            product_class, 
            product_type, 
            settle_date, 
            listing_date, 
            last_trading_date, 
            price_factor,
            contract_size,
            quote_currency, 
            currency, 
            
            
            update_user,
            now(); 
    else 
        update product t
            set 
            
            t.list_market_id = list_market_id,
            t.product_id = product_id,
            t.product_description = product_description , 
            t.product_class = product_class , 
            t.product_type = product_type , 
            t.settle_date = settle_date , 
            t.listing_date = listing_date , 
            t.last_trading_date = last_trading_date, 
            t.price_factor = price_factor,
            t.contract_size = contract_size ,
            t.quote_currency = quote_currency , 
            t.currency = currency, 
           
           
            t.update_user =update_user,
            t.update_time = now();
    end if; 

    if EXISTS(select 1 from product_market_data t where t.trade_date = trade_date and t.list_market_id = list_market_id and t.product_id = product_id) then 
        insert into product_market_data 
        (
            trade_date, 
            list_market_id,
            product_id,
            product_description, 
            product_class, 
            product_type, 
            settle_price,
            closing_price,
            update_user,
            update_time
        )
        select 
            trade_date, 
            list_market_id,
            product_id,
            product_description, 
            product_class, 
            product_type, 
            settle_price,
            closing_price,
            update_user,
            now();
    else 
        update product_market_data t
            set 
            t.trade_date = trade_date, 
            t.list_market_id = list_market_id,
            t.product_id = product_id,
            t.product_description = product_description, 
            t.product_class = product_class, 
            t.product_type = product_type, 
            t.settle_price = settle_price,
            t.closing_price = closing_price ,
            t.update_user = update_user,
            t.update_time = now();
    end if; 

    select '0' as ret_code, 'Success' as ret_msg; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proInsertProductIpoApp
-- ----------------------------
DROP PROCEDURE IF EXISTS `proInsertProductIpoApp`;
delimiter ;;
CREATE PROCEDURE `proInsertProductIpoApp`(OUT o_ret_code int,
    OUT o_ret_msg varchar(256))
label: BEGIN
    DECLARE v_ipo_id_cnt INT DEFAULT 0;
    DECLARE v_sub_status varchar(1);
    DECLARE v_ipo_id varchar(64);
    DECLARE v_account_id varchar(16);

    START TRANSACTION;

    SET o_ret_code = 0, o_ret_msg = "Success";

    select ipo_id,account_id,sub_status into v_ipo_id,v_account_id,v_sub_status from tmp_product_ipo_app;

    IF EXISTS(SELECT 1 FROM tmp_product_ipo_app WHERE ipo_id IS NULL) THEN
        SET o_ret_code = 1, o_ret_msg = "ipo_id exist_null";
        LEAVE label;
    END IF;

    IF EXISTS(SELECT 1 FROM tmp_product_ipo_app WHERE account_id NOT IN (SELECT DISTINCT account_id FROM capital_account) ) THEN
        SET o_ret_code = 1, o_ret_msg = "account_id not_exist in capital_account";
        LEAVE label;
    END IF;

    IF EXISTS(SELECT 1 FROM tmp_product_ipo_app WHERE ipo_id NOT IN (SELECT DISTINCT ipo_id FROM product_ipo_announcement where ipo_id = v_ipo_id) ) THEN
        SET o_ret_code = 1, o_ret_msg = "ipo_id not_exist in base table";
        LEAVE label;
    END IF;

    if v_sub_status = 1 THEN
        IF EXISTS(
            SELECT 1 FROM tmp_product_ipo_app a 
                WHERE (SELECT COUNT(1) FROM product_ipo_qty b WHERE b.ipo_id = a.ipo_id AND b.qty = a.quantity AND b.amount = a.amount ) = 0
            )THEN
            set o_ret_code = 1, o_ret_msg = concat('invalid quantity amount exists:',v_account_id);
            ROLLBACK;
            LEAVE label;
        END IF;
    end if;    

    if EXISTS(select 1 from product_ipo_app a inner join tmp_product_ipo_app b on a.ipo_id = b.ipo_id and a.account_id = b.account_id) then 
        update product_ipo_app a 
        inner join tmp_product_ipo_app b on a.ipo_id = b.ipo_id and a.account_id = b.account_id 
        set a.sub_status = b.sub_status,
            a.quantity = b.quantity,
            a.amount = b.amount,
            a.loan_ratio = b.loan_ratio,
            a.interest_rate = b.interest_rate;
    else
        replace INTO product_ipo_app(ipo_id, account_id, account_type, list_market_id, product_id, quantity, amount, currency, loan_ratio, loan_amount, interest_rate, interest,loan_charge, allot_qty, allot_price, refund_amount, remark, created_time, update_time, update_user,sub_status)
                            SELECT ipo_id, account_id, account_type, list_market_id, product_id, quantity, amount, currency, loan_ratio, loan_amount, interest_rate, interest,loan_charge, allot_qty, allot_price, refund_amount, remark, created_time, update_time, update_user,sub_status FROM tmp_product_ipo_app;
    end if;

    UPDATE product_ipo_app a
    INNER JOIN product_ipo_announcement b ON a.ipo_id=b.ipo_id
    INNER JOIN capital_account c ON a.account_id = c.account_id
    INNER JOIN tmp_product_ipo_app d on a.account_id = d.account_id
    SET
        a.account_type = c.account_type,
        a.list_market_id = b.list_market_id,
        a.product_id = b.product_id,
        a.currency = b.currency
    WHERE a.ipo_id IN (SELECT DISTINCT ipo_id FROM tmp_product_ipo_app);

    UPDATE product_ipo_app a
    INNER JOIN product_ipo_announcement b ON a.ipo_id=b.ipo_id
    INNER JOIN tmp_product_ipo_app d on a.account_id = d.account_id
    SET
        a.loan_amount = if(a.sub_status = 1,ROUND(a.amount*a.loan_ratio/100,2),0),
        a.interest_rate = IFNULL(a.interest_rate, b.interest_rate) -- 允许客户级别的利息率,可能为0,如果为NULL则取公告级别的数据.
    WHERE a.ipo_id IN (SELECT DISTINCT ipo_id FROM tmp_product_ipo_app);-- 不这样写会有BUG.

    UPDATE product_ipo_app a
    INNER JOIN product_ipo_announcement b ON a.ipo_id=b.ipo_id
    INNER JOIN tmp_product_ipo_app d on a.account_id = d.account_id
    SET
        a.interest = ROUND(a.loan_amount*a.interest_rate/100/365*b.interest_day,2),
        a.charge = d.charge,
        a.loan_charge = d.loan_charge
    WHERE a.ipo_id IN (SELECT DISTINCT ipo_id FROM tmp_product_ipo_app);

COMMIT;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proIPOVirtualPosition
-- ----------------------------
DROP PROCEDURE IF EXISTS `proIPOVirtualPosition`;
delimiter ;;
CREATE PROCEDURE `proIPOVirtualPosition`(OUT o_ret_code int,
    OUT o_ret_msg varchar(256))
label: BEGIN
DECLARE v_done int DEFAULT 0;
DECLARE v_account_id char(16);
DECLARE v_account_type int;
DECLARE v_list_market_id int;
DECLARE v_product_id varchar(16);
DECLARE v_currency int;
DECLARE v_amount decimal(30,10);
DECLARE v_loan_amount decimal(30,10);
DECLARE v_interest decimal(30,10);
DECLARE v_allot_qty INT;
DECLARE v_allot_price decimal(30,10);
DECLARE v_refund_amount decimal(30,10);
DECLARE v_process_date date;
DECLARE v_qty BIGINT DEFAULT 0;
DECLARE v_px  DECIMAL(30,3) DEFAULT 0;
DECLARE v_charge decimal(30,10);
DECLARE v_loan_charge decimal(30,10);

DECLARE cur_req CURSOR FOR
    SELECT 
    a.list_market_id as market_id, 
    a.product_id as product_id, 
    a.account_id,
    a.account_type,
    a.currency, 
    a.amount,
    a.loan_amount,
    a.interest,
    a.quantity, 
    a.charge, 
    a.loan_charge
    from 
    product_ipo_announcement b
    inner join product_ipo_app a on a.ipo_id = b.ipo_id
    where ifnull(b.app_posted,'N') = 'Y' and (ifnull(b.result_posted,'N')<> 'Y' or ifnull(b.refund_posted,'N') <>'Y');



DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1;

START TRANSACTION;

SET o_ret_code = 0, o_ret_msg = "Success";


SELECT buss_date INTO v_process_date FROM sys_info;


OPEN cur_req;
temp_loop: LOOP
    FETCH cur_req INTO  v_list_market_id, v_product_id, v_account_id, v_account_type, v_currency, v_amount,v_loan_amount, v_interest, v_allot_qty,v_charge,v_loan_charge; 

    IF v_done <> 0 THEN
        LEAVE temp_loop;
    END IF;

    
    call proProductIn(v_account_id,v_account_type,v_list_market_id,v_product_id,0,'','',0,0,NULL,CONCAT("Prepare IPO @",v_px),'Max',now(),o_ret_code,o_ret_msg);
    IF o_ret_code <> 0 THEN
        ROLLBACK;
        LEAVE label;
    END IF;
    
    
    update account_position a  
    set a.position_cost = a.position_cost + v_amount - v_loan_amount + v_charge - v_loan_charge
    where process_date = v_process_date and
          market_id = v_list_market_id and 
          product_id  = v_product_id and 
          account_id = v_account_id and 
          account_type = v_account_type; 
END LOOP;

COMMIT;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proLoadPlacingResultFile
-- ----------------------------
DROP PROCEDURE IF EXISTS `proLoadPlacingResultFile`;
delimiter ;;
CREATE PROCEDURE `proLoadPlacingResultFile`(OUT o_ret_code int,
    OUT o_ret_msg varchar(256))
label: BEGIN
    DECLARE v_ipo_id_cnt INT DEFAULT 0;

    START TRANSACTION;

    SET o_ret_code = 0, o_ret_msg = "Success";

    IF EXISTS(SELECT 1 FROM tmp_load_result_file WHERE account_id NOT IN (SELECT DISTINCT account_id FROM capital_account) ) THEN
        SET o_ret_code = 1, o_ret_msg = "account_id not_exist in capital_account";
        LEAVE label;
    END IF;

    update product_ipo_app a
	inner join tmp_load_result_file b on a.ipo_id = b.ipo_id and a.account_id = b.account_id
    inner join product_ipo_announcement c on c.ipo_id = a.ipo_id
    set 
        a.amount = b.amount,
        a.allot_qty = b.quantity,
        a.allot_price = b.price,
        a.result_posted = 'Y',
        a.result_posted_time = now()
    where ifnull(a.refund_posted,'') <> 'Y';

    update product_ipo_announcement
    set result_posted = 'Y',
        result_posted_time = now()
    where ipo_id in (select distinct ipo_id from tmp_load_result_file order by ipo_id);

    COMMIT;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proLogOn
-- ----------------------------
DROP PROCEDURE IF EXISTS `proLogOn`;
delimiter ;;
CREATE PROCEDURE `proLogOn`(IN i_user char(40),
    IN i_passwd char(40))
label:begin


    if  exists (select 1 from user where user_id = i_user and user_pwd = i_passwd) then
        set @o_ret_code = 0;
    elseif exists (select 1 from user where user_id = i_user)  then
        set @o_ret_code = 1;
        set @o_ret_msg = 'passwd not correct';
    elseif  exists (select 1 from user where user_pwd = i_passwd) then
        set @o_ret_code = 2;
        set @o_ret_msg = 'user not correct';
    else
        set @o_ret_code = 3;
        set @o_ret_msg = 'user not correct, passwd not correct';
    end if;

    select @o_ret_code, @o_ret_msg;
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proMarketCharge
-- ----------------------------
DROP PROCEDURE IF EXISTS `proMarketCharge`;
delimiter ;;
CREATE PROCEDURE `proMarketCharge`(OUT o_ret_code int, OUT o_ret_msg char(128))
label: BEGIN
  DECLARE t_PT char(16);
  DECLARE t_PST char(16);
  DECLARE v_done int DEFAULT 0;
  DECLARE v_process_date date;
  DECLARE t_trade_id char(32);
  DECLARE v_trade_id char(32);
  DECLARE v_product_id varchar(32);
  DECLARE v_account_id char(16);
  DECLARE v_accrued_interest decimal(21,6);
  DECLARE t_settle_date date;
  DECLARE v_formula_id1 char(255);
  DECLARE v_formula_id2 char(255);
  DECLARE v_formula_value char(255);
  DECLARE v_formula_value2 char(255);
  DECLARE v_sum_flag int DEFAULT 0;
  DECLARE v_ae_sum_flag int DEFAULT 0;
  DECLARE v_done1 int DEFAULT 0;
  DECLARE v_done2 int DEFAULT 0;
  DECLARE v_id bigint;
  DECLARE v_currency char(3);
  DECLARE v_trade_date date;
  DECLARE v_settle_date date;
  DECLARE v_ae_id char(16) DEFAULT '';
  DECLARE t1 datetime(6);
  DECLARE t2 datetime(6);
  DECLARE t3 datetime(6);
  DECLARE t4 datetime(6);
  DECLARE t5 datetime(6);
  DECLARE t6 datetime;
  DECLARE cur_charge CURSOR FOR
    SELECT
      a.id, IFNULL(b.formula_value, 0), a.sum_flag, a.external_id
    FROM
      tmp_account_charge a
        LEFT JOIN formula b ON a.formula_type = b.formula_type AND a.formula_code = b.formula_code
    ORDER BY a.id;
  DECLARE CONTINUE HANDLER FOR NOT FOUND
    SET
      v_done = 1,
      v_done1 = 1,
      v_done2 = 1;

    drop temporary table IF EXISTS tmp_account_charge;
    CREATE temporary TABLE `tmp_account_charge` (
        `id` bigint(11) NOT NULL AUTO_INCREMENT,
        `process_date` date DEFAULT NULL,
        `trade_date` date DEFAULT NULL,
        `settle_date` date DEFAULT NULL,
        `account_id` varchar(16) DEFAULT NULL,
        `account_type` int(11) DEFAULT '-1',
        `market_id` int(11) DEFAULT NULL,
        `product_id` varchar(32) DEFAULT NULL,
        `currency` int(11) DEFAULT NULL,
        `external_id` varchar(32) DEFAULT NULL,
        `external_id2` varchar(32) DEFAULT NULL,
        `charge_code` varchar(36) DEFAULT NULL,
        `formula_code` varchar(32) DEFAULT NULL,
        `formula_type` varchar(8) DEFAULT NULL,
        `charges` decimal(30,10) DEFAULT '0.0000000000',
        `accrued_charges` decimal(30,10) DEFAULT 0,
        `sum_flag` int(11) DEFAULT '0',
        `broker` varchar(16) DEFAULT NULL,
        waive varchar(1),
        product_type int,
        PRIMARY KEY (`id`),
        index idx1(waive),
        index idx2(formula_type),
        index idx3(market_id, product_type, formula_type, charge_code),
        index idx4(account_id,market_id),
        index idx5(market_id),
        index idx6(formula_type,account_id,market_id),
        index idx7(market_id,product_id)
    ) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;



  SELECT buss_date INTO v_process_date FROM sys_info;
  
  
  INSERT
    INTO tmp_account_charge
    (market_id, account_id, account_type, product_id, currency, process_date, trade_date, settle_date, external_id, 
    charge_code, formula_type, formula_code, charges, sum_flag,waive,broker,product_type)
    SELECT
      a.market_id,
      a.account_id,
      a.account_type,
      a.product_id,
      CASE b.currency WHEN 0 THEN a.clearing_currency ELSE b.currency END,
      a.process_date,
      a.trade_date,
      a.settle_date,
      a.trade_id,
      b.charge_code,
      -- CASE WHEN waive = 'Y' THEN '0' ELSE b.formula_type END,
      -- CASE WHEN waive = 'Y' THEN '0' ELSE b.formula_code END,
      b.formula_type, 
      b.formula_code,
      0,
      b.sum_flag,
      b.waive,
      a.broker,
      a.product_type
    FROM
      tmp_account_trade a
        INNER JOIN market_charge_rule b ON a.list_market_id = b.market_id AND (b.formula_type = 'CHRG' OR b.formula_type = 'COMM') AND b.sum_flag = 1 
    WHERE
      a.process_date = v_process_date;
  
  INSERT
    INTO tmp_account_charge
    (market_id, account_id, account_type, product_id, currency, process_date, trade_date, settle_date, external_id, 
    external_id2, charge_code, formula_type, formula_code, charges, sum_flag,waive,broker,product_type)
    SELECT
      a.market_id,
      a.account_id,
      a.account_type,
      a.product_id,
      CASE b.currency WHEN 0 THEN a.clearing_currency ELSE b.currency END,
      a.process_date,
      a.trade_date,
      a.settle_date,
      a.trade_id,
      a.trade_exec_id,
      b.charge_code,
      -- CASE WHEN waive = 'Y' THEN '0' ELSE b.formula_type END,
      -- CASE WHEN waive = 'Y' THEN '0' ELSE b.formula_code END,
      b.formula_type,
      b.formula_code,
      0,
      b.sum_flag,
      b.waive,
      a.broker,
      a.product_type
    FROM
      tmp_account_trade_detail a
        INNER JOIN market_charge_rule b ON a.list_market_id = b.market_id AND (b.formula_type = 'CHRG' OR b.formula_type = 'COMM') AND b.sum_flag = 2 
    WHERE
      a.process_date = v_process_date;


  -- Account level charge 
  drop temporary table IF EXISTS tmp_account_charge_rule;
  create temporary table tmp_account_charge_rule as select * from account_charge_rule where (ifnull(due_date,'') = '' or ifnull(due_date,'') >= date_format(v_process_date,'%Y%m%d'));
  create index Index1 on tmp_account_charge_rule (account_id,charge_code,formula_type);

  update tmp_account_charge a
  inner join tmp_account_charge_rule b on a.account_id  = b.account_id and a.charge_code = b.charge_code and a.formula_type = b.formula_type
  set a.waive = b.waive,
      a.formula_code =case when  ifnull(b.formula_code,'') <> '' then ifnull(b.formula_code,'') else a.formula_code end
  where a.formula_type = 'CHRG';
  
  -- 美股期权不免平台使用费
  update tmp_account_charge a
  left join account_option_charge_rule b on b.account_id = a.account_id and b.formula_type = a.formula_type and 
        b.charge_code = a.charge_code and (ifnull(due_date,'') = '' or b.due_date >= date_format(v_process_date,'%Y%m%d')) 
  set a.waive = ifnull(b.waive,'N')
  where a.market_id = 2 and a.product_type  = 16 and a.formula_type = 'CHRG' and 
        a.charge_code = 'US_JC_FEE:US';

  -- Account level commission 
  update tmp_account_charge a
  left join account_commission_rule b ON a.formula_type = b.formula_type AND a.account_id = b.account_id and  a.market_id = b.market_id
  set a.waive = case when ifnull(b.waive,'') <> '' then b.waive ELSE a.waive end, 
      a.formula_code = case when ifnull(b.formula_code,'') <> '' then b.formula_code ELSE a.formula_code end
  where a.formula_type= 'COMM';

  -- update tmp_account_charge a
  -- inner join account_commission_rule b on a.account_id = b.account_id and  a.market_id = b.market_id 
  -- set a.waive = b.waive, 
  --     a.formula_code = b.formula_code
  -- where a.formula_type= 'COMM';

  -- remove waive 
  delete from tmp_account_charge where waive = 'Y';

  UPDATE
    tmp_account_charge a,
    market_product_charge_rule b
  SET
    -- a.formula_type = (CASE WHEN b.waive = 'Y' THEN '0' ELSE b.formula_type END),
    -- a.formula_code = (CASE WHEN b.waive = 'Y' THEN '0' ELSE b.formula_code END),
    a.currency = CASE b.currency WHEN 0 THEN a.currency ELSE b.currency END
  WHERE
    a.market_id = b.market_id AND a.product_id = b.product_id AND a.charge_code = b.charge_code;

  UPDATE
    tmp_account_charge a
   LEFT join market_account_charge_rule b ON a.market_id = b.market_id
      AND a.account_id = b.account_id
      AND a.account_type = b.account_type
      AND a.charge_code = b.charge_code
  SET
    a.currency = CASE when ifnull(b.currency,'') = '' THEN a.currency ELSE b.currency END;

  -- UPDATE
  --   tmp_account_charge a,
  --   market_account_charge_rule b
  -- SET
  --   -- a.formula_type = (CASE WHEN b.waive = 'Y' THEN '0' ELSE b.formula_type END),
  --   -- a.formula_code = (CASE WHEN b.waive = 'Y' THEN '0' ELSE b.formula_code END),
  --   a.currency = CASE b.currency WHEN 0 THEN a.currency ELSE b.currency END
  -- WHERE
  --   a.market_id = b.market_id
  --     AND a.account_id = b.account_id
  --     AND a.account_type = b.account_type
  --     AND a.charge_code = b.charge_code;
  
  drop temporary table IF EXISTS cal;
  CREATE TEMPORARY TABLE cal (
    id bigint,
    charge decimal(30,10) DEFAULT 0,
    CCY int DEFAULT 0,
    QTY decimal(21,6),
    AMT decimal(21,6),
    AVGPRC decimal(21,6),
    BS int DEFAULT 0,
    OP int DEFAULT 0,
    InputWay int DEFAULT 0,
    TradeCnt int DEFAULT 0,
    SettleFee char(1),
    StampFee char(1),
    LotSize decimal(21,6),
    Lot decimal(21,6),
    PT char(16),
    PST char(16),
    PriceFactor decimal(21,6),
    ContractSize decimal(21,6),
    ACCType int DEFAULT 0,
    EXRate decimal(21,6),
    ProductClass char(32),
    MarketCCY int,
    broker varchar(16),
    KEY pk (id)
  ) ENGINE = innodb DEFAULT CHARSET = utf8;
  INSERT INTO cal
    SELECT
      e.id,
      0,
      a.clearing_currency AS 'CCY',
      a.quantity AS 'QTY',
      a.trade_amount AS 'AMT',
      a.avg_price AS 'AVGPRC',
      a.buy_sell AS 'BS',
      a.open_close AS 'OP',
      a.input_channel AS 'InputWay',
      a.num_of_trades AS 'TradeCnt',
      b.value2 AS 'SettleFee',
      b.value1 AS 'StampFee',
      b.lot_size AS 'LotSize',
      CEIL(a.quantity / b.lot_size) AS 'Lot',
      b.product_type AS 'PT',
      b.product_sub_type AS 'PST',
      b.price_factor AS 'PriceFactor',
      b.contract_size AS 'ContractSzie',
      a.account_type AS 'ACCType',
      a.exchange_rate as ExRate, -- case when a.quote_currency = a.clearing_currency then 1 else d.rate  end AS 'EXRate',
      b.product_class,
      c.clearing_currency,
      a.broker
    FROM
      tmp_account_charge e
      inner join market c on e.market_id = c.market_id
      LEFT JOIN tmp_account_trade a ON e.external_id = a.trade_id
      LEFT JOIN product b ON a.list_market_id = b.list_market_id AND a.product_id = b.product_id;
      

  /*
  update cal a
  inner join currency_ratio b on a.CCY = b.currency_from and a.MarketCCY = b.currency_to 
  set a.ExRate = round(rate_molecular/rate_denominator,6);
  */

  drop temporary table IF EXISTS cal2;
  CREATE TEMPORARY TABLE cal2 (
    id bigint,
    charge decimal(30,10) DEFAULT 0,
    CCY int DEFAULT 0,
    QTY decimal(21,6),
    AMT decimal(21,6),
    AVGPRC decimal(21,6),
    BS int DEFAULT 0,
    OP int DEFAULT 0,
    InputWay int DEFAULT 0,
    SettleFee char(1),
    StampFee char(1),
    LotSize decimal(21,6),
    Lot decimal(21,6),
    PT char(16),
    PST char(16),
    PriceFactor decimal(21,6),
    ContractSize decimal(21,6),
    ACCType int DEFAULT 0,
    EXRate decimal(21,6),
    ProductClass char(32),
    TradeCnt int,
    MarketCCY int,
    KEY pk (id)
  ) ENGINE = innodb DEFAULT CHARSET = utf8;

  INSERT INTO cal2
    SELECT
      f.id,
      0,
      a.clearing_currency AS 'CCY',
      e.exec_quantity AS 'QTY',
      e.trade_amount AS 'AMT',
      e.exec_price AS 'Price',
      a.buy_sell AS 'BS',
      a.open_close AS 'OP',
      a.input_channel AS 'InputWay',
      b.value2 AS 'SettleFee',
      b.value1 AS 'StampFee',
      b.lot_size AS 'LotSize',
      CEIL(a.quantity / b.lot_size) AS 'Lot',
      b.product_type AS 'PT',
      b.product_sub_type AS 'PST',
      b.price_factor AS 'PriceFactor',
      b.contract_size AS 'ContractSzie',
      a.account_type AS 'ACCType',
      a.exchange_rate as 'ExRate', -- case when a.quote_currency = a.clearing_currency then 1 else d.rate  end AS 'EXRate',
      b.product_class,
      e.num_of_trades as TradeCnt,
      b.currency
    FROM tmp_account_trade_detail e 
    LEFT JOIN tmp_account_charge f on f.external_id = e.trade_id AND f.external_id2 = e.trade_exec_id
    LEFT JOIN tmp_account_trade a ON e.trade_id = a.trade_id
    LEFT JOIN product b ON e.list_market_id = b.list_market_id AND e.product_id = b.product_id; 

  -- INSERT INTO cal2
  --   SELECT
  --     f.id,
  --     0,
  --     a.clearing_currency AS 'CCY',
  --     e.exec_quantity AS 'QTY',
  --     e.trade_amount AS 'AMT',
  --     e.exec_price AS 'Price',
  --     a.buy_sell AS 'BS',
  --     a.open_close AS 'OP',
  --     a.input_channel AS 'InputWay',
  --     b.value2 AS 'SettleFee',
  --     b.value1 AS 'StampFee',
  --     b.lot_size AS 'LotSize',
  --     CEIL(a.quantity / b.lot_size) AS 'Lot',
  --     b.product_type AS 'PT',
  --     b.product_sub_type AS 'PST',
  --     b.price_factor AS 'PriceFactor',
  --     b.contract_size AS 'ContractSzie',
  --     a.account_type AS 'ACCType',
  --     a.exchange_rate as 'ExRate', -- case when a.quote_currency = a.clearing_currency then 1 else d.rate  end AS 'EXRate',
  --     b.product_class,
  --     e.num_of_trades as TradeCnt,
  --     g.clearing_currency
  --   FROM
  --     tmp_account_charge f
  --       inner join market g on f.market_id = g.market_id 
  --       LEFT JOIN tmp_account_trade a ON f.external_id = a.trade_id
  --       LEFT JOIN product b ON a.list_market_id = b.list_market_id AND a.product_id = b.product_id
  --       RIGHT JOIN tmp_account_trade_detail e ON f.external_id = e.trade_id AND f.external_id2 = e.trade_exec_id; 

   /*
  update cal2 a
  inner join currency_ratio b on a.CCY = b.currency_from and a.MarketCCY = b.currency_to 
  set a.ExRate = round(rate_molecular/rate_denominator,6);
  */
  
  -- insert into cal3 select * from cal2; 
  

  OPEN cur_charge;
  SET v_done2 = 0;
  FETCH cur_charge INTO v_id, v_formula_value, v_sum_flag, v_trade_id;
  WHILE v_done2 <> 1 DO
    IF v_sum_flag = 1 THEN
      
      SET @sql = CONCAT(' update cal set charge = ', v_formula_value, '  where id =', v_id, ';');
      
      PREPARE stmt FROM @sql;
      EXECUTE stmt;
    ELSEIF v_sum_flag = 2 THEN
      SET @sql = CONCAT(' update cal2 set charge = ', v_formula_value, '  where id =', v_id, ';');
      
      PREPARE stmt FROM @sql;
      EXECUTE stmt;
    END IF;
    SET v_done2 = 0;
    FETCH cur_charge INTO v_id, v_formula_value, v_sum_flag, v_trade_id;
  END WHILE;
  CLOSE cur_charge;

  UPDATE
    tmp_account_charge a
      LEFT JOIN cal b ON a.id = b.id
      LEFT JOIN (SELECT
        id, charge
      FROM
        cal2) c ON a.id = c.id
  SET
    a.charges = IFNULL(b.charge, 0) + IFNULL(c.charge, 0)
  WHERE
    a.process_date = v_process_date;
    
  INSERT
    INTO account_charge
    (process_date, trade_date, settle_date, account_id, account_type, market_id, product_id, currency, external_id, external_id2, charge_code, formula_code, formula_type, charges, accrued_charges, sum_flag, update_user, update_time)
    SELECT
      process_date,
      trade_date,
      settle_date,
      account_id,
      account_type,
      market_id,
      product_id,
      currency,
      external_id,
      external_id2,
      charge_code,
      formula_code,
      formula_type,
      charges,
      accrued_charges,
      sum_flag,
      'JC_Clearing',
      NOW()
    FROM
      tmp_account_charge;

  drop temporary table IF EXISTS tmp_account_trade_charge_summary;
  CREATE TEMPORARY TABLE tmp_account_trade_charge_summary
    SELECT
      external_id, formula_type, SUM(IFNULL(charges, 0)) AS 'charges'
    FROM
      tmp_account_charge
    GROUP BY
      external_id, formula_type;
  CREATE INDEX idx1
    ON tmp_account_trade_charge_summary (external_id, formula_type);

  UPDATE
    tmp_account_trade a,
    tmp_account_trade_charge_summary b
  SET
    a.commission = IFNULL(b.charges, 0),
    a.net_amount = round(a.net_amount + round(IFNULL(b.charges, 0)*(case a.buy_sell when 1 then 1 else -1 end ), 2) ,2)
  WHERE
    a.trade_id = b.external_id AND b.formula_type = 'COMM';

  UPDATE
    tmp_account_trade a,
    tmp_account_trade_charge_summary b
  SET
    a.charges = IFNULL(b.charges, 0),
    a.net_amount = round(a.net_amount +round(IFNULL(b.charges, 0)*(case a.buy_sell when 1 then 1 else -1 end ), 2) ,2)
  WHERE
    a.trade_id = b.external_id AND b.formula_type = 'CHRG';


  update account_trade a, tmp_account_trade b 
    set a.commission = round(ifnull(b.commission,0),2),
        a.charges = ifnull(b.charges,0),
        a.trade_amount = b.trade_amount, 
        a.net_amount = b.net_amount
    where a.trade_id = b.trade_id;
  
  drop temporary table IF EXISTS tmp_account_trade_charge_summary;
  CREATE TEMPORARY TABLE tmp_account_trade_charge_summary
    SELECT
      external_id, external_id2, formula_type, SUM(IFNULL(charges, 0)) AS 'charges'
    FROM
      tmp_account_charge
    GROUP BY
      external_id, external_id2, formula_type;
  CREATE INDEX idx1
    ON tmp_account_trade_charge_summary (external_id, external_id2, formula_type);

  UPDATE
    account_trade_detail a,
    tmp_account_trade_charge_summary b,
    tmP_account_trade c
  SET
    a.commission = round(IFNULL(b.charges, 0),2),
    a.net_amount = round(a.net_amount + round(IFNULL(b.charges, 0)*(case c.buy_sell when 1 then 1 else -1 end ),2 ),2)
  WHERE
    a.trade_id = b.external_id AND a.trade_exec_id = b.external_id2 AND b.formula_type = 'COMM' and 
    a.trade_id = c.trade_id; 
  
  UPDATE
    account_trade_detail a,
    tmp_account_trade_charge_summary b,
    tmp_account_trade c 
  SET
    a.charges = IFNULL(b.charges, 0),
    a.net_amount = round(a.net_amount +round(IFNULL(b.charges, 0)*(case c.buy_sell when 1 then 1 else -1 end ),2),2)
  WHERE
    a.trade_id = b.external_id AND a.trade_exec_id = b.external_id2 AND b.formula_type = 'CHRG' and 
    a.trade_id = c.trade_id ; 

  
  drop temporary table IF EXISTS cal2;
  drop temporary table IF EXISTS cal;

  
  SET o_ret_code = 0;
  SET o_ret_msg = '市场费用计算完成';
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proModifyAccount
-- ----------------------------
DROP PROCEDURE IF EXISTS `proModifyAccount`;
delimiter ;;
CREATE PROCEDURE `proModifyAccount`(OUT o_ret_code INT,
    OUT o_ret_msg  TEXT)
label: BEGIN
DECLARE v_tmp_int INT DEFAULT 0;

SET o_ret_code = 0, o_ret_msg = "Success";

SELECT count(account_id) INTO v_tmp_int FROM tmp_account_info;
IF v_tmp_int <> 1 THEN
    SET o_ret_code = 1, o_ret_msg = CONCAT("exists ",v_tmp_int," accounts");
    LEAVE label;
END IF;

IF EXISTS(SELECT 1 FROM tmp_account_info WHERE account_id IS NULL)THEN
    SET o_ret_code = 1, o_ret_msg = "account_id_is_NULL";
    LEAVE label;
END IF;

IF EXISTS(SELECT 1 FROM tmp_account_info WHERE account_type NOT IN(SELECT item FROM dict WHERE class='ACCOUNT'AND sub_class='ACCOUNT_TYPE') )THEN
    SET o_ret_code = 1, o_ret_msg = "account_type_is_invalid";
    LEAVE label;
END IF;

IF EXISTS(SELECT 1 FROM tmp_account_info WHERE account_class NOT IN(SELECT item FROM dict WHERE class='ACCOUNT'AND sub_class='CLASS') )THEN
    SET o_ret_code = 1, o_ret_msg = "account_class_is_invalid";
    LEAVE label;
END IF;

SELECT MAX(market_id)*2 INTO v_tmp_int FROM market;
IF EXISTS(SELECT 1 FROM tmp_account_info WHERE auth_markets<0 OR auth_markets>=v_tmp_int)THEN
    SET o_ret_code = 1, o_ret_msg = "auth_markets_is_invalid";
    LEAVE label;
END IF;

IF NOT EXISTS(SELECT 1 FROM account_profile INNER JOIN tmp_account_info ON account_profile.account_id=tmp_account_info.account_id) THEN
    SET o_ret_code = 1, o_ret_msg = "account_id not exists in account_profile";
    LEAVE label;
END IF;

IF NOT EXISTS(SELECT 1 FROM capital_account INNER JOIN tmp_account_info ON capital_account.account_id=tmp_account_info.account_id) THEN
    SET o_ret_code = 1, o_ret_msg = "account_id not exists in capital_account";
    LEAVE label;
END IF;

START TRANSACTION;

IF NOT EXISTS(SELECT 0 FROM sys_info WHERE sys_status=1) THEN
    SET o_ret_code = 1, o_ret_msg = "JCBMS database is not ready";
    rollback;
    LEAVE label;
END IF;

UPDATE account_profile 
INNER JOIN tmp_account_info ON account_profile.account_id=tmp_account_info.account_id
SET
account_profile.account_class = tmp_account_info.account_class,

account_profile.address1 = tmp_account_info.address1,
account_profile.address2 = tmp_account_info.address2,
account_profile.address3 = tmp_account_info.address3,
account_profile.address4 = tmp_account_info.address4,
account_profile.bank = tmp_account_info.bank,
account_profile.bank_account_id = tmp_account_info.bank_account_id,
account_profile.bank_account_name = tmp_account_info.bank_account_name,
account_profile.birth_day = tmp_account_info.birth_day,
account_profile.bos_uuid = tmp_account_info.bos_uuid,
account_profile.business_department = tmp_account_info.business_department,
account_profile.city = tmp_account_info.city,
account_profile.country = tmp_account_info.country,
account_profile.daily_statement_email_address = tmp_account_info.daily_statement_email_address,
account_profile.department_trading_group = tmp_account_info.department_trading_group,
account_profile.email_address = tmp_account_info.email_address,
account_profile.employer_address1 = tmp_account_info.employer_address1,
account_profile.employer_address2 = tmp_account_info.employer_address2,
account_profile.employer_address3 = tmp_account_info.employer_address3,
account_profile.employer_address4 = tmp_account_info.employer_address4,
account_profile.employer_city = tmp_account_info.employer_city,
account_profile.employer_country = tmp_account_info.employer_country,
account_profile.employer_name = tmp_account_info.employer_name,
account_profile.employer_phone1 = tmp_account_info.employer_phone1,
account_profile.employer_phone2 = tmp_account_info.employer_phone2,
account_profile.employer_phone3 = tmp_account_info.employer_phone3,
account_profile.employer_state = tmp_account_info.employer_state,
account_profile.employer_zip = tmp_account_info.employer_zip,
account_profile.employment = tmp_account_info.employment,
account_profile.famaliy_equity = tmp_account_info.famaliy_equity,
account_profile.famaliy_income = tmp_account_info.famaliy_income,
account_profile.first_name = tmp_account_info.first_name,
account_profile.fixed_income_experience = tmp_account_info.fixed_income_experience,
account_profile.forien_exchange_experience = tmp_account_info.forien_exchange_experience,
account_profile.fund_experience = tmp_account_info.fund_experience,
account_profile.gender = tmp_account_info.gender,
account_profile.invest_target = tmp_account_info.invest_target,
account_profile.is_government_official = tmp_account_info.is_government_official,
account_profile.is_terrorist = tmp_account_info.is_terrorist,
account_profile.last_name = tmp_account_info.last_name,
account_profile.mailing_address = tmp_account_info.mailing_address,
account_profile.middle_name = tmp_account_info.middle_name,
account_profile.monthly_statement_email_address = tmp_account_info.monthly_statement_email_address,
account_profile.others_incom_experience = tmp_account_info.others_incom_experience,
account_profile.party_country = tmp_account_info.party_country,
account_profile.party_effective_date = tmp_account_info.party_effective_date,
account_profile.party_expiration_date = tmp_account_info.party_expiration_date,
account_profile.partyid = tmp_account_info.partyid,
account_profile.partyid_type = tmp_account_info.partyid_type,
account_profile.phone1 = tmp_account_info.phone1,
account_profile.phone2 = tmp_account_info.phone2,
account_profile.phone3 = tmp_account_info.phone3,
account_profile.photo_country = tmp_account_info.photo_country,
account_profile.photo_effective_date = tmp_account_info.photo_effective_date,
account_profile.photo_expiration_date = tmp_account_info.photo_expiration_date,
account_profile.photoid = tmp_account_info.photoid,
account_profile.photoid_type = tmp_account_info.photoid_type,
account_profile.primary_joint = tmp_account_info.primary_joint,
account_profile.risk_tolerance = tmp_account_info.risk_tolerance,
account_profile.security_experience = tmp_account_info.security_experience,
account_profile.short_name = tmp_account_info.short_name,
account_profile.state = tmp_account_info.state,
account_profile.status = tmp_account_info.status,
account_profile.zip = tmp_account_info.zip,
account_profile.update_time = NOW();

UPDATE capital_account 
INNER JOIN tmp_account_info ON capital_account.account_id=tmp_account_info.account_id 
SET

capital_account.account_tag = tmp_account_info.account_tag,
capital_account.account_type = tmp_account_info.account_type,
capital_account.ae_id = tmp_account_info.ae_id,
capital_account.app_usable = tmp_account_info.app_usable,
capital_account.auth_currencies = tmp_account_info.auth_currencies,
capital_account.auth_markets = tmp_account_info.auth_markets,
capital_account.client_group_code = tmp_account_info.client_group_code,
capital_account.loan_limit = tmp_account_info.loan_limit,
capital_account.password = tmp_account_info.password,
capital_account.update_time = NOW();

COMMIT;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proModifyRemark
-- ----------------------------
DROP PROCEDURE IF EXISTS `proModifyRemark`;
delimiter ;;
CREATE PROCEDURE `proModifyRemark`(IN  i_id int, 
    IN  i_remark varchar(256), 
    IN  i_update_user varchar(32), 
    In  i_update_time datetime,
    OUT o_ret_code int,
    OUT o_ret_msg char(128))
label:begin
    
    set o_ret_code = 0; 
    set o_ret_msg = 'Success';

    start transaction; 

    if not EXISTS(select 1 from cash_flow where id = i_id) then 
        set o_ret_code = 1; 
        set o_ret_msg = 'id is not exists';
    end if;

    update cash_flow set remark = i_remark where id = i_id;

    COMMIT;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proOpenAccount
-- ----------------------------
DROP PROCEDURE IF EXISTS `proOpenAccount`;
delimiter ;;
CREATE PROCEDURE `proOpenAccount`(OUT o_ret_code INT,
    OUT o_ret_msg  TEXT)
label: BEGIN
DECLARE v_tmp_int INT DEFAULT 0;

SET o_ret_code = 0, o_ret_msg = "Success";

SELECT count(account_id) INTO v_tmp_int FROM tmp_account_info;
IF v_tmp_int <> 1 THEN
    SET o_ret_code = 1, o_ret_msg = CONCAT("exists ",v_tmp_int," accounts");
    LEAVE label;
END IF;

IF EXISTS(SELECT 1 FROM tmp_account_info WHERE account_id IS NULL)THEN
    SET o_ret_code = 1, o_ret_msg = "account_id_is_NULL";
    LEAVE label;
END IF;

IF EXISTS(SELECT 1 FROM tmp_account_info WHERE account_type NOT IN(SELECT item FROM dict WHERE class='ACCOUNT'AND sub_class='ACCOUNT_TYPE') )THEN
    SET o_ret_code = 1, o_ret_msg = "account_type_is_invalid";
    LEAVE label;
END IF;

IF EXISTS(SELECT 1 FROM tmp_account_info WHERE account_class NOT IN(SELECT item FROM dict WHERE class='ACCOUNT'AND sub_class='CLASS') )THEN
    SET o_ret_code = 1, o_ret_msg = "account_class_is_invalid";
    LEAVE label;
END IF;

SELECT MAX(market_id)*2 INTO v_tmp_int FROM market;
IF EXISTS(SELECT 1 FROM tmp_account_info WHERE auth_markets<0 OR auth_markets>=v_tmp_int)THEN
    SET o_ret_code = 1, o_ret_msg = "auth_markets_is_invalid";
    LEAVE label;
END IF;

IF EXISTS(SELECT 1 FROM account_profile INNER JOIN tmp_account_info ON account_profile.account_id=tmp_account_info.account_id) THEN
    SET o_ret_code = 1, o_ret_msg = "account_id exists in account_profile";
    LEAVE label;
END IF;

IF EXISTS(SELECT 1 FROM capital_account INNER JOIN tmp_account_info ON capital_account.account_id=tmp_account_info.account_id) THEN
    SET o_ret_code = 1, o_ret_msg = "account_id exists in capital_account";
    LEAVE label;
END IF;

START TRANSACTION;

IF NOT EXISTS(SELECT 0 FROM sys_info WHERE sys_status=1) THEN
    SET o_ret_code = 1, o_ret_msg = "JCBMS database is not ready";
    rollback;
    LEAVE label;
END IF;

INSERT INTO account_profile(
account_class,account_id,address1,address2,address3,address4,bank,bank_account_id,bank_account_name,
birth_day,bos_uuid,business_department,city,country,daily_statement_email_address,department_trading_group,
email_address,employer_address1,employer_address2,employer_address3,employer_address4,
employer_city,employer_country,employer_name,employer_phone1,employer_phone2,employer_phone3,employer_state,employer_zip,employment,
famaliy_equity,famaliy_income,first_name,first_name_eng,fixed_income_experience,forien_exchange_experience,fund_experience,gender,
invest_target,is_government_official,is_terrorist,last_name,last_name_eng,mailing_address,middle_name,monthly_statement_email_address,
others_incom_experience,party_country,party_effective_date,party_expiration_date,partyid,partyid_type,
phone1,phone2,phone3,photo_country,photo_effective_date,photo_expiration_date,photoid,photoid_type,primary_joint,
risk_tolerance,security_experience,short_name,state,status,zip,insert_time,update_user,update_time
) SELECT 
account_class,account_id,address1,address2,address3,address4,bank,bank_account_id,bank_account_name,
birth_day,bos_uuid,business_department,city,country,daily_statement_email_address,department_trading_group,
email_address,employer_address1,employer_address2,employer_address3,employer_address4,
employer_city,employer_country,employer_name,employer_phone1,employer_phone2,employer_phone3,employer_state,employer_zip,employment,
famaliy_equity,famaliy_income,first_name,first_name_eng,fixed_income_experience,forien_exchange_experience,fund_experience,gender,
invest_target,is_government_official,is_terrorist,last_name,last_name_eng,mailing_address,middle_name,monthly_statement_email_address,
others_incom_experience,party_country,party_effective_date,party_expiration_date,partyid,partyid_type,
phone1,phone2,phone3,photo_country,photo_effective_date,photo_expiration_date,photoid,photoid_type,primary_joint,
risk_tolerance,security_experience,short_name,state,status,zip,      NOW(),         '',NOW()
FROM tmp_account_info;

INSERT INTO capital_account(
account_id,account_tag,account_type,ae_id,app_usable,auth_currencies,auth_markets,client_group_code,loan_limit,password,insert_time,update_user,update_time
) SELECT 
account_id,account_tag,account_type,ae_id,app_usable,auth_currencies,auth_markets,client_group_code,loan_limit,password,      NOW(),         '',NOW()
FROM tmp_account_info;

COMMIT;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proOpenPosition
-- ----------------------------
DROP PROCEDURE IF EXISTS `proOpenPosition`;
delimiter ;;
CREATE PROCEDURE `proOpenPosition`(IN  i_market_id int,
   IN  i_product_type int,
   OUT o_ret_code int ,
   OUT o_ret_msg char(128))
label:begin 
       declare v_process_date date; 
       declare v_pre_process_date date;
       declare v_market_id int; 
       declare v_product_id varchar(32); 
       declare v_account_id varchar(16); 
       declare v_account_type int; 
       declare v_price decimal(30,10); 
       declare v_quantity decimal(30,10); 
       declare v_trade_amount decimal(30,10); 
       declare v_net_amount decimal(30,10); 
       declare v_buy_sell int; 
       declare v_product_type int; 
       declare v_currency int; 
       declare v_done int;
       declare v_basic_day date; 
       declare v_settle_days int; 

       select buss_date into v_process_date from sys_info; 
       select last_buss_date into v_pre_process_date from sys_info; 

       
       drop temporary table if exists tmp_trade_summary; 
       create temporary table tmp_trade_summary
       (
       market_id int,
       product_id varchar(32),
       product_type int,
       account_id varchar(16),
       account_type int,
       currency int,
       net_quantity decimal(30,10), 
       net_amount decimal(30,10),    
       custodian_code varchar(16),
       custodian_account varchar(16),
       code int,      
       index idx1(market_id,product_id,account_id),
       index idx2(code)
       ); 

       insert into tmp_trade_summary
       (
          market_id, 
          product_id, 
          product_type, 
          account_id, 
          account_type, 
          currency, 
          net_quantity, 
          net_amount, 
          custodian_code,
          custodian_account,
          code
       )
       select 
       market_id,
       product_id, 
       max(product_type), 
       account_id, 
       max(account_type), 
       max(quote_currency), 
       sum((3-2*buy_sell)*quantity),    
       sum((3-2*buy_sell)*net_amount),  
       custodian_code,
       custodian_account,
       0
       from tmp_account_trade
       group by market_id, product_id, account_id ,custodian_code, custodian_account ; 

       
       update account_position a 
       inner join tmp_trade_summary b on a.market_id =b.market_id and a.product_id =b.product_id and a.account_id = b.account_id
       set a.position_cost = a.position_cost + b.net_amount, 
           a.net_quantity = a.net_quantity + b.net_quantity,
           b.code = 1
       where a.process_date = v_process_date and 
             a.market_id = i_market_id and 
             a.custodian_code = b.custodian_code and 
             a.custodian_account = b.custodian_account; 

       
       insert into account_position
              (                                           
              process_date,
              market_id,
              account_id,
              account_type,
              product_type,
              product_id,
              currency,
              quantity,
              net_quantity,
              frozen_quantity,
              avg_price1,
              avg_price2,
              pnl,
              market_value,
              uncleared_quantity,
              uncleared_amount,
              unsettled_quantity,
              unsettled_amount,
              settled_quantity,
              settled_amount,
              
              
              margin_amount,
              custodian_code,
              custodian_account,
              nominee_quantity,
              position_cost
              )
       select 
              v_process_date, 
              a.market_id, 
              a.account_id, 
              a.account_type, 
              a.product_type, 
              a.product_id, 
              a.currency, 
              0, 
              a.net_quantity, 
              0, 
              0, 
              0, 
              0, 
              0, 
              0, 
              0, 
              0, 
              0, 
              0, 
              0, 
              0, 
              custodian_code,
              custodian_account,
              0,  
              a.net_amount
       from tmp_trade_summary a
       where a.code = 0; 

       
       

       
       
       


       set o_ret_code = 0; 
       set o_ret_msg = "持仓处理完成";
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proPortfolioFee
-- ----------------------------
DROP PROCEDURE IF EXISTS `proPortfolioFee`;
delimiter ;;
CREATE PROCEDURE `proPortfolioFee`(OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin
    declare v_process_date date; 
    declare v_last_process_date  date; 
    declare v_done int; 
    declare v_formula_value char(255); 
    declare v_formula_value2 char(255); 
    declare v_id bigint;  
    declare v_date date ; 
    declare v_last_month_date date;
    declare v_day1 date; 
    declare v_day2 date; 
    declare v_end_date date; 
    declare v_sum_date_s date; 
    declare v_sum_date_e date; 

    start transaction;
    select buss_date,last_buss_date  into v_process_date,v_last_process_date from sys_info; 

    call proDayPortfolioFee(v_process_date,o_ret_code,o_ret_msg);
    if o_ret_code then 
        rollback; 
        leave label;
    end if; 

    set v_sum_date_s = v_process_date;
    set v_sum_date_e = v_process_date; 
    
    set v_end_date = NULL; 
    if date_format(v_process_date,'%w') = 5 then 
        
        set v_day1 = date_add(v_process_date,interval 1 day); 
        set v_day2 = date_add(v_process_date,interval 2 day); 
        set v_last_month_date = last_day(v_process_date);

        
        if v_day1 = v_last_month_date then 
            call proDayPortfolioFee(v_day1,o_ret_code,o_ret_msg);
            if o_ret_code then 
                rollback; 
                leave label;
            end if; 
        end if; 

        
        if v_day2 = v_last_month_date then 
            call proDayPortfolioFee(v_day1,o_ret_code,o_ret_msg);
            if o_ret_code then 
                rollback; 
                leave label;
            end if; 

            call proDayPortfolioFee(v_day2,o_ret_code,o_ret_msg);
            if o_ret_code then 
                rollback; 
                leave label;
            end if; 
        end if;
    end if;     

    set o_ret_code = 0; 
    set o_ret_msg = "托管费计算完成";

    commit;
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proPosition
-- ----------------------------
DROP PROCEDURE IF EXISTS `proPosition`;
delimiter ;;
CREATE PROCEDURE `proPosition`(IN  i_market_id int ,
  IN  i_product_type int ,
  OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin 
   
   declare v_process_date date; 
   declare v_process_date1 date; 
   
   set o_ret_code = 1;

   select buss_date into v_process_date from sys_info; 
   set v_process_date1 = date_add(v_process_date,interval 1 day );

    -- 删除过期持仓？

    -- market_value begin 
    update account_position a
        inner join market  c  on a.market_id = c.market_id 
        inner join product_market_data b on c.t0 = b.trade_date and a.market_id = b.list_market_id and a.product_id = b.product_id
        left join  product d on a.market_id = d.list_market_id and a.product_id = d.product_id
        set a.market_value = round(a.net_quantity * b.closing_price * ifnull(d.price_factor,1),2),
            a.closing_price = b.closing_price, 
            a.last_closing_price = b.last_closing_price
        where a.process_date = v_process_date and a.market_id  = i_market_id and a.product_type = i_product_type; 
    -- market value end

    if i_market_id  = '2' or i_market_id  = '16' then 
        update product a 
        inner join basicdata.vw_zj_basic_info b on a.product_id = b.code 
        inner join market c on a.list_market_id = c.market_id
        set a.status = case when b.trading_day = c.t0 then 1 else 2 end 
        where a.list_market_id = i_market_id and a.product_type = i_product_type;
        
        -- drop temporary table if exists tmp_basic_info;
        -- create temporary table tmp_basic_info as select * from basicdata.vw_zj_basic_info where ;
        -- create index idx1 on tmp_basic_info(code);
        -- update product a 
        -- left join tmp_basic_info b on a.product_id = b.code 
        -- left join market c on a.list_market_id = c.market_id
        -- set a.status = case when b.trading_day = c.t0 then 1 else 2 end 
        -- where a.list_market_id = i_market_id;
    end if; 

    -- 选出停牌两天以上的股票
    drop temporary table if exists tmp_suspend_product; 
    create temporary table tmp_suspend_product
    (
        product_id varchar(32),
        last_active_date date, 
        trade_date date,
        settle_days int,
        valid int not null default 0,
        index idx(valid,product_id)
    ); 

    insert into tmp_suspend_product
    (
        product_id, 
        last_active_date
    )
    select 
        a.product_id, 
        b.last_active_date
    from account_position a
    inner join product b on a.market_id = b.list_market_id and a.product_id = b.product_id and b.status  = 2
    where a.process_date = v_process_date and a.market_id  = i_market_id and a.product_type = i_product_type
    group by b.product_id,b.last_active_date;

    update tmp_suspend_product a 
    inner join market b on b.market_id = i_market_id 
    set a.trade_date = b.t0,
        a.settle_days = b.market_settle_days; 

    update tmp_suspend_product a 
    set valid= case when funIntervalSettleDay(i_market_id, ifnull(a.last_active_date,'2000-01-01'),a.settle_days) < a.trade_date then 1 else 0 end ;

    update account_position a 
    inner join tmp_suspend_product b on b.valid = 1 and a.product_id = b.product_id 
    set a.closing_price = 0, 
        a.market_value = 0
    where  a.process_date = v_process_date and a.market_id  = i_market_id and a.product_type = i_product_type; 

    -- update last_active_date; 
    update product a 
    left join market b on a.list_market_id = b.market_id 
    set a.last_active_date = case when a.status = 2 then a.last_active_date else b.t0 end
    where a.list_market_id  = i_market_id and a.product_type = i_product_type;


    -- 创建汇总成交数据
    drop temporary table if exists tmp_account_position; 
    create temporary table tmp_account_position
    (
        process_date DATE,
        market_id int,
        product_id varchar(32),
        account_id varchar(16),
        net_quantity decimal(30,10), -- 净持仓数量
        position_cost decimal(30,10),
        index idx1(process_date,market_id,product_id,account_id) -- 去掉了product_type
    ); 

    insert into tmp_account_position
    (
        process_date,
        market_id,
        product_id,
        account_id, 
        net_quantity,
        position_cost
    )
    select 
    process_date,
    market_id,
    product_id, 
    account_id,
    sum(net_quantity),
    sum(position_cost)
    from account_position a
    where a.process_date = v_process_date and a.market_id = i_market_id and a.product_type = i_product_type
    group by process_date,market_id,product_id,account_id
    having(count(1) > 1); 

    update tmp_account_position
    set position_cost = 0
    where net_quantity = 0 and position_cost <> 0;

    -- caculate avg_cost 
    update account_position a
    inner join tmp_account_position b on  b.process_date = a.process_date and b.market_id = a.market_id and b.product_id = a.product_id and b.account_id = a.account_id 
    inner join product c on c.list_market_id = a.market_id and c.product_id = a.product_id 
    set 
    -- a.avg_price1 = case when a.net_quantity = 0 then 0 else round(a.position_cost/a.net_quantity,6) end
    -- a.position_cost = case when ifnull(b.position_cost,0) = 0 then 0 else b.position_cost end , 
    -- 按照net_qiantuty 分配不同通道的持仓成本
    a.position_cost = case when ifnull(b.position_cost,0) = 0 then 0 else round(b.position_cost*a.net_quantity/b.net_quantity,6) end
    where a.process_date = v_process_date and a.market_id = i_market_id and a.product_type = i_product_type and a.product_id not in 
    (
        select product_id from product_ipo_announcement where ifnull(app_posted,'') = 'Y' and ifnull(refund_posted,'')<>'Y'
    );

    update account_position a
    inner join tmp_account_position b on  b.process_date = a.process_date and b.market_id = a.market_id and b.product_id = a.product_id and b.account_id = a.account_id 
    inner join product c on c.list_market_id = a.market_id and c.product_id = a.product_id 
    set 
    a.avg_price1 = round(case when ifnull(a.net_quantity,0) =0  then 0 else b.position_cost/b.net_quantity/ifnull(c.price_factor,1) end ,6)
    where a.process_date = v_process_date and a.market_id = i_market_id and a.product_type = i_product_type and a.product_id not in 
    (
        select product_id from product_ipo_announcement where ifnull(app_posted,'') = 'Y' and ifnull(refund_posted,'')<>'Y'
    );

    -- caculate avg_cost 
    update account_position a
    inner join product b on b.list_market_id = a.market_id and b.product_id = a.product_id 
    set 
    a.avg_price1 = round(case when a.net_quantity = 0 then 0 else a.position_cost/a.net_quantity/ifnull(b.price_factor,1) end,6),
    a.position_cost = case when a.net_quantity = 0 then 0 else a.position_cost end 
    where a.process_date = v_process_date and a.market_id = i_market_id and a.product_type = i_product_type and a.product_id not in 
    (
        select product_id from product_ipo_announcement where ifnull(app_posted,'') = 'Y' and ifnull(refund_posted,'')<>'Y'
    );

    -- custodian_account
    update account_position a  
    inner join account_type_custodian b on i_market_id = b.market_id and a.account_type = b.account_type
    set a.custodian_code = b.custodian_code,
        a.custodian_account = b.custodian_account
    where a.process_date = v_process_date and a.market_id = i_market_id and a.product_type = i_product_type; 


    set o_ret_code = 0;
    set o_ret_msg = '持仓处理完成';
    
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proPositionMarketValueSummary
-- ----------------------------
DROP PROCEDURE IF EXISTS `proPositionMarketValueSummary`;
delimiter ;;
CREATE PROCEDURE `proPositionMarketValueSummary`(IN  i_process_date DATE)
label:begin

    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    
    drop temporary table if exists tmp_position_market_value_summary;
    create temporary table tmp_position_market_value_summary
    (
       process_date date,
       account_id varchar(16),
       market_value decimal(30,10),
       market_value_after_haircut decimal(30,10),
       index idx1(process_date,account_id)
    );

    
    insert into tmp_position_market_value_summary
    (
        process_date, 
        account_id, 
        market_value, 
        market_value_after_haircut
    )
    select 
        a.process_date,
        a.account_id,
        sum(round(a.market_value, 2)) as market_value,
        sum(round(a.market_value_after_haircut, 2)) as market_value_after_haircut
        from v_account_position_market_value_after_haircut a 
        where a.process_date = i_process_date 
        group by process_date,account_id;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proPostAccountInterest
-- ----------------------------
DROP PROCEDURE IF EXISTS `proPostAccountInterest`;
delimiter ;;
CREATE PROCEDURE `proPostAccountInterest`(IN  i_account_id varchar(16),
  OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin
    declare v_process_date date; 
    declare v_done int; 
    declare v_id int; 
    declare v_fee decimal(21,6); 
    DECLARE v_fee2 decimal(21,6);
    declare v_account_id char(16); 
    declare v_account_type int; 
    declare v_currency int;
    declare v_month_last_day date; 
    declare cur_bal cursor for 
    select id,account_id, account_type, currency,accrued_interest,accrued_interest_credit
    from account_balance 
    where process_date  =  v_process_date  and (ifnull(i_account_id,'')  = '' or account_id = i_account_id);

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done=1;
    set o_ret_code = '0'; 
    set o_ret_msg = 'Success';
    start transaction ; 
    select buss_date into v_process_date from sys_info; 

    if i_account_id <> '' then 
        if not EXISTS (select 1 from capital_account where account_id = i_account_id) then 
            rollback; 
            set o_ret_code = '1'; 
            set o_ret_msg = concat('Account not exists[',i_account_id,']'); 
            leave label; 
        end if; 
    end if; 

    open cur_bal; 
    set v_done=0; 
    fetch cur_bal into v_id,v_account_id, v_account_type, v_currency,v_fee,v_fee2;
    while v_done <> 1 do

        if v_fee <> 0 then  
            update account_balance set accrued_interest = 0 where id = v_id; 
            call proCashOut(v_process_date,v_account_id,v_account_type, v_currency,v_fee,1 ,concat('Monthly Interest Paid @',(case v_currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end)),
                        '','','','','','','','','','','','accrued_interest_debit',v_account_id, '','','system',now(),o_ret_code,o_ret_msg);
            
            if o_ret_code then 
                rollback; 
                leave label;
            end if; 
        end if; 

        if v_fee2 <> 0 then 
            update account_balance set accrued_interest_credit = 0 where id = v_id; 
            call proCashIn(v_process_date,v_account_id,v_account_type, v_currency,v_fee2,1,concat('Monthly Interest Received @',(case v_currency when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end)),
                        '','','','','','','','','','','','accrued_interest_credit',v_account_id, '','','system',now(),o_ret_code,o_ret_msg);
            if o_ret_code then 
                rollback; 
                leave label;
            end if; 
        end if; 

    set v_done=0; 
    fetch cur_bal into v_id,v_account_id, v_account_type, v_currency,v_fee,v_fee2;
    end while; 
    commit;
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proPostAccountPortfolioFee
-- ----------------------------
DROP PROCEDURE IF EXISTS `proPostAccountPortfolioFee`;
delimiter ;;
CREATE PROCEDURE `proPostAccountPortfolioFee`(IN  i_account_id varchar(16),
  OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin
    declare v_process_date date; 
    declare v_done int; 
    declare v_id int; 
    declare v_fee decimal(30,10); 
    DECLARE v_fee2 decimal(30,10);
    declare v_account_id char(16); 
    declare v_account_type int; 
    declare v_currency int;
    declare v_market_id int;
    declare v_market char(16);
    declare v_real_month_last_day date;
    declare v_real_month_first_day date;

    declare cur_bal cursor for 
        select a.account_id,a.market_id,a.currency,b.account_type,sum(a.BASE_CHARGE_amount)
         from account_portfolio_fee  a 
         inner join capital_account b on a.account_id = b.account_id 
         WHERE a.process_date >= v_real_month_first_day and a.process_date<= v_real_month_last_day 
         group by a.account_id,a.MARKET_ID,a.currency,b.account_type 
         order by a.account_id,a.MARKET_ID,a.currency,b.account_type;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done=1;

    set o_ret_code = '0'; 
    set o_ret_msg = 'Success';

    select buss_date into v_process_date from sys_info; 
    select max(calendar_day) into v_real_month_last_day from calendar where date_format(calendar_day,'%Y%m') = date_format(v_process_date,'%Y%m') ; 
    select min(calendar_day) into v_real_month_first_day from calendar where date_format(calendar_day,'%Y%m') = date_format(v_process_date,'%Y%m') ; 

    if i_account_id <> '' then 
        if not EXISTS (select 1 from capital_account where account_id = i_account_id) then 
            rollback; 
            set o_ret_code = '1'; 
            set o_ret_msg = concat('Account not exists[',i_account_id,']'); 
            leave label; 
        end if; 
    end if; 

    open cur_bal; 
    set v_done=0; 
    fetch cur_bal into v_account_id,v_market_id,v_currency,v_account_type,v_fee;
    while v_done <> 1 do
		  set v_market = case when v_market_id = 4 then 'SHA' when v_market_id = 8 then 'SZA' end;
        if v_fee <> 0 then 
            call proCashOut(v_process_date,v_account_id,v_account_type,v_currency,v_fee,1,
                concat('Portfolio Fee',' ',date_format(v_process_date,'%Y-%m'),' ',v_market),NULL,
                NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                CONCAT('Portfolio Fee Paid=',IFNULL(v_fee,'')),v_account_id,'','', 
                'system',now(),o_ret_code,o_ret_msg);
            if o_ret_code then 
                rollback; 
                leave label;
            end if;
        end if; 
    set v_done=0; 
    fetch cur_bal into v_account_id,v_market_id,v_currency,v_account_type,v_fee;
    end while; 

    drop temporary table if EXISTS tmp_account_portfolio_fee; 
    create temporary table tmp_account_portfolio_fee
    (
        account_id varchar(16), 
        account_type int,
        currency int,
        index idx1(account_id,account_type,currency)  
    );

    insert into tmp_account_portfolio_fee
    (
        account_id,
        account_type,
        currency
    )
    select 
        account_id,
        account_type,
        currency
    from account_portfolio_fee
    where process_date >= v_real_month_first_day and process_date<= v_real_month_last_day 
    group by account_id,account_type,currency
    order by account_id,account_type,currency;

    UPDATE account_balance a
    inner join tmp_account_portfolio_fee b on a.account_id = b.account_id and a.account_type = b.account_type and a.currency =b.currency
    set a.portfolio_fee = 0
    where a.process_date = v_process_date;

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proPostBorrowFee
-- ----------------------------
DROP PROCEDURE IF EXISTS `proPostBorrowFee`;
delimiter ;;
CREATE PROCEDURE `proPostBorrowFee`(OUT o_code INT,
    OUT o_mesg VARCHAR(32))
procedure_label: BEGIN

SET o_code = 0, o_mesg = '';

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proPostfolioFee
-- ----------------------------
DROP PROCEDURE IF EXISTS `proPostfolioFee`;
delimiter ;;
CREATE PROCEDURE `proPostfolioFee`(IN  i_account_id varchar(16),
  OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin
    declare v_process_date date; 
    declare v_month_last_day date; 
    declare v_real_month_last_day date;
    declare v_real_month_first_day date;
    declare v_sat date; 
    declare v_sun date; 
    set o_ret_code = '0'; 
    set o_ret_msg = 'Success';
start transaction; 

    select buss_date into v_process_date from sys_info; 
    select max(calendar_day) into v_month_last_day from calendar where date_format(calendar_day,'%Y%m') = date_format(v_process_date,'%Y%m') and  date_format(calendar_day,'%w') not in(0,6) ; 
    select max(calendar_day) into v_real_month_last_day from calendar where date_format(calendar_day,'%Y%m') = date_format(v_process_date,'%Y%m') ; 
    
    
    if v_process_date = v_month_last_day then 
      call proPostAccountPortfolioFee(i_account_id,o_ret_code,o_ret_msg);  
      if o_ret_code then 
        rollback; 
        leave label;
      end if;
    end if;

    
    if date_format(v_process_date,'%w') = 5 then 
      set v_sat = date_add(v_process_date,interval 1 day); 
      set v_sun = date_add(v_process_date,interval 2 day); 
      
      if v_process_date = v_month_last_day then 
        
        if v_sat > v_real_month_last_day then 
          call proDayPortfolioFee(v_sat,o_ret_code,o_ret_msg);
          if o_ret_code then 
              rollback; 
              leave label;
          end if; 
        end if; 

        if v_sun > v_real_month_last_day then 
          
          call proDayPortfolioFee(v_sun,o_ret_code,o_ret_msg);
          if o_ret_code then 
              rollback; 
              leave label;
          end if; 
        end if; 
      else 
        
        call proDayPortfolioFee(v_sat,o_ret_code,o_ret_msg);
        if o_ret_code then 
            rollback; 
            leave label;
        end if; 
        call proDayPortfolioFee(v_sun,o_ret_code,o_ret_msg);
        if o_ret_code then 
            rollback; 
            leave label;
        end if; 
      end if; 
    end if;

    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proPostInterest
-- ----------------------------
DROP PROCEDURE IF EXISTS `proPostInterest`;
delimiter ;;
CREATE PROCEDURE `proPostInterest`(IN  i_account_id varchar(16),
  OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin
    declare v_process_date date; 
    declare v_month_last_day date; 
    declare v_real_month_last_day date;  
    declare v_sat date; 
    declare v_sun date; 
    set o_ret_code = '0'; 
    set o_ret_msg = 'Success';
    select buss_date into v_process_date from sys_info; 
    select max(calendar_day) into v_month_last_day from calendar where date_format(calendar_day,'%Y%m') = date_format(v_process_date,'%Y%m') and  date_format(calendar_day,'%w') not in(0,6) ; 
    select max(calendar_day) into v_real_month_last_day from calendar where date_format(calendar_day,'%Y%m') = date_format(v_process_date,'%Y%m') ; 
    start transaction; 
    #月末进行划转
    if v_process_date = v_month_last_day then 
      call proPostAccountInterest(i_account_id,o_ret_code,o_ret_msg);        
      if o_ret_code then 
        rollback; 
        leave label;
      end if;
    end if;

    #当日为周五
    if date_format(v_process_date,'%w') = 5 then 
      set v_sat = date_add(v_process_date,interval 1 day); 
      set v_sun = date_add(v_process_date,interval 2 day); 
      #5，6，7中存在月末
      if v_process_date = v_month_last_day then 
        #6为下个月的数据
        if v_sat > v_real_month_last_day then 
          call proCalDayInterest(v_sat,o_ret_code,o_ret_msg);
          if o_ret_code then 
              rollback; 
              leave label;
          end if; 
        end if; 

        if v_sun > v_real_month_last_day then 
          #7为下个月数据
          call proCalDayInterest(v_sun,o_ret_code,o_ret_msg);
          if o_ret_code then 
              rollback; 
              leave label;
          end if; 
        end if; 
      else 
        #不存在月末，直接算出6，7的利息
        call proCalDayInterest(v_sat,o_ret_code,o_ret_msg);
        if o_ret_code then 
            rollback; 
            leave label;
        end if; 
        call proCalDayInterest(v_sun,o_ret_code,o_ret_msg);
        if o_ret_code then 
            rollback; 
            leave label;
        end if; 
      end if; 
    end if;

    call proDeleteExpiredOptionPosition(o_ret_code, o_ret_msg);
    if o_ret_code then 
      rollback; 
      leave label; 
    end if; 

    -- drop temporary table if exists tmp_corp_action_ratio; 
    -- create temporary table tmp_corp_action_ratio
    -- (
    --   market_id int, 
    --   product_id varchar(32),
    --   ratio_from decimal(30,10),
    --   ratio_to decimal(30,10), 
    --   index idx1(market_id,product_id)
    -- ); 
    -- insert into tmp_corp_action_ratio
    -- select  
    --   market_id,product_id,ratio_from,ratio_to
    -- from corp_action 
    -- where date_format(posted_date,'%Y%m%d') = v_process_date and ifnull(posted,'') = 'Y' and 
    --     product_id = to_product_id and ratio_from <> 0 and dividend_rate = 0;

   -- 更新市值: 因为在日终前可能还会进行转仓操作
    -- update account_position a 
    -- inner join tmp_corp_action_ratio c on c.market_id = a.market_id and c.product_id = a.product_id
    -- set a.closing_price = round((ifnull(c.ratio_from,1) / ifnull(c.ratio_to,1))*a.closing_price,6)
    -- where a.process_date = v_process_date; 

    update account_position a
    left join  product d on a.market_id = d.list_market_id and a.product_id = d.product_id
    set a.market_value = round(a.net_quantity*a.closing_price*ifnull(d.price_factor,1),2)
    where a.process_date = v_process_date; 

    -- 汇总市值 BEGIN
    drop temporary table if exists tmp_market_value; 
    create temporary table tmp_market_value
    (
        account_id varchar(16), 
        account_type int, 
        currency  int,
        market_value decimal(30,10),
        long_market_value decimal(30,10), 
        short_market_value decimal(30,10),
        index idx1(account_id,account_type,currency)
    ); 

    insert into tmp_market_value
    select account_id,
           account_type,
           currency, 
           sum(ifnull(market_value,0)), 
           sum(if(ifnull(market_value,0)>0, ifnull(market_value,0), 0) ),
           sum(if(ifnull(market_value,0)<0, ifnull(market_value,0), 0) )
    from account_position 
    where process_date = v_process_date 
    group by account_id,account_type,currency; 

    INSERT
    INTO account_balance
    (
        process_date,
        account_id,
        account_type,
        currency
    )
    SELECT
        v_process_date,
        t.account_id, 
        t.account_type, 
        t.currency
    from  tmp_market_value t 
    where not  exists(select 1 from account_balance a  where a.process_date = v_process_date and a.account_id = t.account_id and a.account_type = t.account_type and a.currency = t.currency);

    update account_balance a
    inner join tmp_market_value b on a.account_id = b.account_id and a.account_type = b.account_type and a.currency = b.currency
    set a.market_value = b.market_value, 
        a.long_market_value  = b.long_market_value, 
        a.short_market_value = b.short_market_value
    where a.process_date = v_process_date;
    -- 市值 END


    -- IPO  
    drop temporary table if exists ipo_frozen;
    create temporary table ipo_frozen
    (
        account_id varchar(16), 
        currency int, 
        loan_amount decimal(30,10),
        index idx(account_id, currency)
    );

    insert into ipo_frozen
    select 
    t1.account_id,
    t1.currency as currency,
    sum(ifnull(t1.loan_amount,0))
    from product_ipo_app t1  
    inner join product_ipo_announcement t2 on t2.ipo_id = t1.ipo_id
    where ifnull(t1.refund_posted,'') <> 'Y'
    group by t1.account_id,t1.currency;
    --


    -- 最终的计算
    update account_balance a
    left join ipo_frozen b on a.account_id = b.account_id and a.currency = b.currency
    set 
        -- settle_balance就是交收后的余额，在手资金，trade_balance就是交收+未交收
        -- 客户权益，代表着如果客户把所有的仓都变现后，可以获取多少钱；（frozen_amount里面之前是包含利息的，现在既然单独了字段，就改成不包含利息）
        a.equity_balance = a.trade_balance  + a.unrealized_pnl + market_value  - accrued_interest + accrued_interest_credit,
        -- 现金结余 - 负债利息 - 冻结资金 - 做空市值  - IPO冻结(截止日前) - 配售冻结(配售是在派发日才扣款)
        a.balance_avail =   a.trade_balance + funMin(accrued_interest_credit- a.accrued_interest,0) - a.frozen_amount + 2*a.short_market_value - (a.ipo_frozen_before_allot - a.ipo_frozen_before_close) - a.placing_amount_before_allot  ,
        -- 在手资金 - 待付出资金 -负债利息  - 冻结资金 - 做空市值 - IPO冻结(截止日前）- 配售冻结(配售是在派发日前才扣款)  - IPO 融资部分冻结
        a.balance_extract = a.settle_balance - a.unsettled_to_pay + funMin(accrued_interest_credit- a.accrued_interest,0) - a.frozen_amount + 2*a.short_market_value - (a.ipo_frozen_before_allot - a.ipo_frozen_before_close) - a.placing_amount_before_allot  - ifnull(b.loan_amount,0),
        -- 用这个来算现在总共欠了多少款，需要追加保证金，或者入金
        -- 也就是说客户现在权益在减去冻结的资金（如保证金等，冻结资金等）如果为负，那就代表危险了要入金了
        a.equity = a.equity_balance  - a.margin_amt - a.frozen_amount
    where process_date = v_process_date;

    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proProductIn
-- ----------------------------
DROP PROCEDURE IF EXISTS `proProductIn`;
delimiter ;;
CREATE PROCEDURE `proProductIn`(IN  i_process_date date, 
  IN  i_account_id varchar(16), 
  IN  i_account_type int,
  IN  i_market_id int, 
  IN  i_product_id varchar(32), 
  IN  i_quantity decimal(30,10),
  IN  i_custodian_code varchar(16), 
  IN  i_custodian_account varchar(16), 
  IN  i_nominee_quantity decimal(30,10), 
  IN  i_avg_price decimal(30,10), 
  IN  i_avg_price2 decimal(30,10),
  In  i_remark varchar(128),
  In  i_update_user varchar(32), 
  In  i_update_time datetime,
  OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin
    declare v_id int default NULL; 
    declare v_process_date date default NULL; 
    declare v_balance decimal(30,10) default 0; 
    set o_ret_code = jcbms.funErrCode('ERR_SUCCESS'), o_ret_msg ="Success";

    -- check bussness date 
    select buss_date into v_process_date from sys_info; 
    if v_process_date is NULL then 
        set o_ret_code = jcbms.funErrCode('ERR_OTHER_DEFAULT'), o_ret_msg = "Bussness date not setting up";
        leave label; 
    end if; 

    if i_process_date is null  then 
        set i_process_date = v_process_date;
    end if; 

    -- check account
    if not EXISTS(select 1 from capital_account where account_id = i_account_id) then 
        set o_ret_code = jcbms.funErrCode('ERR_PARAM_ILLEGAL'), o_ret_msg = "Account not exists";
        leave label; 
    end if; 

    -- check product 
    if not EXISTS(select 1 from product where list_market_id  = i_market_id and product_id = i_product_id) then 
        set o_ret_code = jcbms.funErrCode('ERR_PARAM_ILLEGAL'), o_ret_msg = CONCAT('invalid product: ',IFNULL(i_market_id,'NULL'),' + ',IFNULL(i_product_id,'NULL'));
        leave label; 
    end if; 


    -- check quantity  
    if i_quantity < 0 then 
        set o_ret_code = jcbms.funErrCode('ERR_PARAM_ILLEGAL'), o_ret_msg = "Quantity illegal"; 
        leave label;  
    end if; 

    -- check nominee quantity
    if i_nominee_quantity > i_quantity or i_nominee_quantity <0  then 
        set o_ret_code = jcbms.funErrCode('ERR_PARAM_ILLEGAL'), o_ret_msg = "Nominee quantity illegal"; 
        leave label;  
    end if; 

    select id into v_id 
    from account_position 
    where process_date = v_process_date and 
          market_id = i_market_id and 
          product_id = i_product_id and  
          account_id = i_account_id and  
          account_type = i_account_type and 
          custodian_code = i_custodian_code and 
          custodian_account = i_custodian_account; 


    if v_id is null then 
        insert into account_position 
        (
            process_date, 
            market_id, 
            account_id, 
            account_type, 
            product_type, 
            product_id, 
            currency,
            quantity, 
            net_quantity, 
            frozen_quantity,
            avg_price1, 
            avg_price2,
            custodian_code, 
            custodian_account,
            nominee_quantity,
	    	position_cost
        )
        select 
            v_process_date,
            i_market_id, 
            i_account_id, 
            i_account_type,
            t.product_type, 
            t.product_id, 
            t.currency,
            case when i_process_date > v_process_date then 0 else i_quantity end ,  -- 未生效，所以不影响实际数量
            i_quantity, -- net_quantity 
            0, 
            round(i_avg_price,6), 
            0,
            i_custodian_code, 
            i_custodian_account,
            i_nominee_quantity,
	    	round(i_avg_price * i_quantity,2)
        from product t where t.list_market_id = i_market_id and t.product_id = i_product_id; 
    else 
       update account_position a 
       inner join product b on b.list_market_id = a.market_id and b.product_id = a.product_id 
       set 
        a.position_cost = funPositionCost(a.position_cost,a.net_quantity,i_quantity,i_avg_price),
                        /* case when net_quantity + i_quantity = 0 then 0 when abs(net_quantity + i_quantity) < abs(net_quantity) then round(position_cost*((net_quantity + i_quantity)/net_quantity),6) when abs(net_quantity + i_quantity) > abs(net_quantity) then  position_cost + round(i_avg_price * i_quantity, 6) end ,   -- 成本价只和可用相关 */
        a.quantity = a.quantity + (case when i_process_date > v_process_date then 0 else i_quantity end), 
        a.net_quantity = a.net_quantity + i_quantity, 
        a.custodian_code = i_custodian_code, 
        a.custodian_account = i_custodian_account,
        a.nominee_quantity = a.nominee_quantity + i_nominee_quantity
        where a.id = v_id; 

        update account_position a 
        inner join product b on b.list_market_id = a.market_id and b.product_id = a.product_id 
        set 
		a.avg_price1 = case when a.net_quantity <> 0 then round(a.position_cost/a.net_quantity/ifnull(b.price_factor,1),6) else 0 end,
        a.avg_price2 = 0
        where a.id = v_id; 

    end if; 

    -- getbalance ; 
    select quantity into v_balance from account_position 
        where process_date = v_process_date and 
          market_id = i_market_id and 
          product_id = i_product_id and  
          account_id = i_account_id and  
          i_account_type = i_account_type and 
          custodian_code = i_custodian_code and 
          custodian_account = i_custodian_account;  

    call proRecordProductFlow(
        v_process_date,
        i_process_date,
        i_account_id, 
        i_account_type,
        i_market_id, 
        i_product_id, 
        v_balance,
        i_quantity,
        i_custodian_code, 
        i_custodian_account, 
        i_nominee_quantity, 
        i_avg_price, 
        i_avg_price2, 
        '1', -- for product Out
        i_remark,
        i_update_user, 
        i_update_time
    );

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proProductIn_cover
-- ----------------------------
DROP PROCEDURE IF EXISTS `proProductIn_cover`;
delimiter ;;
CREATE PROCEDURE `proProductIn_cover`(IN  i_process_date date, 
  IN  i_account_id varchar(16), 
  IN  i_account_type int,
  IN  i_market_id int, 
  IN  i_product_id varchar(16), 
  IN  i_quantity decimal(30,10),
  IN  i_custodian_code varchar(16), 
  IN  i_custodian_account varchar(16), 
  IN  i_nominee_quantity decimal(30,10), 
  IN  i_avg_price decimal(30,10), 
  IN  i_avg_price2 decimal(30,10),
  In  i_remark varchar(128),
  In  i_update_user varchar(32), 
  In  i_update_time datetime,
  OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin
    declare v_id int default NULL; 
    declare v_process_date date default NULL; 
    declare v_balance decimal(30,10) default 0; 
    set o_ret_code = jcbms.funErrCode('ERR_SUCCESS'), o_ret_msg ="Success";

    
    select buss_date into v_process_date from sys_info; 
    if v_process_date is NULL then 
        set o_ret_code = jcbms.funErrCode('ERR_OTHER_DEFAULT'), o_ret_msg = "Bussness date not setting up";
        leave label; 
    end if; 

    if i_process_date is null  then 
        set i_process_date = v_process_date;
    end if; 

    
    if not EXISTS(select 1 from capital_account where account_id = i_account_id) then 
        set o_ret_code = jcbms.funErrCode('ERR_PARAM_ILLEGAL'), o_ret_msg = "Account not exists";
        leave label; 
    end if; 

    
    if not EXISTS(select 1 from product where list_market_id  = i_market_id and product_id = i_product_id) then 
        set o_ret_code = jcbms.funErrCode('ERR_PARAM_ILLEGAL'), o_ret_msg = CONCAT('invalid product: ',IFNULL(i_market_id,'NULL'),' + ',IFNULL(i_product_id,'NULL'));
        leave label; 
    end if; 


    
    if i_quantity < 0 then 
        set o_ret_code = jcbms.funErrCode('ERR_PARAM_ILLEGAL'), o_ret_msg = "Quantity illegal"; 
        leave label;  
    end if; 

    
    if i_nominee_quantity > i_quantity or i_nominee_quantity <0  then 
        set o_ret_code = jcbms.funErrCode('ERR_PARAM_ILLEGAL'), o_ret_msg = "Nominee quantity illegal"; 
        leave label;  
    end if; 

    select id into v_id 
    from account_position 
    where process_date = v_process_date and 
          market_id = i_market_id and 
          product_id = i_product_id and  
          account_id = i_account_id and  
          account_type = i_account_type and 
          custodian_code = i_custodian_code and 
          custodian_account = i_custodian_account; 


    if v_id is null then 
        insert into account_position 
        (
            process_date, 
            market_id, 
            account_id, 
            account_type, 
            product_type, 
            product_id, 
            currency,
            quantity, 
            net_quantity, 
            frozen_quantity,
            avg_price1, 
            avg_price2,
            custodian_code, 
            custodian_account,
            nominee_quantity,
	    	position_cost
        )
        select 
            v_process_date,
            i_market_id, 
            i_account_id, 
            i_account_type,
            t.product_type, 
            t.product_id, 
            t.currency,
            case when i_process_date > v_process_date then 0 else i_quantity end ,  
            i_quantity, 
            0, 
            round(i_avg_price,6), 
            0,
            i_custodian_code, 
            i_custodian_account,
            i_nominee_quantity,
	    	round(i_avg_price * i_quantity,2)
        from product t where t.list_market_id = i_market_id and t.product_id = i_product_id; 
    else 
       update account_position set 
        position_cost =case when net_quantity + i_quantity = 0 then 0 else position_cost + round(i_avg_price * i_quantity, 6) end ,  
        quantity = quantity + (case when i_process_date > v_process_date then 0 else i_quantity end), 
        net_quantity = net_quantity + i_quantity, 
        custodian_code = i_custodian_code, 
        custodian_account = i_custodian_account,
        nominee_quantity = nominee_quantity + i_nominee_quantity,
		avg_price1 = case when net_quantity <> 0 then round(position_cost/net_quantity,6) else 0 end,
        avg_price2 = 0
        where id = v_id; 
    end if; 

    
    select quantity into v_balance from account_position 
        where process_date = v_process_date and 
          market_id = i_market_id and 
          product_id = i_product_id and  
          account_id = i_account_id and  
          i_account_type = i_account_type and 
          custodian_code = i_custodian_code and 
          custodian_account = i_custodian_account;  

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proProductIpoAnnouncementDelete
-- ----------------------------
DROP PROCEDURE IF EXISTS `proProductIpoAnnouncementDelete`;
delimiter ;;
CREATE PROCEDURE `proProductIpoAnnouncementDelete`(OUT o_ret_code int,
    OUT o_ret_msg varchar(256))
label: BEGIN
declare v_done int default 0;
DECLARE v_ipo_id char(64);

DECLARE cur_req CURSOR FOR
    SELECT ipo_id FROM tmp_product_ipo_announcement;

DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1;

START TRANSACTION;

SET o_ret_code = 0, o_ret_msg = "Success";

OPEN cur_req;

temp_loop: LOOP
    FETCH cur_req INTO v_ipo_id;

    IF v_done <> 0 THEN
        LEAVE temp_loop;
    END IF;

    IF (v_ipo_id IS NULL) OR NOT EXISTS(SELECT ipo_id FROM product_ipo_announcement WHERE ipo_id=v_ipo_id) THEN
        set o_ret_code = 1, o_ret_msg = CONCAT("ipo_id(", IFNULL(v_ipo_id,"NULL"), ") is_null or not_exist");
        ROLLBACK;
        LEAVE label;
    END IF;

    DELETE FROM product_ipo_announcement WHERE ipo_id=v_ipo_id;    
END LOOP;

COMMIT;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proProductIpoAnnouncementInsert
-- ----------------------------
DROP PROCEDURE IF EXISTS `proProductIpoAnnouncementInsert`;
delimiter ;;
CREATE PROCEDURE `proProductIpoAnnouncementInsert`(OUT o_ret_code int,
    OUT o_ret_msg varchar(256))
label: BEGIN
declare v_done int default 0;
DECLARE v_id bigint(11);
DECLARE v_ipo_id char(64);
DECLARE v_list_market_id int(11);
DECLARE v_product_id varchar(32);
DECLARE v_product_name char(255);
DECLARE v_currency int(11);
DECLARE v_start_time datetime;
DECLARE v_close_time datetime;
DECLARE v_margin_start_time datetime;
DECLARE v_margin_close_time datetime;
DECLARE v_balance_frozen_start_time datetime;
DECLARE v_balance_frozen_close_time datetime;
DECLARE v_max_loan_ratio decimal(30,10);
DECLARE v_max_loan_amount decimal(30,10);
DECLARE v_interest_rate decimal(30,10);
DECLARE v_interest_day int(11);
DECLARE v_min_apply_amount decimal(30,10);
DECLARE v_max_apply_amount decimal(30,10);
DECLARE v_charge_rate decimal(30,10);
DECLARE v_charge decimal(30,10);
DECLARE v_loan_charge_rate decimal(30,10);
DECLARE v_loan_charge decimal(30,10);
DECLARE v_official_close_time datetime;
DECLARE v_allot_date date;
DECLARE v_listing_date date;
DECLARE v_issue_price decimal(30,10);
DECLARE v_min_issue_price decimal(30,10);
DECLARE v_max_issue_price decimal(30,10);
DECLARE v_issue_quantity decimal(30,10);
DECLARE v_url1 char(128);
DECLARE v_url2 char(128);
DECLARE v_url3 char(128);
DECLARE v_url4 char(128);
DECLARE v_allow_web_e_ipo varchar(1);
DECLARE v_allow_web_cancel varchar(1);
DECLARE v_remark text;
DECLARE v_app_posted varchar(1);
DECLARE v_app_posted_time datetime;
DECLARE v_result_posted varchar(1);
DECLARE v_result_posted_time datetime;
DECLARE v_refund_posted varchar(1);
DECLARE v_refund_posted_time datetime;
DECLARE v_update_user varchar(32);
DECLARE v_update_time varchar(32);
DECLARE v_apply_quantity int(11);
DECLARE v_trading_fee_rate decimal(30,10);
DECLARE v_trading_fee_standard decimal(30,10);
DECLARE v_pla_loan_ratio decimal(30,10);
DECLARE v_is_cross_trade varchar(1);
DECLARE v_settle_date date;

DECLARE cur_req CURSOR FOR
    SELECT id, ipo_id, list_market_id, product_id, product_name, currency, start_time, close_time, margin_start_time, 
        margin_close_time, balance_frozen_start_time, balance_frozen_close_time, 
        max_loan_ratio, max_loan_amount, interest_rate, interest_day, min_apply_amount, 
        max_apply_amount, charge_rate, charge, loan_charge_rate, loan_charge, official_close_time, 
        allot_date, listing_date, issue_price, min_issue_price, max_issue_price, issue_quantity, 
        url1, url2, url3, url4, allow_web_e_ipo, allow_web_cancel, remark, app_posted, app_posted_time, 
        result_posted, result_posted_time, refund_posted, refund_posted_time, update_user, update_time,
        apply_quantity,trading_fee_rate,trading_fee_standard,pla_loan_ratio,is_cross_trade,settle_date 
    FROM tmp_product_ipo_announcement;

DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1;

START TRANSACTION;

SET o_ret_code = 0, o_ret_msg = "Success";

OPEN cur_req;

temp_loop: LOOP
    FETCH cur_req INTO v_id, v_ipo_id, v_list_market_id, v_product_id, v_product_name, v_currency, v_start_time, v_close_time, 
            v_margin_start_time, v_margin_close_time, v_balance_frozen_start_time, v_balance_frozen_close_time, v_max_loan_ratio, 
            v_max_loan_amount, v_interest_rate, v_interest_day, v_min_apply_amount, v_max_apply_amount, v_charge_rate, v_charge, 
            v_loan_charge_rate, v_loan_charge, v_official_close_time, v_allot_date, v_listing_date, v_issue_price, v_min_issue_price, 
            v_max_issue_price, v_issue_quantity, v_url1, v_url2, v_url3, v_url4, v_allow_web_e_ipo, v_allow_web_cancel, v_remark,v_app_posted, 
            v_app_posted_time, v_result_posted, v_result_posted_time, v_refund_posted, v_refund_posted_time, v_update_user, v_update_time,
            v_apply_quantity,v_trading_fee_rate,v_trading_fee_standard,v_pla_loan_ratio,v_is_cross_trade,v_settle_date;
    IF v_done <> 0 THEN
        LEAVE temp_loop;
    END IF;

    IF (v_ipo_id IS NULL) OR EXISTS(SELECT ipo_id FROM product_ipo_announcement WHERE ipo_id=v_ipo_id) THEN
        set o_ret_code = 1, o_ret_msg = CONCAT("ipo_id(", IFNULL(v_ipo_id,"NULL"), ") is_null or is_exist");
        ROLLBACK;
        LEAVE label;
    END IF;

    if v_is_cross_trade <> 'Y' then 
        set v_settle_date = v_allot_date;
    end if;

    INSERT INTO product_ipo_announcement
        (ipo_id, list_market_id, product_id, product_name, currency, start_time, close_time, margin_start_time, margin_close_time, 
            balance_frozen_start_time, balance_frozen_close_time, max_loan_ratio, max_loan_amount, interest_rate, interest_day, 
            min_apply_amount, max_apply_amount, charge_rate, charge, loan_charge_rate, loan_charge, official_close_time, allot_date, 
            listing_date, issue_price, min_issue_price, max_issue_price, issue_quantity, url1, url2, url3, url4, allow_web_e_ipo, 
            allow_web_cancel, remark, app_posted, app_posted_time, result_posted, result_posted_time, refund_posted, refund_posted_time, 
            update_user, update_time,apply_quantity,trading_fee_rate,trading_fee_standard,pla_loan_ratio,is_cross_trade,settle_date)
    SELECT
        v_ipo_id, v_list_market_id, v_product_id, v_product_name, v_currency, v_start_time, v_close_time, v_margin_start_time, v_margin_close_time, 
        v_balance_frozen_start_time, v_balance_frozen_close_time, v_max_loan_ratio, v_max_loan_amount, v_interest_rate, v_interest_day, 
        v_min_apply_amount, v_max_apply_amount, v_charge_rate, v_charge, v_loan_charge_rate, v_loan_charge, v_official_close_time, 
        v_allot_date, v_listing_date, v_issue_price, v_min_issue_price, v_max_issue_price, v_issue_quantity, v_url1, v_url2, v_url3, v_url4, 
        v_allow_web_e_ipo, v_allow_web_cancel, v_remark, v_app_posted, v_app_posted_time, v_result_posted, v_result_posted_time, v_refund_posted, 
        v_refund_posted_time, v_update_user, v_update_time,v_apply_quantity,v_trading_fee_rate,v_trading_fee_standard,v_pla_loan_ratio,
        v_is_cross_trade,v_settle_date;
    
END LOOP;

COMMIT;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proProductIpoAnnouncementUpdate
-- ----------------------------
DROP PROCEDURE IF EXISTS `proProductIpoAnnouncementUpdate`;
delimiter ;;
CREATE PROCEDURE `proProductIpoAnnouncementUpdate`(OUT o_ret_code int,
    OUT o_ret_msg varchar(256))
label: BEGIN
declare v_done int default 0;
DECLARE v_id bigint(11);
DECLARE v_ipo_id char(64);
DECLARE v_orig_ipo_id char(64);
DECLARE v_list_market_id int(11);
DECLARE v_product_id varchar(32);
DECLARE v_product_name char(255);
DECLARE v_currency int(11);
DECLARE v_start_time datetime;
DECLARE v_close_time datetime;
DECLARE v_margin_start_time datetime;
DECLARE v_margin_close_time datetime;
DECLARE v_balance_frozen_start_time datetime;
DECLARE v_balance_frozen_close_time datetime;
DECLARE v_max_loan_ratio decimal(30,10);
DECLARE v_max_loan_amount decimal(30,10);
DECLARE v_interest_rate decimal(30,10);
DECLARE v_interest_day int(11);
DECLARE v_min_apply_amount decimal(30,10);
DECLARE v_max_apply_amount decimal(30,10);
DECLARE v_charge_rate decimal(30,10);
DECLARE v_charge decimal(30,10);
DECLARE v_loan_charge_rate decimal(30,10);
DECLARE v_loan_charge decimal(30,10);
DECLARE v_official_close_time datetime;
DECLARE v_allot_date date;
DECLARE v_listing_date date;
DECLARE v_issue_price decimal(30,10);
DECLARE v_min_issue_price decimal(30,10);
DECLARE v_max_issue_price decimal(30,10);
DECLARE v_issue_quantity decimal(30,10);
DECLARE v_url1 char(128);
DECLARE v_url2 char(128);
DECLARE v_url3 char(128);
DECLARE v_url4 char(128);
DECLARE v_allow_web_e_ipo varchar(1);
DECLARE v_allow_web_cancel varchar(1);
DECLARE v_remark text;
DECLARE v_app_posted varchar(1);
DECLARE v_app_posted_time datetime;
DECLARE v_result_posted varchar(1);
DECLARE v_result_posted_time datetime;
DECLARE v_refund_posted varchar(1);
DECLARE v_refund_posted_time datetime;
DECLARE v_update_user varchar(32);
DECLARE v_update_time varchar(32);
DECLARE v_apply_quantity int(11);
DECLARE v_trading_fee_rate decimal(30,10);
DECLARE v_trading_fee_standard decimal(30,10);
DECLARE v_pla_loan_ratio decimal(30,10);
DECLARE v_is_cross_trade varchar(1);
DECLARE v_settle_date date;

DECLARE cur_req CURSOR FOR
    SELECT id, ipo_id, list_market_id, product_id, product_name, currency, start_time, close_time, margin_start_time, 
        margin_close_time, balance_frozen_start_time, balance_frozen_close_time, max_loan_ratio, max_loan_amount, 
        interest_rate, interest_day, min_apply_amount, max_apply_amount, charge_rate, charge, loan_charge_rate, loan_charge, 
        official_close_time, allot_date, listing_date, issue_price, min_issue_price, max_issue_price, issue_quantity, url1, 
        url2, url3, url4, allow_web_e_ipo, allow_web_cancel, remark, app_posted, app_posted_time, result_posted, result_posted_time, 
        refund_posted, refund_posted_time, update_user, update_time,apply_quantity,trading_fee_rate,trading_fee_standard,
        pla_loan_ratio,is_cross_trade,settle_date 
    FROM tmp_product_ipo_announcement;

DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1;

START TRANSACTION;

SET o_ret_code = 0, o_ret_msg = "Success";

OPEN cur_req;

temp_loop: LOOP
    FETCH cur_req INTO v_id, v_ipo_id, v_list_market_id, v_product_id, v_product_name, v_currency, v_start_time, v_close_time, 
        v_margin_start_time, v_margin_close_time, v_balance_frozen_start_time, v_balance_frozen_close_time, v_max_loan_ratio, 
        v_max_loan_amount, v_interest_rate, v_interest_day, v_min_apply_amount, v_max_apply_amount, v_charge_rate, v_charge, 
        v_loan_charge_rate, v_loan_charge, v_official_close_time, v_allot_date, v_listing_date, v_issue_price, v_min_issue_price, 
        v_max_issue_price, v_issue_quantity, v_url1, v_url2, v_url3, v_url4, v_allow_web_e_ipo, v_allow_web_cancel, v_remark, v_app_posted, 
        v_app_posted_time, v_result_posted, v_result_posted_time, v_refund_posted, v_refund_posted_time, v_update_user, v_update_time,
        v_apply_quantity,v_trading_fee_rate,v_trading_fee_standard,v_pla_loan_ratio,v_is_cross_trade,v_settle_date;

    IF v_done <> 0 THEN
        LEAVE temp_loop;
    END IF;

    IF (v_ipo_id IS NULL) OR NOT EXISTS(SELECT ipo_id FROM product_ipo_announcement WHERE id=v_id) THEN
        set o_ret_code = 1, o_ret_msg = CONCAT("ipo_id(", IFNULL(v_ipo_id,"NULL"), ") is_null or not_exist");
        ROLLBACK;
        LEAVE label;
    END IF;

    if v_is_cross_trade <> 'Y' then 
        set v_settle_date = v_allot_date;
    end if;

    /*
    取出原ipo_id
    */
    select ipo_id
    into v_orig_ipo_id
    from product_ipo_announcement
    where id  = v_id;

    -- 更新所有的申请数据的ipo_id.
    update product_ipo_app 
    set ipo_id = v_ipo_id
    where ipo_id = v_orig_ipo_id; 

    UPDATE product_ipo_announcement SET 
        ipo_id                    = v_ipo_id,
        list_market_id            = v_list_market_id,
        product_id                = v_product_id,
        product_name              = v_product_name,
        currency                  = v_currency,
        start_time                = v_start_time,
        close_time                = v_close_time,
        margin_start_time         = v_margin_start_time,
        margin_close_time         = v_margin_close_time,
        balance_frozen_start_time = v_balance_frozen_start_time,
        balance_frozen_close_time = v_balance_frozen_close_time,
        max_loan_ratio            = v_max_loan_ratio,
        max_loan_amount           = v_max_loan_amount,
        interest_rate             = v_interest_rate,
        interest_day              = v_interest_day,
        min_apply_amount          = v_min_apply_amount,
        max_apply_amount          = v_max_apply_amount,
        charge_rate               = v_charge_rate,
        charge                    = v_charge,
        loan_charge_rate          = v_loan_charge_rate,
        loan_charge               = v_loan_charge,
        official_close_time       = v_official_close_time,
        allot_date                = v_allot_date,
        listing_date              = v_listing_date,
        issue_price               = v_issue_price,
        min_issue_price           = v_min_issue_price,
        max_issue_price           = v_max_issue_price,
        issue_quantity            = v_issue_quantity,
        url1                      = v_url1,
        url2                      = v_url2,
        url3                      = v_url3,
        url4                      = v_url4,
        allow_web_e_ipo           = v_allow_web_e_ipo,
        allow_web_cancel          = v_allow_web_cancel,
        remark                    = v_remark,
        app_posted                = v_app_posted,
        app_posted_time           = v_app_posted_time,
        result_posted             = v_result_posted,
        result_posted_time        = v_result_posted_time,
        refund_posted             = v_refund_posted,
        refund_posted_time        = v_refund_posted_time,
        update_user               = v_update_user,
        update_time               = v_update_time, 
        apply_quantity            = v_apply_quantity,
        trading_fee_rate          = v_trading_fee_rate,
        trading_fee_standard      = v_trading_fee_standard,
        pla_loan_ratio            = v_pla_loan_ratio,
        is_cross_trade            = v_is_cross_trade,
        settle_date               = v_settle_date      
        WHERE id = v_id;
END LOOP;

COMMIT;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proProductIpoAppDoRefund
-- ----------------------------
DROP PROCEDURE IF EXISTS `proProductIpoAppDoRefund`;
delimiter ;;
CREATE PROCEDURE `proProductIpoAppDoRefund`(IN  i_ipo_id varchar(64),
    In  i_update_user varchar(32), 
    In  i_update_time datetime,
    OUT o_ret_code int,
    OUT o_ret_msg varchar(256))
label: BEGIN
DECLARE v_done int DEFAULT 0;
DECLARE v_account_id char(16);
DECLARE v_account_type int;
DECLARE v_list_market_id int;
DECLARE v_product_id varchar(32);
DECLARE v_currency int;
DECLARE v_loan_amount decimal(30,10);
DECLARE v_interest decimal(30,10);
DECLARE v_allot_qty INT;
DECLARE v_allot_price decimal(30,10);
DECLARE v_refund_amount decimal(30,10);
DECLARE v_process_date date;
DECLARE v_qty BIGINT DEFAULT 0;
DECLARE v_px  DECIMAL(30,3) DEFAULT 0;
DECLARE v_custodian_code    VARCHAR(16);
DECLARE v_custodian_account VARCHAR(16);
DECLARE v_amount decimal(30,10);
DECLARE v_sub_status int;
DECLARE v_is_cross_trade varchar(1);
DECLARE v_allot_date date;
DECLARE v_settle_date date;

DECLARE v_error int;


DECLARE cur_req CURSOR FOR
    SELECT a.account_id, b.account_type, a.list_market_id, a.product_id, a.currency, a.loan_amount, a.interest, a.allot_qty, a.allot_price, a.refund_amount, a.quantity,a.amount,a.sub_status
    FROM product_ipo_app  a
    inner join capital_account b on a.account_id = b.account_id
    WHERE a.ipo_id = i_ipo_id and ifnull(a.app_posted,'') = 'Y' and ifnull(a.result_posted,'') = 'Y' and ifnull(a.refund_posted,'') <> 'Y';

DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1;

declare CONTINUE HANDLER FOR SQLEXCEPTION
    begin
        GET DIAGNOSTICS CONDITION 1
        o_ret_msg = MESSAGE_TEXT,
        o_ret_code = RETURNED_SQLSTATE; 
        set v_error = 1;
    end; 
set v_error = 0 ; 
START TRANSACTION;

SET o_ret_code = 0, o_ret_msg = "Success";

IF NOT EXISTS(SELECT distinct 1 from product_ipo_app WHERE ipo_id=i_ipo_id and ifnull(app_posted,'') = 'Y' and ifnull(result_posted,'') = 'Y' and ifnull(refund_posted,'') <> 'Y') THEN
    set o_ret_code = 1, o_ret_msg = "No customers need to posted";
    ROLLBACK;
    LEAVE label;
END IF;

-- IF EXISTS(SELECT distinct 1 FROM product_ipo_app WHERE ipo_id=i_ipo_id AND a.sub_status = i_sub_status and ifnull(app_posted,'')='N')THEN
--     set o_ret_code = 1, o_ret_msg = "curr action has been completed";
--     ROLLBACK;
--     LEAVE label;
-- END IF; 

-- IF EXISTS(SELECT distinct 1 FROM product_ipo_app WHERE ipo_id=i_ipo_id AND a.sub_status = i_sub_status and ifnull(result_posted,'')='N')THEN
--     set o_ret_code = 1, o_ret_msg = "prev action was not completed";
--     ROLLBACK;
--     LEAVE label;
-- END IF;

-- IF NOT EXISTS(SELECT 1 FROM product_ipo_announcement WHERE ipo_id=i_ipo_id and sub_status = i_sub_status AND ifnull(result_posted,'')='Y')THEN
--     set o_ret_code = 1, o_ret_msg = "prev action was not completed";
--     ROLLBACK;
--     LEAVE label;
-- END IF;

SELECT buss_date INTO v_process_date FROM sys_info;

SELECT issue_price,allot_date,settle_date,is_cross_trade
INTO v_px,v_allot_date,v_settle_date,v_is_cross_trade FROM product_ipo_announcement WHERE ipo_id = i_ipo_id;

-- select v_px,v_allot_date,v_settle_date,v_is_cross_trade;
if v_is_cross_trade <> 'Y' then 
    set v_settle_date = v_process_date;
end if ; 

OPEN cur_req;

temp_loop: LOOP
    FETCH cur_req INTO v_account_id, v_account_type, v_list_market_id, v_product_id, v_currency, v_loan_amount, v_interest, v_allot_qty, v_allot_price, v_refund_amount, v_qty,v_amount,v_sub_status;

    IF v_done <> 0 THEN
        LEAVE temp_loop;
    END IF;


    if v_list_market_id = 2 THEN
        SELECT custodian_code,custodian_account INTO v_custodian_code,v_custodian_account FROM market where market_id = v_list_market_id;
    else 
        SELECT custodian_code,custodian_account INTO v_custodian_code,v_custodian_account FROM account_type_custodian WHERE market_id=v_list_market_id AND account_type=v_account_type;
    end if;

    -- SELECT custodian_code,custodian_account INTO v_custodian_code,v_custodian_account FROM account_type_custodian WHERE market_id=v_list_market_id AND account_type=v_account_type;
    
    -- IF IFNULL(v_allot_price, 0) = 0 THEN
    --     set o_ret_code = 1, o_ret_msg = CONCAT("allot_price is illegal with account_id=", v_account_id);
    --     ROLLBACK;
    --     LEAVE label;
    -- END IF;

    IF IFNULL(v_allot_price, 0) <> 0 THEN
        if v_sub_status = 1 then 
            -- check 
            IF v_allot_qty > v_qty then 
                set o_ret_code = 1, o_ret_msg = concat("Allot quantity is illegal,account[",v_account_id,"], apply quantity[",v_qty,"],allot quantity[",v_allot_qty,"]");
                ROLLBACK;
                LEAVE label;
            end if;
            
            if v_refund_amount <> ( v_amount - (v_allot_price * v_allot_qty + 
                                                round(v_allot_price * v_allot_qty*1/100,2)+ 
                                                round(v_allot_price * v_allot_qty*0.0027/100,2)+ 
                                                round(v_allot_price * v_allot_qty*0.005/100,2) + 
                                                round(v_allot_price * v_allot_qty*0.00015/100,2)) ) then
                set o_ret_code = 1, 
                    o_ret_msg = concat("Refund amount is illegal,account[",v_account_id,"],expected amount[",( v_amount - (v_allot_price * v_allot_qty + round(v_allot_price * v_allot_qty*1/100,2)+ round(v_allot_price * v_allot_qty*0.0027/100,2) + round(v_allot_price * v_allot_qty*0.005/100,2)) ),"],refund amount[",v_refund_amount,"]");
                ROLLBACK;
                LEAVE label;
            end if; 
            -- check end
            -- if v_refund_amount <> (v_amount - round(v_allot_price * v_allot_qty * 1.010077,2)) then
            --     set o_ret_code = 1, o_ret_msg = concat("Refund amount is illegal,account[",v_account_id,"],expected amount[",(v_amount - round(v_allot_price * v_allot_qty * 1.010077,2)),"],refund amount[",v_refund_amount,"]");
            --     ROLLBACK;
            --     LEAVE label;
            -- end if; 
            -- check end

            IF v_refund_amount <> 0 THEN
                call proCashIn (v_process_date,v_account_id,v_account_type,v_currency,v_refund_amount,1,CONCAT("IPO Refund ",       i_ipo_id," Qty: ",v_qty," Alloted: ",v_allot_qty," @",v_px),'remark2','','','','','','','','',v_list_market_id,v_product_id, 'ipo_refund',i_ipo_id,v_custodian_code,v_custodian_account, i_update_user,i_update_time,o_ret_code,o_ret_msg);
                IF o_ret_code <> 0 THEN
                    ROLLBACK;
                    LEAVE label;
                END IF;
            END IF;
            IF v_loan_amount <> 0 THEN
                call proCashOut(v_process_date,v_account_id,v_account_type,v_currency,v_loan_amount,  1,CONCAT("IPO Loan Return ",  i_ipo_id," Qty: ",v_qty," Alloted: ",v_allot_qty," @",v_px),'remark2','','','','','','','','',v_list_market_id,v_product_id, 'ipo_loan_recv',i_ipo_id, v_custodian_code,v_custodian_account,i_update_user,i_update_time,o_ret_code,o_ret_msg);
                IF o_ret_code <> 0 THEN
                    ROLLBACK;
                    LEAVE label;
                END IF;
            END IF;
            IF v_interest <> 0 THEN
                call proCashOut(v_process_date,v_account_id,v_account_type,v_currency,v_interest,     1,CONCAT("IPO Loan Interest ",i_ipo_id," Qty: ",v_qty," Alloted: ",v_allot_qty," @",v_px),'remark2','','','','','','','','',v_list_market_id,v_product_id, 'ipo_interest',i_ipo_id, v_custodian_code,v_custodian_account,i_update_user,i_update_time,o_ret_code,o_ret_msg);
                IF o_ret_code <> 0 THEN
                    ROLLBACK;
                    LEAVE label;
                END IF;
            END IF;

            IF v_allot_qty <> 0 THEN
            call proProductIn(v_process_date,v_account_id,v_account_type,v_list_market_id,v_product_id,v_allot_qty,v_custodian_code,v_custodian_account,v_allot_qty,0/*此处传0即可正常处理*/,NULL,CONCAT("Successful IPO @",v_px),i_update_user,i_update_time,o_ret_code,o_ret_msg);
                IF o_ret_code <> 0 THEN
                    ROLLBACK;
                    LEAVE label;
                END IF;
            END IF;
            update product_ipo_app set refund_posted = 'Y',refund_posted_time = now() where ipo_id = i_ipo_id and account_id = v_account_id;
        elseif v_sub_status = 2 THEN
            IF v_amount <> 0 and v_allot_qty <> 0 THEN
                call proProductIn(v_settle_date,v_account_id,v_account_type,v_list_market_id,v_product_id,v_allot_qty,
                    v_custodian_code,v_custodian_account,v_allot_qty,0/*此处传0即可正常处理*/,NULL,
                    CONCAT(v_product_id," Placing Order@",v_allot_price),i_update_user,i_update_time,o_ret_code,o_ret_msg);
                IF o_ret_code <> 0 THEN
                    ROLLBACK;
                    LEAVE label;
                END IF;

                call proCashOut(v_settle_date,v_account_id,v_account_type,v_currency,v_amount,  1,
                    CONCAT(v_product_id," Placing Order@",v_allot_qty),'remark2','','','','','','','','',
                    v_list_market_id,v_product_id, 'ipo_loan_recv',i_ipo_id, v_custodian_code,v_custodian_account,i_update_user,i_update_time,o_ret_code,o_ret_msg);
                IF o_ret_code <> 0 THEN
                    ROLLBACK;
                    LEAVE label;
                END IF;
            END IF;

            -- IF v_allot_qty <> 0 THEN
            --     call proProductIn(NULL,v_account_id,v_account_type,v_list_market_id,v_product_id,v_allot_qty,
            --         v_custodian_code,v_custodian_account,v_allot_qty,0/*此处传0即可正常处理*/,NULL,
            --         CONCAT(v_product_id," Placing Order@",v_allot_price),i_update_user,i_update_time,o_ret_code,o_ret_msg);
            --     IF o_ret_code <> 0 THEN
            --         ROLLBACK;
            --         LEAVE label;
            --     END IF;
            -- END IF;
            update product_ipo_app set refund_posted = 'Y',refund_posted_time = now() where ipo_id = i_ipo_id and account_id = v_account_id;
        else
            set o_ret_code = 1, o_ret_msg = concat('invalid sub_status ',v_account_id,' : ',v_sub_status);
            ROLLBACK;
            LEAVE label;
        END IF;
    else 
        set o_ret_code = 1, o_ret_msg = CONCAT("allot_price is illegal with account_id=", v_account_id);
        ROLLBACK;
        LEAVE label;
    END IF;

END LOOP;

-- 修正持仓成本 = 中签价*中签数量
-- 成本价= 中签价
update account_position 
set avg_price1 = v_allot_price, 
    position_cost = v_allot_price*net_quantity
where process_date = v_process_date and market_id = v_list_market_id and product_id = v_product_id; 

-- 更新状态为已派发
UPDATE product_ipo_announcement SET refund_posted = 'Y', refund_posted_time = now() WHERE ipo_id=i_ipo_id;

if v_error <> 0  then 
    rollback; 
else 
    -- 如果不捕获v_error,test1里会插入a; 
    set o_ret_code = 0; 
    set o_ret_msg = "派发处理完成"; 
    commit;
end if ;

END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proProductOut
-- ----------------------------
DROP PROCEDURE IF EXISTS `proProductOut`;
delimiter ;;
CREATE PROCEDURE `proProductOut`(IN  i_process_date varchar(16), 
  IN  i_account_id varchar(16), 
  IN  i_account_type int,
  IN  i_market_id int, 
  IN  i_product_id varchar(32), 
  IN  i_quantity decimal(30,10),
  IN  i_custodian_code varchar(16), 
  IN  i_custodian_account varchar(16), 
  IN  i_nominee_quantity decimal(30,10), 
  IN  i_avg_price decimal(30,10), 
  IN  i_avg_price2 decimal(30,10),
  In  i_remark varchar(128),
  In  i_update_user varchar(32), 
  In  i_update_time datetime,
  OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin
    DECLARE v_check_quantity decimal(30,10) DEFAULT NULL;
    DECLARE v_check_net_quantity decimal(30,10) DEFAULT NULL;
    DECLARE v_account_id_country VARCHAR(32);
    DECLARE v_insufficient_position_enum VARCHAR(128);
    declare v_id int default NULL; 
    declare v_process_date date default NULL; 
    declare v_balance decimal(30,10) default 0; 
    set o_ret_code = jcbms.funErrCode('ERR_SUCCESS'), o_ret_msg ="Success"; 

    -- check bussness date 
    select buss_date into v_process_date from sys_info; 
    if v_process_date is NULL then 
        set o_ret_code = jcbms.funErrCode('ERR_OTHER_DEFAULT'), o_ret_msg = "Bussness date not setting up"; 
        leave label; 
    end if; 

    if i_process_date is null then 
        set i_process_date = v_process_date; 
    end if; 

    -- check account
    if not EXISTS(select 1 from capital_account where account_id = i_account_id) then 
        set o_ret_code = jcbms.funErrCode('ERR_PARAM_ILLEGAL'), o_ret_msg = "Account not exists"; 
        leave label; 
    end if; 

    -- check product 
    if not EXISTS(select 1 from product where list_market_id  = i_market_id and product_id = i_product_id) then 
        set o_ret_code = jcbms.funErrCode('ERR_PARAM_ILLEGAL'), o_ret_msg = CONCAT('invalid product: ',IFNULL(i_market_id,'NULL'),' + ',IFNULL(i_product_id,'NULL'));
        leave label; 
    end if; 

    /* SELECT (CASE account_class WHEN'1'THEN party_country when '2' then party_country WHEN'3'THEN photo_country ELSE NULL END) INTO v_account_id_country FROM jcbms.account_profile WHERE account_id=i_account_id;
    IF v_account_id_country IS NULL THEN
        SET o_ret_code = jcbms.funErrCode('ERR_LOGIC'), o_ret_msg = "unknown account_id country";
        LEAVE label;
    END IF; */
    -- SET v_insufficient_position_enum = IF(v_account_id_country='CHN','ERR_ACCOUNT_INSUFFICIENT_POSITION_CHN','ERR_ACCOUNT_INSUFFICIENT_POSITION_NON_CHN');

    /* SELECT quantity,net_quantity INTO v_check_quantity,v_check_net_quantity
    FROM jcbms.account_position
    WHERE process_date = v_process_date AND
          market_id = i_market_id AND
          product_id = i_product_id AND
          account_id = i_account_id AND
          account_type = i_account_type AND
          custodian_code = i_custodian_code AND
          custodian_account = i_custodian_account;
    IF (v_check_quantity IS NULL) OR (v_check_net_quantity IS NULL) THEN
        SET o_ret_code = jcbms.funErrCode(v_insufficient_position_enum), o_ret_msg = "no position or invalid quantity";
        LEAVE label;
    END IF; */

/* 
    IF v_process_date = i_process_date and  jcbms.funMAX(jcbms.funMAX(v_check_quantity,v_check_net_quantity), 0) < IFNULL(i_quantity,0) THEN
        SET o_ret_code = jcbms.funErrCode(v_insufficient_position_enum), o_ret_msg = "insufficient position";
        LEAVE label;
    END IF; */

    set i_quantity = -1*i_quantity; 
    set i_nominee_quantity = -1*i_nominee_quantity; 

    -- check quantity  
    if i_quantity > 0 then 
        set o_ret_code = jcbms.funErrCode('ERR_PARAM_ILLEGAL'), o_ret_msg = "Quantity illegal";
        leave label;  
    end if; 

    -- check nominee quantity
    /* if i_nominee_quantity < i_quantity or i_nominee_quantity >0  then 
        set o_ret_code = 1, o_ret_msg = "Nominee quantity illegal"; 
         
        leave label;  
    end if;  */

    set i_nominee_quantity = i_quantity;

    select id into v_id 
    from account_position 
    where process_date = v_process_date and 
          market_id = i_market_id and 
          product_id = i_product_id and  
          account_id = i_account_id and  
          account_type = i_account_type and
          custodian_code = i_custodian_code and 
          custodian_account = i_custodian_account;

    if v_id is null then 
        insert into account_position 
        (
            process_date, 
            market_id, 
            account_id, 
            account_type, 
            product_type, 
            product_id, 
            currency,
            quantity, 
            net_quantity, 
            frozen_quantity,
            avg_price1, 
            avg_price2,
            custodian_code, 
            custodian_account, 
            position_cost, 
            nominee_quantity
        )
        select 
        
            v_process_date,
            i_market_id, 
            i_account_id, 
            i_account_type,
            t.product_type, 
            t.product_id, 
            t.currency,
            case when i_process_date > v_process_date then 0 else i_quantity end ,  
            i_quantity, 
            0,
            round(i_avg_price,6),  -- i_avg_price, 
            0,  -- i_avg_price2,
            i_custodian_code, 
            i_custodian_account, 
            round(i_avg_price*i_quantity,2), -- 没有持仓还可以转出持仓吗？成本为0, 
            i_nominee_quantity
        from product t where t.list_market_id = i_market_id and t.product_id = i_product_id; 
    else 
       update account_position a
       inner join product b on b.list_market_id = a.market_id and b.product_id = a.product_id 
       set 
        -- avg_price1 = (avg_price1*quantity+i_avg_price*i_quantity)/(quantity+i_quantity),
        -- avg_price2 = (avg_price2*quantity+i_avg_price*i_quantity)/(quantity+i_quantity),
        a.position_cost = funPositionCost(a.position_cost,a.net_quantity,i_quantity,i_avg_price),
                /* case when net_quantity + i_quantity = 0 then 0 when abs(net_quantity + i_quantity) < abs(net_quantity) then round(position_cost*((net_quantity + i_quantity)/net_quantity),6) when abs(net_quantity + i_quantity) > abs(net_quantity) then  position_cost + round(i_avg_price * i_quantity, 6) end ,   -- 成本价只和可用相关 */
        a.quantity = a.quantity + (case when i_process_date > v_process_date then 0 else i_quantity end) , 
        a.net_quantity = a.net_quantity + i_quantity, 
        a.custodian_code = i_custodian_code, 
        a.custodian_account = i_custodian_account
        where a.id = v_id; 

        update account_position a
        inner join product b on b.list_market_id = a.market_id and b.product_id = a.product_id 
        set 
        a.avg_price1 = case when a.net_quantity <> 0 then round(a.position_cost/a.net_quantity/ifnull(b.price_factor,1),6) else 0 end,
        a.avg_price2 = 0
        where a.id = v_id; 

        update account_position a 
        set a.nominee_quantity = funMin(a.quantity, a.nominee_quantity)
        where a.id = v_id; 
    end if; 

    -- getbalance ; 
    select quantity into v_balance from account_position 
        where process_date = v_process_date and 
          market_id = i_market_id and 
          product_id = i_product_id and  
          account_id = i_account_id and  
          i_account_type = i_account_type and
          custodian_code = i_custodian_code and 
          custodian_account = i_custodian_account;

    call proRecordProductFlow(
        v_process_date,
        i_process_date,
        i_account_id, 
        i_account_type,
        i_market_id, 
        i_product_id, 
        v_balance,
        -1*i_quantity,
        i_custodian_code, 
        i_custodian_account, 
        -1*i_nominee_quantity, 
        i_avg_price, 
        i_avg_price2, 
        '2', -- for product Out
        i_remark,
        i_update_user, 
        i_update_time
    );

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proProductOut_cover
-- ----------------------------
DROP PROCEDURE IF EXISTS `proProductOut_cover`;
delimiter ;;
CREATE PROCEDURE `proProductOut_cover`(IN  i_process_date varchar(16), 
  IN  i_account_id varchar(16), 
  IN  i_account_type int,
  IN  i_market_id int, 
  IN  i_product_id varchar(16), 
  IN  i_quantity decimal(30,10),
  IN  i_custodian_code varchar(16), 
  IN  i_custodian_account varchar(16), 
  IN  i_nominee_quantity decimal(30,10), 
  IN  i_avg_price decimal(30,10), 
  IN  i_avg_price2 decimal(30,10),
  In  i_remark varchar(128),
  In  i_update_user varchar(32), 
  In  i_update_time datetime,
  OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin
    DECLARE v_check_quantity decimal(30,10) DEFAULT NULL;
    DECLARE v_check_net_quantity decimal(30,10) DEFAULT NULL;
    DECLARE v_account_id_country VARCHAR(32);
    DECLARE v_insufficient_position_enum VARCHAR(128);
    declare v_id int default NULL; 
    declare v_process_date date default NULL; 
    declare v_balance decimal(30,10) default 0; 
    set o_ret_code = jcbms.funErrCode('ERR_SUCCESS'), o_ret_msg ="Success"; 

    
    select buss_date into v_process_date from sys_info; 
    if v_process_date is NULL then 
        set o_ret_code = jcbms.funErrCode('ERR_OTHER_DEFAULT'), o_ret_msg = "Bussness date not setting up"; 
        leave label; 
    end if; 

    if i_process_date is null then 
        set i_process_date = v_process_date; 
    end if; 

    
    if not EXISTS(select 1 from capital_account where account_id = i_account_id) then 
        set o_ret_code = jcbms.funErrCode('ERR_PARAM_ILLEGAL'), o_ret_msg = "Account not exists"; 
        leave label; 
    end if; 

    
    if not EXISTS(select 1 from product where list_market_id  = i_market_id and product_id = i_product_id) then 
        set o_ret_code = jcbms.funErrCode('ERR_PARAM_ILLEGAL'), o_ret_msg = CONCAT('invalid product: ',IFNULL(i_market_id,'NULL'),' + ',IFNULL(i_product_id,'NULL'));
        leave label; 
    end if; 

    SELECT (CASE account_class WHEN'1'THEN party_country when '2' then party_country WHEN'3'THEN photo_country ELSE NULL END) INTO v_account_id_country FROM jcbms.account_profile WHERE account_id=i_account_id;
    IF v_account_id_country IS NULL THEN
        SET o_ret_code = jcbms.funErrCode('ERR_LOGIC'), o_ret_msg = "unknown account_id country";
        LEAVE label;
    END IF;
    SET v_insufficient_position_enum = IF(v_account_id_country='CHN','ERR_ACCOUNT_INSUFFICIENT_POSITION_CHN','ERR_ACCOUNT_INSUFFICIENT_POSITION_NON_CHN');

    



    set i_quantity = -1*i_quantity; 
    set i_nominee_quantity = -1*i_nominee_quantity; 

    
    if i_quantity > 0 then 
        set o_ret_code = jcbms.funErrCode('ERR_PARAM_ILLEGAL'), o_ret_msg = "Quantity illegal";
        leave label;  
    end if; 

    
    

    set i_nominee_quantity = i_quantity;

    select id into v_id 
    from account_position 
    where process_date = v_process_date and 
          market_id = i_market_id and 
          product_id = i_product_id and  
          account_id = i_account_id and  
          account_type = i_account_type and
          custodian_code = i_custodian_code and 
          custodian_account = i_custodian_account;

    if v_id is null then 
        insert into account_position 
        (
            process_date, 
            market_id, 
            account_id, 
            account_type, 
            product_type, 
            product_id, 
            currency,
            quantity, 
            net_quantity, 
            frozen_quantity,
            avg_price1, 
            avg_price2,
            custodian_code, 
            custodian_account, 
            position_cost, 
            nominee_quantity
        )
        select 
        
            v_process_date,
            i_market_id, 
            i_account_id, 
            i_account_type,
            t.product_type, 
            t.product_id, 
            t.currency,
            case when i_process_date > v_process_date then 0 else i_quantity end ,  
            i_quantity, 
            0,
            round(i_avg_price,6),  
            0,  
            i_custodian_code, 
            i_custodian_account, 
            round(i_avg_price*i_quantity,2), 
            i_nominee_quantity
        from product t where t.list_market_id = i_market_id and t.product_id = i_product_id; 
    else 
       update account_position set 
        
        
        position_cost = case when net_quantity = 0 then 0 else round(position_cost*((net_quantity + i_quantity)/net_quantity),6) end ,   
        quantity = quantity + (case when i_process_date > v_process_date then 0 else i_quantity end) , 
        net_quantity = net_quantity + i_quantity, 
        custodian_code = i_custodian_code, 
        custodian_account = i_custodian_account,
        
        avg_price1 = case when net_quantity <> 0 then round(position_cost/net_quantity,6) else 0 end,
        avg_price2 = 0
        where id = v_id; 

        update account_position a 
        set a.nominee_quantity = funMin(a.quantity, a.nominee_quantity)
        where a.id = v_id; 
    end if; 

    
    select quantity into v_balance from account_position 
        where process_date = v_process_date and 
          market_id = i_market_id and 
          product_id = i_product_id and  
          account_id = i_account_id and  
          i_account_type = i_account_type and
          custodian_code = i_custodian_code and 
          custodian_account = i_custodian_account;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proProductTmpAccountTradeDetail
-- ----------------------------
DROP PROCEDURE IF EXISTS `proProductTmpAccountTradeDetail`;
delimiter ;;
CREATE PROCEDURE `proProductTmpAccountTradeDetail`(OUT o_ret_code int,
    OUT o_ret_msg char(128))
label: BEGIN

    declare v_process_date date default null;

    -- 校验系统状态是否正常
    if exists (select 1 from import_account_trade_detail where list_market_id not in ('2','16')) and 
        exists (select 1 from sys_info where sys_status = '1') then 
        set o_ret_code = 1; 
        set o_ret_msg = 'Please set system status to be clearing.'; 
        leave label; 
    end if; 

    start transaction;

    select buss_date into v_process_date from sys_info;

-- 汇总成交
    insert into tmp_account_trade
    (
        process_date,
        trade_date ,
        settle_date,
        trade_id,
        business_department ,
        department_trading_group ,
        account_id,
        account_type ,
        market_id ,
        list_market_id ,
        product_id ,
        product_description ,
        product_type ,
        product_sub_type,
        quote_currency,
        clearing_currency ,
        exchange_rate,
        buy_sell ,
        quantity,
        avg_price,
        trade_amount ,
        net_amount ,
        open_close ,
        hedge_flag,
        call_put ,
        strike_price ,
        contract_date ,
        input_channel,
        remark,
        num_of_trades ,
        order_no,
        order_date ,
        update_time,
        update_user,
        custodian_code,
        custodian_account,
        broker,
        is_odd_lot
    )
    select 
        v_process_date,
        a.trade_date ,
        max(a.settle_date),
         concat(date_format(v_process_date, "%Y%m%d"), right(concat('0000000000',funGenerateID(v_process_date)),10)),
        max(a.business_department) ,
        max(a.department_trading_group) ,
        a.account_id,
        a.account_type ,
        max(a.market_id) ,
        a.list_market_id ,
        a.product_id ,
        max(a.product_description) ,
        max(a.product_type) ,
        max(a.product_sub_type),
        max(a.quote_currency),
        max(a.clearing_currency) ,
        max(a.exchange_rate),
        a.buy_sell ,
        ifnull(sum(exec_quantity), 0),
        ifnull(sum(a.trade_amount) / sum(exec_quantity), 0),
        ifnull(round(sum(a.trade_amount),2),0) ,
        ifnull(round(sum(a.net_amount),2), 0),
        max(a.open_close) ,
        max(a.hedge_flag),
        max(a.call_put) ,
        max(a.strike_price) ,
        max(a.contract_date) ,
        max(a.input_channel),
        max(a.remark),
        count(*) ,
        max(a.order_no),
        max(a.order_date) ,
        now(),
        'JC_Clearing',
        a.custodian_code,
        a.custodian_account,
        a.broker,
        max(is_odd_lot)
    from tmp_account_trade_detail a 
    inner join market b on a.list_market_id = b.market_id 
    group by 
        case  b.group_by_order when 'Y' then a.order_no else '0' end,
        trade_date ,
        account_id,
        account_type ,
        list_market_id ,
        product_id ,
        buy_sell ,
        case  b.group_by_order when 'Y' then a.order_date else '' end,
        input_channel,
        a.custodian_code,
        a.custodian_account,
        a.broker;

    delete from generate_exec_id; 

    /*
    update tmp_account_trade_detail a, tmp_account_trade b
    set a.trade_id = b.trade_id,
        a.trade_exec_id = funGenerateExecID(b.trade_id)
    where a.order_date = b.order_date and
          a.order_no = b.order_no ;
    */

    -- for group by order_no 
    update tmp_account_trade_detail a
    inner join tmp_account_trade b on  a.order_date = b.order_date and a.order_no = b.order_no 
    inner join market c on a.list_market_id = c.market_id and c.group_by_order  = 'Y'
    set a.trade_id = b.trade_id,
        a.trade_exec_id = funGenerateExecID(b.trade_id)
    where a.order_no <> '0'  and a.order_no <> '';
    
    update tmp_account_trade SET broker = '' WHERE IFNULL(broker,'') = '';
    update tmp_account_trade_detail SET broker = '' WHERE IFNULL(broker,'') = '';
    -- for not group by order_no; 
    update tmp_account_trade_detail a
    inner join tmp_account_trade b on a.trade_date = b.trade_date and a.account_id = b.account_id and 
                                a.account_type = b.account_type and a.list_market_id = b.list_market_id and 
                                a.product_id = b.product_id and a.buy_sell = b.buy_sell and 
                                a.input_channel = b.input_channel and 
                                ifnull(a.broker,'') = b.broker and ifnull(a.custodian_code,'') = b.custodian_code and 
                                ifnull(a.custodian_account,'') = b.custodian_account
    inner join market c on a.list_market_id = c.market_id 
    set a.trade_id = b.trade_id,
        a.trade_exec_id = funGenerateExecID(b.trade_id)
    where c.group_by_order  <> 'Y' or a.order_no = '0' or a.order_no = ''; 


    -- insert into tmp_account_trade_detail_log select *from tmp_account_trade_detail; 

    -- 交易明细导入到系统中
    insert into account_trade_detail
    select 
        null,
        a.trade_id ,   
        a.trade_exec_id,
        a.order_date,
        a.order_no,
        v_process_date,
        a.trade_date,
        a.settle_date,
        a.exec_time,
        a.exec_no,
        a.market_id,
        a.exchange_ref_no,
        a.exec_broker,
        a.contra_broker,
        a.exec_quantity,
        a.exec_price,
        now(),
        'JC_clearing' ,
        0.0,      -- commission
        0.0,       -- charges 
        1, -- num_of_trades
        trade_amount,
        net_amount,
        is_odd_lot
    from 
    tmp_account_trade_detail a ;

    insert into account_order_detail
    select 
        null,
        process_date,
        order_no,
        order_date ,
        order_time ,
        business_department,
        department_trading_group,
        account_id,
        account_type,  
        trade_date,
        settle_date,   
        market_id,
        list_market_id,
        product_type,
        product_sub_type,
        product_id,
        product_description,
        quote_currency,
        clearing_currency,
        exchange_rate,
        buy_sell,
        order_price,
        order_quantity,
        trade_quantity ,
        status,
        open_close ,
        hedge_flag ,
        call_put,
        strike_price,
        contract_date ,
        input_channel,
        remark,
        now(),
        'JC_clearing',
        is_odd_lot
    from tmp_account_trade_detail;  
   

    /*重新整理tmp_account_trade_detail*/
    -- 需要汇总的成交标记为1(如果order no 没有传那么就不进行分组)
    update tmp_account_trade_detail a 
    inner join  market b on a.market_id = b.market_id and b.group_by_price = 'Y'
        set a.code = 1  
    where a.order_no <> '' and  a.order_no <> '0'; 

    -- 按照input channel 如果是暗盘也进行分笔计算 
    -- update tmp_account_trade_detail a  set a.code = 1 where a.input_channel = '5';

    drop temporary table if exists tmp_account_trade_detail2; 
    create temporary table tmp_account_trade_detail2 select *from tmp_account_trade_detail where 1=2; 
    insert into 
        tmp_account_trade_detail2
        (
            trade_id,
            trade_exec_id,
            process_date,
            order_no,
            order_date,
            order_time,
            business_department,
            department_trading_group,
            account_id,
            account_type,
            trade_date,
            settle_date,
            market_id,
            list_market_id,
            product_type,
            product_sub_type,
            product_id,
            product_description,
            quote_currency,
            clearing_currency,
            exchange_rate,
            buy_sell,
            order_price,
            order_quantity,
            trade_quantity,
            status,
            open_close,
            hedge_flag,
            call_put,
            strike_price,
            contract_date,
            input_channel,
            remark,
            exec_time,
            exec_no,
            exchange_ref_no,
            exec_broker,
            contra_broker,
            exec_quantity,
            exec_price,
            code,
            mark,
            num_of_trades,
            trade_amount,
            net_amount,
            custodian_code,
            custodian_account,
            broker,
            is_odd_lot
        )
        select 
            trade_id,
            max(trade_exec_id),
            max(process_date),
            max(order_no),
            max(order_date),
            max(order_time),
            max(business_department),
            max(department_trading_group),
            max(account_id),
            max(account_type),
            max(trade_date),
            max(settle_date),
            max(market_id),
            max(list_market_id),
            max(product_type),
            max(product_sub_type),
            max(product_id),
            max(product_description),
            max(quote_currency),
            max(clearing_currency),
            max(exchange_rate),
            max(buy_sell),
            max(order_price),
            max(order_quantity),
            max(trade_quantity),
            max(status),
            max(open_close),
            max(hedge_flag),
            max(call_put),
            max(strike_price),
            max(contract_date),
            max(input_channel),
            max(remark),
            max(exec_time),
            max(exec_no),
            max(exchange_ref_no),
            max(exec_broker),
            max(contra_broker),
            sum(exec_quantity),
            ifnull(sum(exec_quantity * exec_price) / sum(exec_quantity), 0),
            '0',
            max(mark),
            count(*) , -- num_of_trades 如果是暗盘，num_of_trades就是1；如果是美股就是真实的num_of_trades; 
            sum(trade_amount), 
            sum(net_amount),
            custodian_code,
            custodian_account,
            broker,
            max(is_odd_lot)
        from tmp_account_trade_detail 
        group by 
            trade_id,
            case code  when 1 then exec_price else trade_exec_id end,
            custodian_code,
            custodian_account,
            broker;
   
    
    delete from  tmp_account_trade_detail ;
    insert into tmp_account_trade_detail select * from  tmp_account_trade_detail2;



    /* -- 不需要进行汇总；
    group by 
        trade_id,
         case code  when 1 then exec_price else trade_exec_id end; 
    */

       
    insert into account_trade
    select 
        null,
        process_date,
        trade_date ,
        settle_date,
        trade_id,
        business_department ,
        department_trading_group ,
        account_id,
        account_type ,
        market_id ,
        list_market_id ,
        product_id ,
        product_description ,
        product_type ,
        product_sub_type,
        quote_currency,
        clearing_currency ,
        exchange_rate,
        buy_sell ,
        quantity,
        avg_price,
        trade_amount,
        net_amount,
        open_close ,
        hedge_flag,
        call_put ,
        strike_price ,
        contract_date ,
        input_channel,
        remark,
        num_of_trades ,
        order_no,
        order_date ,
        update_time,
        update_user ,
        0.0,
        0.0,
        broker,
        custodian_code,
        custodian_account,
        'Confirmed',
        is_odd_lot
    from 
    tmp_account_trade a ;

    set o_ret_code = 0; 
    set o_ret_msg = '成交明细校验完成';

    commit;
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proQueryAccountBalance
-- ----------------------------
DROP PROCEDURE IF EXISTS `proQueryAccountBalance`;
delimiter ;;
CREATE PROCEDURE `proQueryAccountBalance`(in  i_account_id VARCHAR(16),
    in  i_from_date date,   -- 业务日期
    in  i_to_date date,   -- 业务日期
    in  i_page_size int,
    in  i_last_no   int,
    OUT o_ret_code int,
    OUT o_ret_msg char(128))
label:begin
    declare v_done int; 
    DECLARE v_calendar_day date;
    DECLARE v_t1 date;
    DECLARE v_t2 date;
    
    DECLARE v_currency varchar(16);
    
    DECLARE cur_calendar CURSOR FOR 
    select distinct calendar_day
    from calendar 
    where calendar_day >= DATE_FORMAT(DATE_SUB(i_from_date,INTERVAL 0 DAY),'%Y%m%d') and 
          calendar_day <= DATE_FORMAT(DATE_SUB(i_to_date,INTERVAL 0 DAY),'%Y%m%d') and 
          holiday in ('N','T');
    
    DECLARE cur_currency CURSOR FOR 
    select currency from currency;

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1; 

    set o_ret_code = '0'; 
    set o_ret_msg = 'Success';

    DROP TEMPORARY TABLE IF EXISTS tmp_balance;
    CREATE TEMPORARY TABLE tmp_balance 
    (
        `id`                      int not null DEFAULT 0,
        `process_date`            date NULL DEFAULT NULL,
        `account_id`              VARCHAR(16) NULL DEFAULT NULL,
        `account_type`            INT(11) NULL DEFAULT '0',
        `currency`                INT(11) NULL DEFAULT '0',
        `trade_balance`           DECIMAL(30,10) NULL DEFAULT 0.00,
        `settle_balance`          DECIMAL(30,10) NULL DEFAULT 0.00,
        `T0`                      DECIMAL(30,10) NULL DEFAULT 0.00,
        `T1`                      DECIMAL(30,10) NULL DEFAULT 0.00,
        `T2`                      DECIMAL(30,10) NULL DEFAULT 0.00,
        `balance_avail`           DECIMAL(30,10) NULL DEFAULT 0.00,
        `balance_extract`         DECIMAL(30,10) NULL DEFAULT 0.00,
        `market_value`            DECIMAL(30,10) NULL DEFAULT 0.00,
        `long_market_value`       DECIMAL(30,10) NULL DEFAULT 0.00,
        `short_market_value`      DECIMAL(30,10) NULL DEFAULT 0.00,
        `equity_balance`          DECIMAL(30,10) NULL DEFAULT 0.00,
        `equity`                  DECIMAL(30,10) NULL DEFAULT 0.00,
        `frozen_amount`           DECIMAL(30,10) NULL DEFAULT 0.00,
        `uncleared_amount`        DECIMAL(30,10) NULL DEFAULT 0.00,
        `unsettled_amount`        DECIMAL(30,10) NULL DEFAULT 0.00,
        `realized_pnl`            DECIMAL(30,10) NULL DEFAULT 0.00,
        `unrealized_pnl`          DECIMAL(30,10) NULL DEFAULT 0.00,
        `margin_amt`              DECIMAL(30,10) NULL DEFAULT 0.00,
        `charges`                 DECIMAL(30,10) NULL DEFAULT 0.00,
        `interest`                DECIMAL(30,10) NULL DEFAULT 0.00,
        `accrued_interest`        DECIMAL(30,10) NULL DEFAULT 0.00,
        `accrued_interest_credit` DECIMAL(30,10) NULL DEFAULT 0.00
    );

    DROP TEMPORARY TABLE IF EXISTS tmp_amount0;
    CREATE TEMPORARY TABLE tmp_amount0 
    (
        `account_id`              VARCHAR(16) NULL DEFAULT NULL,
        `currency`                INT(11) NULL DEFAULT '0',
        `net_amount`              DECIMAL(30,10) NULL DEFAULT 0.00,
        INDEX `idx1` (`account_id`,`currency`,`net_amount`)
    );

    DROP TEMPORARY TABLE IF EXISTS tmp_amount1;
    CREATE TEMPORARY TABLE tmp_amount1 
    (
        `account_id`              VARCHAR(16) NULL DEFAULT NULL,
        `currency`                INT(11) NULL DEFAULT '0',
        `net_amount`              DECIMAL(30,10) NULL DEFAULT 0.00,
        INDEX `idx1` (`account_id`,`currency`,`net_amount`)
    );

    DROP TEMPORARY TABLE IF EXISTS tmp_amount2;
    CREATE TEMPORARY TABLE tmp_amount2
    (
        `account_id`              VARCHAR(16) NULL DEFAULT NULL,
        `currency`                INT(11) NULL DEFAULT '0',
        `net_amount`              DECIMAL(30,10) NULL DEFAULT 0.00,
        INDEX `idx1`  (`account_id`,`currency`,`net_amount`)
    );

    DROP TEMPORARY TABLE IF EXISTS tmp_cash_settle;
    CREATE TEMPORARY TABLE tmp_cash_settle
    (
        `account_id`              VARCHAR(16) NULL DEFAULT NULL,
        `currency`                INT(11) NULL DEFAULT '0',
        `amount`              DECIMAL(30,10) NULL DEFAULT 0.00,
        INDEX `idx1`  (`account_id`,`currency`,`amount`)
    );

    DROP TEMPORARY TABLE IF EXISTS tmp_cash_settle1;
    CREATE TEMPORARY TABLE tmp_cash_settle1
    (
        `account_id`              VARCHAR(16) NULL DEFAULT NULL,
        `currency`                INT(11) NULL DEFAULT '0',
        `amount`              DECIMAL(30,10) NULL DEFAULT 0.00,
        INDEX `idx1`  (`account_id`,`currency`,`amount`)
    );

    DROP TEMPORARY TABLE IF EXISTS tmp_cash_settle2;
    CREATE TEMPORARY TABLE tmp_cash_settle2
    (
        `account_id`              VARCHAR(16) NULL DEFAULT NULL,
        `currency`                INT(11) NULL DEFAULT '0',
        `amount`              DECIMAL(30,10) NULL DEFAULT 0.00,
        INDEX `idx1`  (`account_id`,`currency`,`amount`)
    );

    open cur_calendar; 
    set v_done = 0; 
    fetch cur_calendar into v_calendar_day; 
    while v_done <> 1 do 

        open cur_currency; 
        set v_done = 0; 
        fetch cur_currency into v_currency; 
        while v_done <> 1 do 

            select min(calendar_day) into v_t1 
                from calendar 
                where calendar_day > DATE_FORMAT(DATE_SUB(v_calendar_day,INTERVAL 0 DAY),'%Y%m%d') and holiday  in ('N','S') and market_id = (case v_currency when 1 then 4 when 2 then 1 when 4 then 2 end);
            select min(calendar_day) into v_t2 
                from calendar 
                where calendar_day > DATE_FORMAT(DATE_SUB(v_t1,INTERVAL 0 DAY),'%Y%m%d') and holiday  in ('N','S') and market_id = (case v_currency when 1 then 4 when 2 then 1 when 4 then 2 end);

            delete from tmp_amount0;
            delete from tmp_amount1;
            delete from tmp_amount2;
            delete from tmp_cash_settle;
            delete from tmp_cash_settle1;
            delete from tmp_cash_settle2;

            if EXISTS (select 1 from sys_info where buss_date = v_calendar_day) then 
                if EXISTS (select 1 from unsettled_position where settle_date = v_calendar_day) then 
                    insert into tmp_amount0
                    select  account_id AS account_id,
                            clearing_currency AS currency,
                            sum(case buy_sell  when 1 then -1 else 1 end * net_amount) AS net_amount 
                    from jcbms.account_trade 
                    where settle_date = v_calendar_day and (ifnull(i_account_id,'') = '' or account_id = i_account_id) and clearing_currency = v_currency and status = 'Confirmed'
                    group by account_id,clearing_currency;
                end if;

                if EXISTS (select 1 from cash_flow where process_date < v_calendar_day and settle_date = v_calendar_day) then 
                    insert into tmp_cash_settle
                    select  account_id AS account_id,
                            currency AS currency,
                            sum(case purpose  when 1 then 1 else -1 end * amount) AS amount 
                    from jcbms.cash_flow 
                    where process_date < v_calendar_day and settle_date = v_calendar_day and status = 'Confirmed' and (ifnull(i_account_id,'') = '' or account_id = i_account_id) and currency = v_currency 
                    group by account_id,currency;
                end if;
            end if;

            insert into tmp_amount1
            select  account_id AS account_id,
                    clearing_currency AS currency,
                    sum(case buy_sell  when 1 then -1 else 1 end * net_amount) AS net_amount 
            from jcbms.account_trade 
            where settle_date = v_t1 and status = 'Confirmed' and   (ifnull(i_account_id,'') = '' or account_id = i_account_id) and clearing_currency = v_currency 
            group by account_id,clearing_currency;

            insert into tmp_amount2
            select  account_id AS account_id,
                    clearing_currency AS currency,
                    sum(case buy_sell  when 1 then -1 else 1 end * net_amount) AS net_amount 
            from jcbms.account_trade 
            where settle_date = v_t2 and status = 'Confirmed' and (ifnull(i_account_id,'') = '' or account_id = i_account_id) and clearing_currency = v_currency 
            group by account_id,clearing_currency;

            insert into tmp_cash_settle1
            select  account_id AS account_id,
                    currency AS currency,
                    sum(case purpose  when 1 then 1 else -1 end * amount) AS amount 
            from jcbms.cash_flow 
            where settle_date = v_t1 and status = 'Confirmed' and (ifnull(i_account_id,'') = '' or account_id = i_account_id) and currency = v_currency  and process_date < v_t1  
            group by account_id,currency;

            insert into tmp_cash_settle2
            select  account_id AS account_id,
                    currency AS currency,
                    sum(case purpose  when 1 then 1 else -1 end * amount) AS amount 
            from jcbms.cash_flow 
            where settle_date = v_t2 and status = 'Confirmed' and (ifnull(i_account_id,'') = '' or account_id = i_account_id) and currency = v_currency and process_date < v_t2
            group by account_id,currency;

            insert into tmp_balance
            select 
                a.id AS id,
                a.process_date AS process_date,
                a.account_id AS account_id,
                a.account_type AS account_type,
                a.currency AS currency,
                a.trade_balance as trade_balance,
                a.settle_balance as settle_balance,
                a.settle_balance + ifnull(d.net_amount,0) AS T0,
                (a.settle_balance + ifnull(b.net_amount,0) + ifnull(d.net_amount,0) + ifnull(c0.amount,0) + ifnull(c1.amount,0)) AS T1,
                (a.settle_balance + ifnull(b.net_amount,0) + ifnull(c.net_amount,0) + ifnull(d.net_amount,0) + 
                        ifnull(c0.amount,0) + ifnull(c1.amount,0) + ifnull(c2.amount,0)) AS T2,
                a.balance_avail AS balance_avail,
                a.balance_extract AS balance_extract,
                a.market_value AS market_value,
                a.long_market_value AS long_market_value,
                a.short_market_value AS short_market_value,
                a.equity_balance AS equity_balance,
                a.equity AS equity,
                a.frozen_amount AS frozen_amount,
                a.uncleared_amount AS uncleared_amount,
                a.unsettled_amount AS unsettled_amount,
                a.realized_pnl AS realized_pnl,
                a.unrealized_pnl AS unrealized_pnl,
                a.margin_amt AS margin_amt,
                a.charges AS charges,
                a.interest AS interest,
                a.accrued_interest AS accrued_interest,
                a.accrued_interest_credit AS accrued_interest_credit 
            from account_balance a 
            left join tmp_amount1 b on (b.account_id = a.account_id) and (b.currency = a.currency)
            left join tmp_amount2 c on (c.account_id = a.account_id) and (c.currency = a.currency)
            left join tmp_amount0 d on (d.account_id = a.account_id) and (d.currency = a.currency)
            left join tmp_cash_settle c0 on (c0.account_id = a.account_id) and (c0.currency = a.currency)
            left join tmp_cash_settle1 c1 on (c1.account_id = a.account_id) and (c1.currency = a.currency)
            left join tmp_cash_settle2 c2 on (c2.account_id = a.account_id) and (c2.currency = a.currency)
            where 
                a.process_date = v_calendar_day and 
                (ifnull(i_account_id,'') = '' or a.account_id = i_account_id) and 
                a.currency = v_currency;

            set v_done = 0; 
            fetch cur_currency into v_currency; 
        end while; 
        close cur_currency;
    
        set v_done = 0; 
        fetch cur_calendar into v_calendar_day; 
    end while; 
    close cur_calendar;

    select o_ret_code,o_ret_msg, a.* From tmp_balance a where if(ifnull(i_last_no,0) > 0, id > ifnull(i_last_no,0), 1=1) order by id limit i_page_size;

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proQueryATI
-- ----------------------------
DROP PROCEDURE IF EXISTS `proQueryATI`;
delimiter ;;
CREATE PROCEDURE `proQueryATI`(in i_market_id int, 
    in i_file_id varchar(32),
    in i_generate_date date, 
    in i_update_user varchar(32),
    out o_ret_code int, 
    out o_ret_message varchar(64))
label:begin
    
    /*
    中华通的股票是T日交收，所以中华通应当用T-1日的数据
    中华通持仓文件（昨天已经交收完的状态，上一日的持仓）（中华通结算是晚上17:30左右进行交收): 
    1.4/5->1: 今日交易的净卖
    2.1->4/5: 今日交收的净买
    3.派发领取：从2->1的领取（晚上出报告，今日应该领取昨日的派发,所以按昨天的2号仓库就可以直接进行派发)
    */

    declare v_member_id varchar(32) default '';  -- 会员号
    declare v_count int default 0 ;   -- 本日生成文件次数
    declare v_space varchar(1);
    declare YYYYMMDD varchar(8);
    declare v_file_name varchar(15); 
    declare v_zero varchar (1); 
    declare v_t0 date default null ; 
    declare v_t1 date default null ; 
    declare v_1t date default null; 
    declare v_buss_date date default null; 
    declare v_dayend_performed varchar(1); 
    declare v_sum_stock bigint default 0; 
    declare v_sum_quantity bigint default 0; 

    set o_ret_code = 0; 
    set o_ret_message = "Success";
    set v_space = ' ';
    set YYYYMMDD  = date_format(i_generate_date,'%Y%m%d');
    set v_file_name = 'ATI BATCH INPUT'; 
    set v_zero = '0';

    -- 取数据，数据校验
    truncate table CheckWarnings; 

    -- -- 当前业务日期
    select buss_date,day_end_performed into v_buss_date,v_dayend_performed from sys_info; 

    -- -- 市场校验

    insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 
        1,
        'ATI_FILE',
        i_market_id,
        '',
        '',
        '市场不存在',
        'JC_clearing',
        now()
    where not exists(select 1 from market where market_id = i_market_id);
    
    if exists(select 1 from CheckWarnings) then 
        set o_ret_code = 1; 
        set o_ret_message = 'market not exists';
        select o_ret_code,o_ret_message,'';
        leave label;
    end if; 

    -- --会员号
    set v_member_id = '';
    select member_id into v_member_id 
    from market 
    where market_id = i_market_id;

    if v_member_id = ''  or v_member_id is null then 
        set o_ret_code = 2; 
        set o_ret_message = concat("member id is not setted up");
        select o_ret_code,o_ret_message,'';
        leave label;
    end if; 

    -- 取出生成日对应的交易日
    /*
    *1.生成日 = 当前业务日期 &&　dayend = false:取<=生成日的交易日
    *2.生成日 = 当前业务日期 &&　dayend = true: 取当前交易日
    *3.生成日 < 当前业务日期；取<=生成日的交易日
    *4.生成日 > 当前业务日期；不合法 
    */

    set v_t0  =  null; 
    if (YYYYMMDD = v_buss_date and v_dayend_performed <>'Y')  then 
        select max(calendar_day) into v_t0 from calendar where market_id = i_market_id and  calendar_day <= YYYYMMDD and holiday <> 'Y';
    elseif (YYYYMMDD = v_buss_date and v_dayend_performed  = 'Y') then 
        select max(calendar_day) into v_t0 from calendar where market_id = i_market_id and calendar_day <= YYYYMMDD and holiday <> 'Y';
    elseif (YYYYMMDD < v_buss_date) then 
        select max(calendar_day) into v_t0 from calendar where market_id = i_market_id and calendar_day <= YYYYMMDD and holiday <> 'Y';       
    end if ; 
    if v_t0 is null then 
        set o_ret_code = 3; 
        set o_ret_message = concat("cannot get t0 day");
        select o_ret_code,o_ret_message,'';
        leave label;
    end if; 

    set v_t1  = NULL; 
    select min(calendar_day) into v_t1 from calendar where market_id = i_market_id and calendar_day>YYYYMMDD and holiday <> 'Y'; 
    
    set v_1t  = NULL; 
    select max(calendar_day) into v_1t from calendar where market_id = i_market_id and calendar_day<YYYYMMDD and holiday <> 'Y'; 

    if v_t1 is null  then 
        set o_ret_code = 4; 
        set o_ret_message = concat("cannot get t1 day");
        select o_ret_code,o_ret_message,'';
        leave label;
    end if; 

    start transaction; 

    -- 本日生成文件次数
    if not exists(select 1 from ati_index where generate_date = i_generate_date) then 
        set v_count = 1; 
        insert into ati_index(generate_date,cnt,update_user,update_time)
            select i_generate_date,v_count,i_update_user,now();
    else 
        update ati_index set cnt = cnt+1 where generate_date = i_generate_date; 
        select cnt into v_count from ati_index where generate_date = i_generate_date; 
    end if; 


    drop temporary table if EXISTS result; 
    create temporary table result
    (
        id int auto_increment primary key ,
        type int,
        product_id varchar(32),
        txt varchar(128), 
        index idx1(product_id)
    );

    insert into result
    -- 标题 '0'+ 序号 + member_id(6) +  空格（8）+ 自定义标识(15)(ATI+count) + 生成日期（YYYYMMDD)+ "ATI BATCH INPUT" + 空格(42)
    select 
    NULL,
    0,
    '',
    concat('0', rjust(v_count,4,v_zero), ljust(v_member_id,6,v_space), ljust('',8,v_space), ljust(concat('ATI',v_count),15,v_space), YYYYMMDD, ljust(v_file_name,15,v_space), ljust('',42,v_space));

    -- 数据行 '1' + product_id(5) + space(12) + custodian_account_from(8)(rjust('0')) + custodian_account_to(8)(rjust('0')) + quantity(11)(rjust('0')) + remark(40) + checksum(14)(product_id + quantity)

    -- 生成公司级别的汇总数据
    drop temporary table if exists custodian_account_position_summary; 
    create temporary table custodian_account_position_summary
    (
        id int auto_increment primary key, 
        order_id int, 
        custodian_code varchar(16),     
        custodian_account varchar(16), 
        from_custodian_account varchar(16), 
        to_custodian_account varchar(16), 
        market_id int, 
        product_id varchar(32), 
        quantity decimal(30,10) default 0,   -- 实际数量
        value decimal(30,10) default 0, -- ATI报告数量
        index idx1(order_id,custodian_code,custodian_account,from_custodian_account,to_custodian_account,market_id,product_id)
    );

    if i_file_id = 'HKEX_ATI2_BATCH' then
        -- 港交所ATI2文件
        insert into custodian_account_position_summary
        (
            order_id,
            custodian_code, 
            custodian_account,
            from_custodian_account, 
            to_custodian_account, 
            market_id, 
            product_id, 
            quantity,  
            value
        )
        select 
                1,
            	c.custodian_code, 
                c.custodian_account,
                1 as from_custodian_account,
                c.custodian_account as to_custodian_account,
                a.market_id, 
                a.product_id,
                sum(a.quantity) as quantity,
                sum(a.quantity) as value
        from settled_position a
        inner join account_type_custodian c on c.market_id = a.market_id and c.account_type = a.account_type
        where a.settle_date = v_t0 and a.market_id = i_market_id
        group by a.product_id,a.account_type
        having(quantity > 0) 
        order by a.product_id,c.custodian_account;
    
    elseif i_file_id = 'SSE_ATI2_BATCH' or i_file_id = 'SZSE_ATI2_BATCH' then
        insert into custodian_account_position_summary
            (
                order_id,
                custodian_code, 
                custodian_account,
                from_custodian_account, 
                to_custodian_account, 
                market_id, 
                product_id, 
                quantity,  
                value
            )
            select 
                    1,
                    c.custodian_code, 
                    c.custodian_account,
                    1 as from_custodian_account,
                    c.custodian_account as to_custodian_account,
                    a.market_id, 
                    a.product_id,
                    sum(a.quantity) as quantity,
                    sum(a.quantity) as value
            from unsettled_position a
            inner join account_type_custodian c on c.market_id = a.market_id and c.account_type = a.account_type
            where a.settle_date = v_t1 and a.market_id = i_market_id
            group by a.product_id,a.account_type
            having(quantity > 0) 
            order by a.product_id,c.custodian_account;
    elseif i_file_id = 'HKEX_ATI1_BATCH' or i_file_id = 'SSE_ATI1_BATCH' or i_file_id = 'SZSE_ATI1_BATCH' then
        -- 港交所ATI 1文件
        insert into custodian_account_position_summary
        (
            order_id,
            custodian_code, 
            custodian_account,
            from_custodian_account, 
            to_custodian_account, 
            market_id, 
            product_id, 
            quantity, 
            value
        )
        select
            order_id,
            custodian_code, 
            custodian_account,
            case when quantity > 0 then 1 else custodian_account end as from_custodian_account,
            case when quantity > 0 and custodian_account = 1 then 5 
                 when quantity > 0 and custodian_account <> 1 then custodian_account 
                 when quantity < 0 then 1 end as to_custodian_account,
            market_id, 
            product_id,
            quantity,
            case when quantity>0 then 1 else -1 end *quantity as value
        from
        (
            -- 净卖出，转到1号仓
            select 
                4 as order_id,
                c.custodian_code,
                c.custodian_account, 
                a.market_id,
                a.product_id,
                -1 * sum(case when a.buy_sell = 1 then -1 else 1 end * a.quantity) as quantity
            from account_trade a 
            inner join account_type_custodian c on a.market_id = c.market_id and a.account_type = c.account_type
            where a.settle_date = case when i_market_id = 1 then v_t0 else v_t1 end and a.market_id = i_market_id and a.status = 'Confirmed'
            group by a.product_id,c.custodian_code,c.custodian_account
            having(quantity < 0)
            union
            -- 持仓差异，4/5号仓位比交易所多的，交易所要从1号仓转到4/5号仓
            select 
                3 as order_id,
                a.custodian_code as custodian_code,
                a.custodian_account as custodian_account,
                a.market_id as market_id,
                a.product_id as product_id,
                ifnull(sum(case when a.market_id in (4,8) then ifnull(a.net_quantity,0) else ifnull(a.quantity,0) end),0) - ifnull(b.quantity,0) as quantity
            from account_position a 
            left join custodian_account_position b on b.process_date = v_1t and  b.market_id = a.market_id and 
                b.product_id = a.product_id and ifnull(b.custodian_account,'') = ifnull(a.custodian_account,'')
            where a.process_date = v_1t and a.market_id = i_market_id and a.product_id not like 'XS%' and a.product_id not like 'YFD%' and a.product_id not like '%FREEZE' and a.product_id not like '%APPLIED'
            group by a.product_id,ifnull(a.custodian_code,''),ifnull(a.custodian_account,'')
            having(quantity > 0)
            UNION
            -- 持仓差异，4/5号仓位比交易所少的，交易所要将多出来的转到1号仓
            select 
                2 as order_id,
                a.custodian_code,
                a.custodian_account,
                a.market_id,
                a.product_id,
                case when a.market_id = 1 then ifnull(b.quantity,0) else ifnull(b.net_quantity,0) end - ifnull(a.quantity,0) as quantity
            from custodian_account_position a 
            left join(
                    select c.product_id,c.market_id as market_id,c.custodian_code,c.custodian_account,sum(c.quantity) as quantity,sum(c.net_quantity) as net_quantity 
                    from account_position c
                    where c.process_date = v_1t and c.market_id = i_market_id
                    group by c.product_id,c.market_id,c.custodian_code,c.custodian_account
            ) b on a.market_id = b.market_id and a.product_id = b.product_id and ifnull(b.custodian_code,'') = ifnull(a.custodian_code,'') and ifnull(b.custodian_account,'') = ifnull(a.custodian_account,'')
            where a.process_date = v_1t and a.market_id = i_market_id and a.custodian_account not in (1,2)
            having(quantity < 0)
        ) t where t.product_id not REGEXP '[a-z]' order by t.order_id,t.product_id,from_custodian_account,to_custodian_account;
        -- 2号仓-->1号仓
        insert into custodian_account_position_summary
        (
            order_id,
            custodian_code, 
            custodian_account,
            from_custodian_account, 
            to_custodian_account, 
            market_id, 
            product_id, 
            quantity, 
            value
        )
        select 
            1 as order_id,
            custodian_code, 
            custodian_account,
            custodian_account, 
            1, 
            market_id, 
            product_id, 
            quantity, 
            quantity
        from custodian_account_position
        where process_date = v_1t and
            market_id = i_market_id and 
            custodian_code = 'CCASS' and 
            custodian_account = '2';
    end if;

    if i_market_id = 4 or i_market_id = 8 then
        update custodian_account_position_summary a 
        inner join market_product_mapping b on b.market_id = a.market_id and b.to_product_id = a.product_id 
        set a.product_id = b.product_id;
    end if;

    -- 有导入官方持仓文件
    if exists (select 1 from custodian_account_position where  process_date = v_1t and market_id = i_market_id) then 

            insert into result
            select
            NULL,
            1,
            a.product_id,
            concat(
                '1',
                rjust(a.product_id,5,v_zero),  
                ljust('',12,v_space),
                rjust(a.from_custodian_account,8,v_zero),
                rjust(a.to_custodian_account,8,v_zero),
                rjust(ceil(a.value),11,v_zero),
                ljust('',40,v_space),
                rjust(a.product_id + ceil(a.value),14,v_zero)
            ) 
            from custodian_account_position_summary a order by a.product_id,a.order_id,field(a.from_custodian_account,4,5,1),a.to_custodian_account;
    else
        rollback;  
        set o_ret_code = 1; 
        set o_ret_message = concat("need import custodian account on ", v_1t ); 
        select o_ret_code,o_ret_message,'';
        leave label; 

    end if;

    select ifnull(count(*),0),ifnull(sum(product_id),0),ifnull(sum(value),0) into v_count,v_sum_stock,v_sum_quantity
    from custodian_account_position_summary; 

    insert into result
    select 
    NULL,
    2,
    '',
    concat('2',rjust(v_count,4,'0'),rjust(v_sum_stock,7,'0'),rjust(v_sum_quantity,14,'0'),rjust(v_sum_quantity+v_sum_stock,17,'0'),ljust('',56,v_space));
    
    select o_ret_code, o_ret_message, txt from result order by type,product_id,id;
    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proQueryAutoExchange
-- ----------------------------
DROP PROCEDURE IF EXISTS `proQueryAutoExchange`;
delimiter ;;
CREATE PROCEDURE `proQueryAutoExchange`(IN  i_process_date date,
    in  i_pageCount int,
    in  i_lastID int,
    In  i_input_user char(32), 
    OUT o_ret_code INT , 
    OUt o_ret_msg VARCHAR(64))
label: BEGIN
    declare v_process_date date; 
    declare v_id int;
    declare v_loop int;
    declare v_to_priority int;
    declare v_account_id varchar(16);
    declare v_account_type varchar(1);
    declare v_currency_in varchar(1);
    declare v_currency_out varchar(1);
    declare v_status varchar(16);
    declare remark_currency_out varchar(3);
    declare remark_currency_in varchar(3);
    
    declare v_debit_balance decimal(30,10);
    declare v_settle_balance decimal(30,10);

    declare v_tmp_account_id varchar(16);
    declare v_tmp_currency_out varchar(1);
    declare v_tmp_settle_balance decimal(30,10);
    
    declare exchange_amount decimal(30,10);
    declare v_rate_molecular decimal(30,10);
    declare v_rate_denominator decimal(30,10);
    
    declare v_done int;
    DECLARE v_error int;

    DECLARE cur_exchange CURSOR FOR
    SELECT
       id,account_id,currency_in,debit_balance
    FROM
      tmp_auto_exchange a
    where a.process_date = i_process_date order by id; 

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1; 

    declare CONTINUE HANDLER FOR SQLEXCEPTION
            begin
                GET DIAGNOSTICS CONDITION 1
                o_ret_msg = MESSAGE_TEXT,
                o_ret_code = RETURNED_SQLSTATE; 
                set v_error = 1;
            end; 

    select buss_date  into v_process_date from sys_info; 

    if i_process_date is NULL then 
        set i_process_date = v_process_date;
    end if; 
    
    if i_process_date > v_process_date then 
        set i_process_date = v_process_date;
    end if; 

    set o_ret_code = 0; 
    set o_ret_msg = 'Success';
    start transaction; 
    -- 获取处理标志
    select status into v_status from day_end_process where operation = 'AutoExchange';
    -- pageCount = 999，日期为当天，并且未处理，才可以重新生成
    if i_pageCount = 999 and i_process_date = v_process_date and ifnull(v_status,'') <> '已处理' then 
        delete from auto_exchange where process_date = i_process_date;
    end if;

    if not EXISTS(select 1 from auto_exchange where process_Date = i_process_date) then 

        drop temporary table if exists tmp_acct_balance;
        create TEMPORARY table tmp_acct_balance as select * from account_balance where process_date = i_process_date;
        create index idx1 on tmp_acct_balance(process_date,account_id,currency);

        drop temporary table if exists tmp_currency_rate;
        create TEMPORARY table tmp_currency_rate as select * from basicdata.currency_rate;
        create index idx1 on tmp_currency_rate(currency_from,currency_to);

        drop temporary table if exists tmp_auto_exchange;
        create TEMPORARY table tmp_auto_exchange as select * from auto_exchange where 1=2;

        insert into tmp_auto_exchange 
        (
            process_date,account_id,debit_balance,currency_in
        )
        select 
            a.process_date,a.account_id,a.settle_balance,a.currency
        from account_balance a 
        inner join currency b on a.currency = b.currency
        inner join account_profile c on c.account_id = a.account_id and (c.account_class = '3' or (c.account_class <> '3' and c.account_sub_class = 'trading'))
        where a.process_date = i_process_date and a.settle_balance < 0
        order by a.account_id,b.exchange_from_priority;

        -- 遍历欠款信息
        open cur_exchange; 
            set v_done = 0; 
            fetch cur_exchange into v_id,v_account_id,v_currency_in,v_debit_balance; 
            while v_done <> 1 do 
                -- 转换币种格式
                set remark_currency_in = case v_currency_in when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end;
                -- 每处理一条，插入表中
                insert into jcbms.auto_exchange
                (
                    process_date,account_id,debit_balance,currency_in,update_user,update_time
                ) 
                select i_process_date,v_account_id,v_debit_balance,v_currency_in,i_input_user,now();

                -- 根据欠款客户信息，查找无欠款币种，进行货币兑换
                set v_to_priority = 0;
                loop_acct_bal: LOOP
                    set v_loop = NULL; -- 判断是否结束循环
                    select b.exchange_to_priority,a.account_type,a.currency,a.settle_balance,d.rate_molecular,d.rate_denominator,b.exchange_to_priority
                    into v_to_priority,v_account_type,v_currency_out,v_settle_balance,v_rate_molecular,v_rate_denominator,v_loop
                    from tmp_acct_balance a 
                    left join jcbms.currency b on a.currency = b.currency
                    left join jcbms.account_profile c on c.account_id = a.account_id and (c.account_class = '3' or (c.account_class <>'3' and c.account_sub_class = 'trading'))
                    left join tmp_currency_rate d on d.currency_from = (case a.currency when 1 then 'CNH' when 2 then 'HKD' when 4 then 'USD' end) and 
                                                     d.currency_to = (case v_currency_in when 1 then 'CNH' when 2 then 'HKD' when 4 then 'USD' end)
                    where a.process_date = i_process_date and a.account_id = v_account_id and a.currency <> v_currency_in and a.settle_balance > 0 and b.exchange_to_priority > ifnull(v_to_priority,0)
                    order by b.exchange_to_priority
                    limit 1;
                    
                    if v_loop is null then 
                        leave loop_acct_bal;
                    end if;  
                    
                    /* 
                        记录上一次执行的数据，如果本次客户币种和上一次执行客户币种相同，则本次可用的settle_balance金额要减去上一次amount_out数据
                        入不同，则记录本次客户币种，供下次循环比较
                    */
                    if v_tmp_account_id = v_account_id and v_tmp_currency_out = v_currency_out then 
                        set v_settle_balance = v_settle_balance - v_tmp_settle_balance;
                    else 
                        set v_tmp_account_id = v_account_id;
                        set v_tmp_currency_out = v_currency_out;
                        set v_tmp_settle_balance = 0;
                    end if;
                    
                    set remark_currency_out = case v_currency_out when 1 then 'CNY' when 2 then 'HKD' when 4 then 'USD' end;
                    set exchange_amount = round(v_settle_balance * (v_rate_molecular / v_rate_denominator),2);
                    
                    -- 换汇之后的资金大于欠款，使用欠款金额做相关出入金
                    if exchange_amount <> 0 and v_debit_balance <> 0 and exchange_amount > abs(v_debit_balance) then 
                        if exists (select 1 from auto_exchange 
                                        where process_date = i_process_date and account_id = v_account_id and 
                                        ifnull(currency_out,'') <> '' and currency_in = v_currency_in
                                    ) then
                            insert into auto_exchange(
                                process_date,account_id,debit_balance,currency_out,currency_in,exchange_rate,
                                amount_out,amount_in,update_user,update_time
                            )
                            select 
                                i_process_date,
                                v_account_id,
                                0,
                                v_currency_out,
                                v_currency_in,
                                round(v_rate_molecular / v_rate_denominator,6),
                                round(abs(v_debit_balance)/(v_rate_molecular / v_rate_denominator),2),
                                abs(v_debit_balance),
                                i_input_user,
                                now();
                        else 
                            update auto_exchange
                            set debit_balance = 0,
                                currency_out = v_currency_out,
                                exchange_rate = round(v_rate_molecular / v_rate_denominator,6),
                                amount_out = round(abs(v_debit_balance)/(v_rate_molecular / v_rate_denominator),2),
                                amount_in = abs(v_debit_balance)
                            where process_date = i_process_date and account_id = v_account_id and currency_in = v_currency_in 
                            order by id desc limit 1;
                        end if;
                        -- 记录本次转汇金额，共下次循环比较用
                        set v_tmp_settle_balance = v_tmp_settle_balance + round(abs(v_debit_balance)/(v_rate_molecular / v_rate_denominator),2);
                        -- settle_balance转换的金额大于欠款金额，欠款金额清0
                        set v_debit_balance = 0;
                        
                    elseif exchange_amount <> 0 and v_debit_balance <> 0 and exchange_amount <= abs(v_debit_balance) then 
                    -- 换汇之后的资金小于欠款，使用换汇金额做相关出入金
                        if exists (select 1 from auto_exchange 
                                        where process_date = i_process_date and account_id = v_account_id and 
                                        ifnull(currency_out,'') <> '' and currency_in = v_currency_in
                                ) then
                            insert into auto_exchange(
                                process_date,account_id,debit_balance,currency_out,currency_in,exchange_rate,
                                amount_out,amount_in,update_user,update_time
                            )
                            select 
                                i_process_date,
                                v_account_id,
                                v_debit_balance + exchange_amount,
                                v_currency_out,
                                v_currency_in,
                                round(v_rate_molecular / v_rate_denominator,6),
                                v_settle_balance,
                                exchange_amount,
                                i_input_user,
                                now();
                        else 
                            update auto_exchange
                            set debit_balance = (v_debit_balance + exchange_amount),
                                currency_out = v_currency_out,
                                exchange_rate = round(v_rate_molecular / v_rate_denominator,6),
                                amount_out = v_settle_balance,
                                amount_in = exchange_amount
                            where process_date = i_process_date and account_id = v_account_id and currency_in = v_currency_in 
                            order by id desc limit 1;
                        end if;
                        -- 记录本次转汇金额，共下次循环比较用
                        set v_tmp_settle_balance = v_tmp_settle_balance + v_settle_balance;
                        -- settle_balance转换的金额小于欠款金额，欠款金额减去转回金额
                        set v_debit_balance = v_debit_balance + exchange_amount;

                    end if;

                end LOOP;

                set v_done = 0; 
                fetch cur_exchange into v_id,v_account_id,v_currency_in,v_debit_balance; 
            end while; 
        close cur_exchange;

    end if;

    if ifnull(i_pageCount,0) <> 0 then 
        select 
            o_ret_code,o_ret_msg,id,process_date,account_id,debit_balance,currency_out,currency_in,
            exchange_rate,amount_out,amount_in,update_user,update_time
        from jcbms.auto_exchange 
        where process_date = i_process_date and (case when ifnull(i_lastID,0) > 0 then id > ifnull(i_lastID,0) else 1=1 end)
        LIMIT i_pageCount; 
    else 
        select 
            o_ret_code,o_ret_msg,id,process_date,account_id,debit_balance,currency_out,currency_in,
            exchange_rate,amount_out,amount_in,update_user,update_time
        from jcbms.auto_exchange 
        where process_date = i_process_date and (case when ifnull(i_lastID,0) > 0 then id > ifnull(i_lastID,0) else 1=1 end);
    end if;

  commit; 
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proQueryExcerciseOption
-- ----------------------------
DROP PROCEDURE IF EXISTS `proQueryExcerciseOption`;
delimiter ;;
CREATE PROCEDURE `proQueryExcerciseOption`(in  i_trade_date date,
    out o_ret_code int, 
    out o_ret_message varchar(64))
label:begin
    
    declare  v_process_date date; 
    select buss_date into v_process_date from sys_info ; 

    set o_ret_code = 0; 
    set o_ret_message  = "";

    if i_trade_date  is null then 
        set i_trade_date = v_process_date;
    end if; 

    drop temporary table if exists tmp_exercise; 
    create temporary table tmp_exercise
    (
        id bigint primary key auto_increment, 
        market_id int default 0, 
        product_id varchar(32) default '', 
        account_id varchar(16) default '',
        account_type int default 0, 
        quantity decimal(30,10) default 0,
        multiplier decimal(30,10) default 0,
        underlying_list_market int default 0, 
        underlying_product_id varchar(32) default '',
        call_put varchar(1) default '',
        exercise_date date, 
        closing_price decimal(30,10) default 0,
        strike_price decimal(30,10) default 0, 
        underlying_quantity decimal(30,10) default 0,
        profit varchar(1) default 'N', 
        enough_underlying_quantity varchar(1) default 'N',
        auto_excercise varchar(1) default 'N',
        index idx(market_id,product_id, account_id), 
        index idx1(underlying_list_market, underlying_product_id, account_id)
    ); 

    -- 插入持仓
    insert into tmp_exercise 
    (
        market_id, 
        product_id,
        account_id, 
        quantity,
        multiplier,
        underlying_list_market, 
        underlying_product_id,
        strike_price,
        call_put,
        exercise_date
    )
    select 
        a.market_id, 
        a.product_id, 
        a.account_id,
        sum(net_quantity),
        b.price_factor,
        underlying_list_market,
        underlying_product_id,
        strike_price, 
        call_put, 
        exercise_date
    from account_position a  
    inner join product b on a.market_id = b.list_market_id and a.product_id = b.product_id and b.exercise_date=i_trade_date
    where process_date = v_process_date  and 
          a.market_id = 2 and 
          a.product_type = 16
    group by market_id ,product_id, account_id;


    -- 更新标的持仓相关信息
    update tmp_exercise a 
    inner join product_market_data b on b.trade_date = i_trade_date and  a.underlying_list_market = b.list_market_id and a.underlying_product_id = b.product_id 
    set a.closing_price = b.closing_price;

    -- 更新标的持仓信息
    drop temporary table if exists tmp_position; 
    create temporary  table tmp_position
    (
        id bigint primary key auto_increment, 
        market_id int default 0,
        product_id varchar(32) default '',
        account_id varchar(32) default '', 
        quantity decimal(30,10) default 0, 
        index idx(market_id, product_id, account_id)
    );
    insert into tmp_position
    (
        market_id, 
        product_id, 
        account_id, 
        quantity
    )
    select 
        a.market_id, 
        a.product_id, 
        a.account_id, 
        sum(a.net_quantity)
    from account_position a 
    inner join tmp_exercise b on a.market_id = b.underlying_list_market and  a.product_id = b.underlying_product_id and a.account_id = b.account_id
    where a.process_date = v_process_date; 

    update tmp_exercise a 
    inner join tmp_position b on a.underlying_list_market = b.market_id  and a.underlying_product_id = b.product_id and a.account_id = b.account_id 
    set a.underlying_quantity = b.quantity; 

    -- 盈亏
    update tmp_exercise a
    set a.profit  = case when (a.call_put = 'C'  and a.strike_price > a.closing_price ) or (a.call_put = 'P' and a.strike_price < a.closing_price) then 'Y' else 'N' end ; 

    -- 买put是否有足够的标的
    update tmp_exercise a
    set a.enough_underlying_quantity = case when a.underlying_quantity >= a.quantity*a.multiplier then 'Y' else 'N' end 
    where call_put = 'P';

    -- 程序判断自动行权
    update tmp_exercise a 
    set a.auto_excercise = case when call_put = 'C' then a.profit 
                                when call_put = 'P' and a.enough_underlying_quantity = 'Y' then a.profit 
                           else  'N' end; 

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proQueryExpiringPosition
-- ----------------------------
DROP PROCEDURE IF EXISTS `proQueryExpiringPosition`;
delimiter ;;
CREATE PROCEDURE `proQueryExpiringPosition`(in  i_process_date date,   
    in  i_pageCount int,
    in  i_lastID int,
    OUT o_ret_code int,
    OUT o_ret_msg char(128))
label:begin
    if i_process_date is null then 
        select buss_date into i_process_date from sys_info; 
    end if; 

    set o_ret_code = '0'; 
    set o_ret_msg = 'Success';

    select 
        o_ret_code,
        o_ret_msg,
        b.id,
        a.market_id as market_id,
        a.product_id as product_id, 
        max(ifnull(b.product_description,'')) as product_description,
        sum(a.quantity) as sum_quantity,  
        count(distinct(a.account_id)) as account_number, 
        date_format(b.last_trading_date,'%Y%m%d') as last_trading_date
        from 
        account_position a
        left join product b on a.market_id = b.list_market_id and a.product_id = b.product_id
        where a.process_date = i_process_date
        and exists (select 1 from product b where a.market_id = b.list_market_id and a.product_id = b.product_id and b.last_trading_date <> '00000000'  and b.last_trading_date is not null and b.last_trading_date <> '20000101' and b.last_trading_date < i_process_date) 
        and a.quantity <> 0 and case when i_lastID > 0 then b.id > i_lastID else 1=1 end
        group by a.product_id
        ORDER BY b.id LIMIT i_pageCount; 

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proQueryGenId
-- ----------------------------
DROP PROCEDURE IF EXISTS `proQueryGenId`;
delimiter ;;
CREATE PROCEDURE `proQueryGenId`(in i_key varchar(32), 
    in i_generate_date date, 
    in i_update_user varchar(32),
    out o_ret_code int, 
    out o_ret_message varchar(64))
label:begin 
    declare v_count int default 0 ;   

    set o_ret_code = 0; 
    set o_ret_message = "Success";
    start transaction;  

    
    if not exists(select 1 from export_file_cnt where process_date = i_generate_date and gen_key = i_key) then 
        set v_count = 1; 
        insert into export_file_cnt (id,process_date,gen_key,cnt,update_user,update_time)
		    select NULL,i_generate_date,i_key,v_count,i_update_user,now();
    else 
        update export_file_cnt set cnt = cnt+1 where process_date = i_generate_date and gen_key = i_key; 
        select cnt into v_count from export_file_cnt where process_date = i_generate_date and gen_key = i_key; 
    end if; 

    select o_ret_code, o_ret_message, v_count;
    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proQueryHKATI
-- ----------------------------
DROP PROCEDURE IF EXISTS `proQueryHKATI`;
delimiter ;;
CREATE PROCEDURE `proQueryHKATI`(in i_market_id int, 
    in i_file_id varchar(32),
    in i_generate_date date, 
    in i_update_user varchar(32),
    out o_ret_code int, 
    out o_ret_message varchar(64))
label:begin
    
    

    declare v_member_id varchar(32) default '';  
    declare v_count int default 0 ;   
    declare v_space varchar(1);
    declare YYYYMMDD varchar(8);
    declare v_file_name varchar(15); 
    declare v_zero varchar (1); 
    declare v_t0 date default null ; 
    declare v_t1 date default null ; 
    declare v_1t date default null; 
    declare v_buss_date date default null; 
    declare v_dayend_performed varchar(1); 
    declare v_sum_stock bigint default 0; 
    declare v_sum_quantity bigint default 0; 

    set o_ret_code = 0; 
    set o_ret_message = "Success";
    set v_space = ' ';
    set YYYYMMDD  = date_format(i_generate_date,'%Y%m%d');
    set v_file_name = 'ATI BATCH INPUT'; 
    set v_zero = '0';

    
    
    select buss_date,day_end_performed into v_buss_date,v_dayend_performed from sys_info; 

    
    truncate table CheckWarnings; 
    insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 
        1,
        'ATI_FILE',
        i_market_id,
        '',
        '',
        '市场不存在',
        'JC_clearing',
        now()
    where not exists(select 1 from market where market_id = i_market_id);
    
    if exists(select 1 from CheckWarnings) then 
        set o_ret_code = 1; 
        set o_ret_message = 'market not exists';
        select o_ret_code,o_ret_message,'';
        leave label;
    end if; 

    
    set v_member_id = '';
    select member_id into v_member_id 
    from market 
    where market_id = i_market_id;

    if v_member_id = ''  or v_member_id is null then 
        set o_ret_code = 2; 
        set o_ret_message = concat("member id is not setted up");
        select o_ret_code,o_ret_message,'';
        leave label;
    end if; 


    
    

    set v_t0  =  null; 
    if (YYYYMMDD = v_buss_date and v_dayend_performed <>'Y')  then 
        select max(calendar_day) into v_t0 from calendar where market_id = i_market_id and  calendar_day < YYYYMMDD and holiday <> 'Y';
    elseif (YYYYMMDD = v_buss_date and v_dayend_performed  = 'Y') then 
        select max(calendar_day) into v_t0 from calendar where market_id = i_market_id and calendar_day <= YYYYMMDD and holiday <> 'Y';
    elseif (YYYYMMDD < v_buss_date) then 
        select max(calendar_day) into v_t0 from calendar where market_id = i_market_id and calendar_day <= YYYYMMDD and holiday <> 'Y';       
    end if ; 
    if v_t0 is null then 
        set o_ret_code = 3; 
        set o_ret_message = concat("cannot get t0 day");
        select o_ret_code,o_ret_message,'';
        leave label;
    end if; 

    select v_t0;

    set v_t1  = NULL; 
    select min(calendar_day) into v_t1 from calendar where market_id = i_market_id and calendar_day>YYYYMMDD and holiday <> 'Y'; 
    
    set v_1t  = NULL; 
    select max(calendar_day) into v_1t from calendar where market_id = i_market_id and calendar_day<YYYYMMDD and holiday <> 'Y'; 
    select v_1t;
    select v_t1;
    if v_t1 is null  then 
        set o_ret_code = 4; 
        set o_ret_message = concat("cannot get t1 day");
        select o_ret_code,o_ret_message,'';
        leave label;
    end if; 

    start transaction; 

    
    if not exists(select 1 from ati_index where generate_date = i_generate_date) then 
        set v_count = 1; 
        insert into ati_index(generate_date,cnt,update_user,update_time)
            select i_generate_date,v_count,i_update_user,now();
    else 
        update ati_index set cnt = cnt+1 where generate_date = i_generate_date; 
        select cnt into v_count from ati_index where generate_date = i_generate_date; 
    end if; 


    drop table if EXISTS result; 
    create temporary table result
    (
        id int auto_increment primary key ,
        type int,
        product_id varchar(16),
        txt varchar(128), 
        index idx1(product_id)
    );

    insert into result
    
    select 
    NULL,
    0,
    '',
    concat('0', rjust(v_count,4,v_zero), ljust(v_member_id,6,v_space), ljust('',8,v_space), ljust(concat('ATI',v_count),15,v_space), YYYYMMDD, ljust(v_file_name,15,v_space), ljust('',42,v_space));

    

    
    drop table if exists custodian_account_position_summary; 
    create temporary table custodian_account_position_summary
    (
        id int auto_increment primary key, 
        custodian_code varchar(16),     
        custodian_account varchar(16), 
        from_custodian_account varchar(16), 
        to_custodian_account varchar(16), 
        market_id int, 
        product_id varchar(16), 
        com_quantity decimal(30,10) default 0,   
        off_quantity decimal(30,10) default 0,   
        value decimal(30,10) default 0, 
        index idx1(custodian_code,custodian_account,market_id,product_id)
    );

    if i_file_id = 'HKEX_ATI2_BATCH' or i_file_id = 'SSE_ATI2_BATCH' or i_file_id = 'SZSE_ATI2_BATCH' then
        
        insert into custodian_account_position_summary
        (
            custodian_code, 
            custodian_account,
            from_custodian_account, 
            to_custodian_account, 
            market_id, 
            product_id, 
            com_quantity,  
            value
        )
        select 
            	c.custodian_code, 
                c.custodian_account,
                1 as from_custodian_account,
                c.custodian_account as to_custodian_account,
                a.market_id, 
                a.product_id,
                sum(a.quantity) as quantity,
                sum(a.quantity) as value
        from settled_position a
        inner join account_type_custodian c on c.market_id = a.market_id and c.account_type = a.account_type
        where a.settle_date = case when i_market_id = 1 then v_t0 else v_t1 end and a.market_id = i_market_id
        group by a.product_id,a.account_type
        having(quantity > 0) 
        order by a.product_id,c.custodian_account;

    elseif i_file_id = 'HKEX_ATI1_BATCH' or i_file_id = 'SSE_ATI1_BATCH' or i_file_id = 'SZSE_ATI1_BATCH' then
        
        insert into custodian_account_position_summary
        (
            custodian_code, 
            custodian_account,
            from_custodian_account, 
            to_custodian_account, 
            market_id, 
            product_id, 
            com_quantity, 
            value
        )
        select
            custodian_code, 
            custodian_account,
            case when quantity > 0 then 1 else custodian_account end as from_custodian_account,
            case when quantity > 0 and custodian_account = 1 then 5 when quantity > 0 and custodian_account <> 1 then custodian_account when quantity < 0 then 1 end as to_custodian_account,
            market_id, 
            product_id,
            quantity,
            case when quantity>0 then 1 else -1 end *quantity
        from
        (
            select 
                c.custodian_code,
                c.custodian_account, 
                a.market_id,
                a.product_id,
                sum(case when a.buy_sell = 1 then 1 else -1 end * a.quantity) as quantity
            from account_trade a 
            inner join account_type_custodian c on a.market_id = c.market_id and a.account_type = c.account_type
            where a.settle_date = case when i_market_id = 1 then v_t0 else v_t1 end and a.market_id = i_market_id
            group by a.product_id,c.custodian_account
            having(quantity <0)
            union
            select 
                a.custodian_code as custodian_code,
                a.custodian_account as custodian_account,
                a.market_id as market_id,
                a.product_id as product_id,
                ifnull(sum(a.quantity),0) - ifnull(b.quantity,0) as quantity
            from account_position a 
            left join custodian_account_position b on b.process_date = v_1t and  b.market_id = a.market_id and b.product_id = a.product_id and b.custodian_account = a.custodian_account
            where a.process_date = case when i_market_id = 1 then v_1t else v_t0 end and a.market_id = i_market_id
            group by a.product_id,a.custodian_account
            having(quantity > 0)
            union
            select 
                custodian_code,
                custodian_account, 
                market_id,
                product_id,
                quantity 
            from custodian_account_position
            where process_date = v_1t and
                market_id = i_market_id and 
                custodian_code = 'CCASS' and 
                custodian_account = '2'
        ) t order by t.product_id,from_custodian_account,to_custodian_account;

    end if;

    
    if exists (select 1 from custodian_account_position where  process_date = v_1t and market_id = i_market_id) then 

            insert into result
            select
            NULL,
            1,
            a.product_id,
            concat(
                '1',
                rjust(a.product_id,5,v_zero),  
                ljust('',12,v_space),
                rjust(a.from_custodian_account,8,v_zero),
                rjust(a.to_custodian_account,8,v_zero),
                rjust(ceil(a.value),11,v_zero),
                ljust('',40,v_space),
                rjust(a.product_id + ceil(a.value),14,v_zero)
            ) 
            from custodian_account_position_summary a;
    else
        rollback;  
        set o_ret_code = 1; 
        set o_ret_message = concat("need import custodian account on ", v_1t ); 
        select o_ret_code,o_ret_message,'';
        leave label; 

    end if;

    select ifnull(count(*),0),ifnull(sum(product_id),0),ifnull(sum(value),0) into v_count,v_sum_stock,v_sum_quantity
    from custodian_account_position_summary; 

    insert into result
    select 
    NULL,
    2,
    '',
    concat('2',rjust(v_count,4,'0'),rjust(v_sum_stock,7,'0'),rjust(v_sum_quantity,14,'0'),rjust(v_sum_quantity+v_sum_stock,17,'0'),ljust('',56,v_space));
    select txt from result order by type,product_id,id;
    select o_ret_code, o_ret_message, txt from result order by type,product_id,id;
    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proQueryMenuPrivilege
-- ----------------------------
DROP PROCEDURE IF EXISTS `proQueryMenuPrivilege`;
delimiter ;;
CREATE PROCEDURE `proQueryMenuPrivilege`(in  i_user varchar(32))
label:begin 

    if not exists(
        select 1 
        from user 
        where user_id = i_user
    ) then 
        leave label;
    end if; 

    select user_id, 
           menu_id, 
           name, 
           visible
    from user_privilege
    where user_id = i_user;

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proQueryPlacingResult
-- ----------------------------
DROP PROCEDURE IF EXISTS `proQueryPlacingResult`;
delimiter ;;
CREATE PROCEDURE `proQueryPlacingResult`(in i_ipo_id varchar(32), 
    in i_update_user varchar(32),
    out o_ret_code int, 
    out o_ret_message varchar(64))
label:begin

    start transaction; 
    SET o_ret_code = 0, o_ret_message = "Success";
    IF NOT EXISTS(SELECT 1 FROM product_ipo_announcement WHERE ipo_id = i_ipo_id) THEN
        SET o_ret_code = 1, o_ret_message = "ipo_id not exist";
        LEAVE label;
    END IF;

    drop temporary table if EXISTS result; 
    create temporary table result
    (
        id int auto_increment primary key,
        txt varchar(256), 
        index idx1(id)
    );

    insert into result
    select 
        NULL,
        concat(
            a.account_id,
            ',',
            replace(b.short_name,',',' '),
            ',',
            concat("'",ifnull(b.photoid,'')),
            ',',
            replace(b.mailing_address,',',' '),
            ',',
            replace(b.phone1,',',' '),
            ',',
            round(a.quantity,2),
            ',',
            round(a.amount,2)
        )
    from product_ipo_app a
    inner join account_profile b on b.account_id = a.account_id
    where a.ipo_id = i_ipo_id and sub_status = 2;

    select o_ret_code, o_ret_message, txt from result order by id;
    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proQueryStamp
-- ----------------------------
DROP PROCEDURE IF EXISTS `proQueryStamp`;
delimiter ;;
CREATE PROCEDURE `proQueryStamp`(in i_market_id int, 
    in i_file_id varchar(32),
    in i_generate_date date, 
    in i_update_user varchar(32),
    out o_ret_code int, 
    out o_ret_message varchar(64))
label:begin
    declare v_count int default 0 ;   
    declare YYYYMMDD varchar(8);
    declare v_buss_date date default null; 
    declare v_dayend_performed varchar(1); 
    declare v_sum_amount int default 0;
    declare v_sum_charges int default 0;
    declare v_variance int default 0;
    declare v_t0 date default null ; 
    declare v_t1 date default null ; 
    declare v_1t date default null; 
    set o_ret_code = 0; 
    set o_ret_message = "Success";
    set YYYYMMDD  = date_format(i_generate_date,'%Y%m%d');

    
    truncate table CheckWarnings; 


    
    select buss_date,day_end_performed into v_buss_date,v_dayend_performed from sys_info; 

    
    insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 
        1,
        'ATI_FILE',
        i_market_id,
        '',
        '',
        '市场不存在',
        'JC_clearing',
        now()
    where not exists(select 1 from market where market_id = i_market_id);
    
    if exists(select 1 from CheckWarnings) then 
        set o_ret_code = 1; 
        set o_ret_message = 'market not exists';
        select o_ret_code,o_ret_message,'';
        leave label;
    end if; 

    set v_t0  =  null; 
    if (YYYYMMDD = v_buss_date and v_dayend_performed <>'Y')  then 
        select max(calendar_day) into v_t0 from calendar where market_id = i_market_id and  calendar_day <= YYYYMMDD and holiday <> 'Y';
    elseif (YYYYMMDD = v_buss_date and v_dayend_performed  = 'Y') then 
        select max(calendar_day) into v_t0 from calendar where market_id = i_market_id and calendar_day <= YYYYMMDD and holiday <> 'Y';
    elseif (YYYYMMDD < v_buss_date) then 
        select max(calendar_day) into v_t0 from calendar where market_id = i_market_id and calendar_day <= YYYYMMDD and holiday <> 'Y';       
    end if ; 
    if v_t0 is null then 
        set o_ret_code = 3; 
        set o_ret_message = concat("cannot get t0 day");
        select o_ret_code,o_ret_message,'';
        leave label;
    end if; 

    set v_t1  = NULL; 
    select min(calendar_day) into v_t1 from calendar where market_id = i_market_id and calendar_day>YYYYMMDD and holiday <> 'Y'; 
    
    set v_1t  = NULL; 
    select max(calendar_day) into v_1t from calendar where market_id = i_market_id and calendar_day<YYYYMMDD and holiday <> 'Y'; 

    if v_t1 is null  then 
        set o_ret_code = 4; 
        set o_ret_message = concat("cannot get t1 day");
        select o_ret_code,o_ret_message,'';
        leave label;
    end if; 

    start transaction; 

    
    if not exists(select 1 from ati_index where generate_date = i_generate_date) then 
        set v_count = 1; 
        insert into ati_index(generate_date,cnt,update_user,update_time)
            select i_generate_date,v_count,i_update_user,now();
    else 
        update ati_index set cnt = cnt+1 where generate_date = i_generate_date; 
        select cnt into v_count from ati_index where generate_date = i_generate_date; 
    end if; 

 
    drop temporary table if EXISTS result; 
    create temporary table result
    (
        id int auto_increment primary key,
        txt varchar(256), 
        index idx1(id)
    );

    select 
    ceil(sum(b.charges* a.exchange_rate)) as sum_charges,
	ceil(sum((a.trade_amount*a.exchange_rate)*1/10/100) ) as sum_amount,
	ceil(sum(b.charges* a.exchange_rate)) - ceil(sum(a.trade_amount*a.exchange_rate) * 1/10/100) as variance
    into 
        v_sum_charges,v_sum_amount,v_variance
    from account_trade a 
    inner join account_charge b on b.process_date = a.process_date and b.charge_code = 'STAMP_HK:HK' and b.external_id = a.trade_id and b.charges<> 0 
    where a.process_date = v_t0 and a.STATUS = 'Confirmed' and a.market_id = 1 and a.input_channel <> 5;

    
    
    

    update export_stamp_file
        set quantity = date_format(v_t0,'%Y%m%d')
    where table_list = 'e';

    update export_stamp_file
        set quantity = ifnull(cast(v_sum_charges as CHAR(64)),'0')
    where table_list = 'f';

    update export_stamp_file
        set quantity = ifnull(cast(v_sum_amount as CHAR(64)),'0')
    where table_list = 'g';

    update export_stamp_file
        set quantity = ifnull(cast(v_variance as CHAR(64)),'0')
    where table_list = 'h';

    insert into result
        select
            NULL,
            concat(
            '"',
            ifnull(a.title,''),
            '","',
            ifnull(a.space1,''),
            '","',
            ifnull(a.space2,''),
            '","',
            ifnull(a.quantity,''),
            '","',
            ifnull(a.space3,''),
            '","',
            ifnull(a.space4,''),
            '","',
            ifnull(a.table_list,''),
            '",'
        ) from export_stamp_file a;

    select o_ret_code, o_ret_message, txt from result order by id;
    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proQueryTradeReply
-- ----------------------------
DROP PROCEDURE IF EXISTS `proQueryTradeReply`;
delimiter ;;
CREATE PROCEDURE `proQueryTradeReply`(in i_product_id varchar(32), 
    in i_process_date_start date, 
    in i_process_date_end date, 
    in i_update_user varchar(32),
    out o_ret_code int, 
    out o_ret_message varchar(64))
label:begin

    set o_ret_code = 0; 
    set o_ret_message = "Success";

    truncate table CheckWarnings; 


    
    insert into CheckWarnings
    (
        warn_type,
        file_name,
        list_market_id,
        product_id,
        account_id,
        remark,
        update_user,
        update_time
    )
    select 
        1,
        'Trade_Reply',
        '',
        i_product_id,
        '',
        '产品不存在',
        'JC_clearing',
        now()
    where not exists(select 1 from product where product_id = i_product_id);
    
    if exists(select 1 from CheckWarnings) then 
        set o_ret_code = 1; 
        set o_ret_message = 'product not exists';
        select o_ret_code,o_ret_message,'';
        leave label;
    end if; 

    start transaction; 

    drop temporary table if EXISTS result; 
    create temporary table result
    (
        id int auto_increment primary key,
        txt varchar(512), 
        index idx1(id)
    );

    insert into result
        select
            NULL,
            concat(
            '"',
            ifnull(a.process_date,''),
            '","',
            ifnull(b.short_name,''),
            '","',
            ifnull(b.photoid,''),
            '","',
            ifnull((case a.buy_sell when 1 then 1 else 0 end * a.quantity),''),
            '","',
            ifnull((case a.buy_sell when 1 then 0 else 1 end * a.quantity),''),
            '","',
            ifnull(round(a.avg_price,3),''),
            '","',
            ifnull(b.phone1,''),
            '","',
            ifnull(b.mailing_address,''),
            '","',
            ifnull(b.short_name,''),
            '","',
            ifnull(a.broker,''),
            '","Zinvest Global Limited","N",'
            )
        from account_trade a 
        inner join account_profile b on b.account_id = a.account_id 
        where a.process_date >= i_process_date_start and a.process_date <= i_process_date_end and a.status = 'Confirmed' and a.product_id = i_product_id
        group by a.process_date,b.short_name,a.buy_sell
        order by a.process_date desc;

    select o_ret_code, o_ret_message,txt from result order by id;
    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proQueryUnsettledQty
-- ----------------------------
DROP PROCEDURE IF EXISTS `proQueryUnsettledQty`;
delimiter ;;
CREATE PROCEDURE `proQueryUnsettledQty`(in  i_event_id varchar(128),
    OUT o_ret_code int,
    OUT o_ret_msg char(128))
label:begin
    DECLARE v_calendar_day date;
    DECLARE v_process_date date;
    DECLARE v_t2 date;
    declare v_account_id varchar(16) default NULL;
    declare v_product_id varchar(32) default '';
    declare v_market_id int default 0;   
    declare v_register_date date default null;
    declare v_ratio_from decimal(30,10);
    declare v_ratio_to decimal(30,10);
    declare v_done int; 
    
    DECLARE cur_account CURSOR FOR 
    select account_id from corp_action_detail where event_id = i_event_id;

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1; 

    set o_ret_code = '0'; 
    set o_ret_msg = 'Success';

    select buss_date into v_process_date from sys_info;

    DROP TEMPORARY TABLE IF EXISTS tmp_unsettled_qty;
    CREATE TEMPORARY TABLE tmp_unsettled_qty 
    (
        `account_id`        VARCHAR(16) NULL DEFAULT NULL,
        `unsettle_qty`      DECIMAL(30,10) NULL DEFAULT 0.00,
        `dividend_un_qty` DECIMAL(30,10) NULL DEFAULT 0.00
    );

    select market_id,product_id,ifnull(ratio_from,0),ifnull(ratio_to,0)
    into v_market_id,v_product_id,v_ratio_from,v_ratio_to
    from corp_action where event_id = i_event_id;

    OPEN cur_account;
        SET v_done = 0;
        FETCH cur_account INTO v_account_id;
        WHILE v_done <> 1 DO

            insert into tmp_unsettled_qty
            select  v_account_id AS account_id,
                    ifnull(sum(quantity),0) AS unsettle_qty,
                    case when ifnull(sum(quantity),0) <> 0 then ifnull(sum(quantity),0)/abs(ifnull(sum(quantity),0))*floor( abs(ifnull(sum(quantity),0))  * v_ratio_to / v_ratio_from) else 0 end  as dividend_un_qty
            from jcbms.unsettled_position 
            where settle_date >= v_process_date and account_id = v_account_id and market_id = v_market_id and product_id = v_product_id;

            set v_done = 0; 
            fetch cur_account into v_account_id; 
        end while; 
    close cur_account;

    select a.* From tmp_unsettled_qty a;

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proQueryUSTradeSum
-- ----------------------------
DROP PROCEDURE IF EXISTS `proQueryUSTradeSum`;
delimiter ;;
CREATE PROCEDURE `proQueryUSTradeSum`(in i_account_id varchar(32), 
    in i_market_id varchar(32),
    in i_ConfirmedStatus varchar(32), 
    in i_input_channel varchar(32),
    in i_broker varchar(32),
    in i_is_odd_lot varchar(32),
    out o_ret_code int, 
    out o_ret_message varchar(64))
label:begin 
    DECLARE v_count int;
    DECLARE v_quantity decimal(30,10) DEFAULT '0.000000';
    DECLARE v_amount decimal(30,10) DEFAULT '0.000000';
    DECLARE v_num_of_trade int;
    DECLARE v_sub_quantity decimal(30,10) DEFAULT '0.000000';
    DECLARE v_trade_amount decimal(30,10) DEFAULT '0.000000';
    declare v_process_date date default null;
    set o_ret_code = 0; 
    set o_ret_message = "Success";
    start transaction;  

    select buss_date into v_process_date from sys_info;

    
    drop temporary table  if EXISTS tmp_account_trade;
    CREATE  temporary TABLE `tmp_account_trade` (
        `id` bigint(11) NOT NULL AUTO_INCREMENT,
        `process_date` date DEFAULT NULL,
        `trade_date` date DEFAULT NULL,
        `settle_date` date DEFAULT NULL,
        `trade_id` char(32) DEFAULT NULL,
        `business_department` char(16) DEFAULT NULL,
        `department_trading_group` char(16) DEFAULT NULL,
        `account_id` char(16) DEFAULT NULL,
        `account_type` int(11) DEFAULT NULL,
        `market_id` int DEFAULT 0,
        `list_market_id` int DEFAULT 0,
        `product_id` varchar(32) DEFAULT NULL,
        `product_description` VARCHAR(255) DEFAULT NULL,
        `product_type` int(11) DEFAULT NULL,
        `product_sub_type` char(16) DEFAULT NULL,
        `quote_currency` char(3) DEFAULT NULL,
        `clearing_currency` char(3) DEFAULT NULL,
        `exchange_rate` decimal(30,10) DEFAULT NULL,
        `buy_sell` int(11) DEFAULT NULL,
        `quantity` decimal(21,6) DEFAULT '0.000000',
        `avg_price` decimal(21,6) DEFAULT '0.000000',
        `trade_amount` decimal(30,10) DEFAULT '0.0000000000',
        `net_amount` decimal(30,10) DEFAULT '0.0000000000',
        `open_close` int(11) DEFAULT NULL,
        `hedge_flag` int(11) DEFAULT NULL,
        `call_put` int(11) DEFAULT NULL,
        `strike_price` decimal(30,10) DEFAULT NULL,
        `contract_date` date DEFAULT NULL,
        `input_channel` int(11) DEFAULT NULL,
        `remark` text,
        `num_of_trades` int(11) DEFAULT NULL,
        `order_no` char(32) DEFAULT NULL,
        `order_date`  date DEFAULT NULL,
        `update_time` varchar(30) DEFAULT NULL,
        `update_user` char(16) DEFAULT NULL,
        commission decimal(30,10),
        charges   decimal(30,10),
        `custodian_code` char(16) DEFAULT NULL,
        `custodian_account` char(16) DEFAULT NULL,
        `broker` char(16) DEFAULT NULL,
        PRIMARY KEY (`id`)
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
        create index Index1 on tmp_account_trade (trade_id);
        create index Index2 on tmp_account_trade (order_date,order_no);
        create index Index3 on tmp_account_trade (trade_date,account_id,account_type,list_market_id,product_id,buy_sell,input_channel);
        create index Index4 on tmp_account_trade (process_date,market_id,product_id,account_id,account_type,buy_sell,input_channel);

    insert into tmp_account_trade
    (
        process_date,
        trade_date ,
        settle_date,
        trade_id,
        business_department ,
        department_trading_group ,
        account_id,
        account_type ,
        market_id ,
        list_market_id ,
        product_id ,
        product_description ,
        product_type ,
        product_sub_type,
        quote_currency,
        clearing_currency ,
        exchange_rate,
        buy_sell ,
        quantity,
        avg_price,
        trade_amount ,
        net_amount ,
        open_close ,
        hedge_flag,
        call_put ,
        strike_price ,
        contract_date ,
        input_channel,
        remark,
        num_of_trades ,
        order_no,
        order_date ,
        update_time,
        update_user,
        custodian_code,
        custodian_account,
        broker
    )
    select 
        v_process_date,
        a.trade_date ,
        max(a.settle_date),
         concat(date_format(v_process_date, "%Y%m%d"), right(concat('0000000000',funGenerateID(v_process_date)),10)),
        max(a.business_department) ,
        max(a.department_trading_group) ,
        a.account_id,
        a.account_type ,
        max(a.market_id) ,
        a.list_market_id ,
        a.product_id ,
        max(a.product_description) ,
        max(a.product_type) ,
        max(a.product_sub_type),
        max(a.quote_currency),
        max(a.clearing_currency) ,
        max(a.exchange_rate),
        a.buy_sell ,
        ifnull(sum(exec_quantity), 0),
        ifnull(sum(a.trade_amount) / sum(exec_quantity), 0),
        ifnull(round(sum(a.trade_amount),2),0) ,
        ifnull(round(sum(a.net_amount),2), 0),
        max(a.open_close) ,
        max(a.hedge_flag),
        max(a.call_put) ,
        max(a.strike_price) ,
        max(a.contract_date) ,
        max(a.input_channel),
        max(a.remark),
        count(*) ,
        max(a.order_no),
        max(a.order_date) ,
        now(),
        'JC_Clearing',
        a.custodian_code,
        a.custodian_account,
        a.broker
    from import_account_trade_detail a 
    inner join market b on a.list_market_id = b.market_id 
    where (i_account_id = '' or a.account_id = i_account_id) and 
          (i_market_id = '' or a.market_id = i_market_id) and
          (i_ConfirmedStatus = '' or a.ConfirmStatus = i_ConfirmedStatus) and 
          (i_input_channel = '' or a.input_channel = i_input_channel) and 
          (i_broker = '' or a.broker = i_broker) and 
          case when i_is_odd_lot = 'Y' then is_odd_lot <> 'Y' else 1 = 1 end
    group by 
        case  b.group_by_order when 'Y' then a.order_no else '0' end,
        trade_date ,
        account_id,
        account_type ,
        list_market_id,
        product_id,
        buy_sell,
        case b.group_by_order when 'Y' then a.order_date else '' end,
        input_channel,
        a.custodian_code,
        a.custodian_account,
        a.broker;

    select count(1),sum(quantity),sum(trade_amount)
    into v_count,v_quantity,v_amount
    from tmp_account_trade a;

    select count(1),sum(exec_quantity),sum(trade_amount)
    into v_num_of_trade,v_sub_quantity,v_trade_amount 
    from import_account_trade_detail a 
    where (i_account_id = '' or a.account_id = i_account_id) and 
          (i_market_id = '' or a.market_id = i_market_id) and
          (i_ConfirmedStatus = '' or a.ConfirmStatus = i_ConfirmedStatus) and 
          (i_input_channel = '' or a.input_channel = i_input_channel) and 
          (i_broker = '' or a.broker = i_broker) and 
          case when i_is_odd_lot = 'Y' then is_odd_lot <> i_is_odd_lot else 1 = 1 end;

    select o_ret_code,o_ret_message,v_num_of_trade,v_sub_quantity,v_trade_amount,v_count,v_quantity,v_amount;

    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proRecalculationCorpAction
-- ----------------------------
DROP PROCEDURE IF EXISTS `proRecalculationCorpAction`;
delimiter ;;
CREATE PROCEDURE `proRecalculationCorpAction`(IN  i_event_id varchar(128),
  IN  i_account_id varchar(16),
  IN  i_update_user varchar(32), 
  IN  i_update_time datetime,
  OUT o_ret_code int, 
  OUT o_ret_msg varchar(64))
label:begin
    
    declare v_product_id varchar(32) default ''; 
    declare v_market_id int; 

    declare v_charge1 varchar(32) default '';
    declare v_charge2 varchar(32) default ''; 
    declare v_charge3 varchar(32) default ''; 
    declare v_charge4 varchar(32) default ''; 
    declare v_charge5 varchar(32) default ''; 
    declare v_sub_charge1 varchar(32) default '';
    declare v_sub_charge2 varchar(32) default '';
    declare v_sub_charge3 varchar(32) default '';
    declare v_sub_charge4 varchar(32) default '';
    declare v_lot_size decimal(30,10);
    declare v_formula1 varchar(255) default '0';  
    declare v_formula2 varchar(255) default '0'; 
    declare v_formula3 varchar(255) default '0'; 
    declare v_formula4 varchar(255) default '0'; 
    declare v_formula5 varchar(255) default '0'; 
    declare v_sub_formula1 varchar(255) default '0'; 
    declare v_sub_formula2 varchar(255) default '0';
    declare v_sub_formula3 varchar(255) default '0';
    declare v_sub_formula4 varchar(255) default '0'; 
    declare v_to_product_id varchar(32) default ''; 
    
    select a.product_id,  
           a.market_id,
           a.to_product_id
    into v_product_id,
         v_market_id,
         v_to_product_id
    from corp_action a
    where a.event_id = i_event_id;

    select ifnull(lot_size,1)  into v_lot_size from product where list_market_id = v_market_id and product_id = v_product_id; 

    
    
    update corp_action_detail a 
    inner join corp_action b on i_event_id = b.event_id
    set a.dividend_amount = case when b.scrip_price <> 0 then 0 else round(a.apply_quantity * b.dividend_rate,2) end, 
        a.dividend_quantity = case when (v_to_product_id is null or v_to_product_id = '00000') then 0 
             else (case when (b.ratio_to = 0 or b.ratio_from = 0) then 0 else floor(a.apply_quantity * b.ratio_to/b.ratio_from) end )
                + (case when b.scrip_price <> 0 then (floor(round(a.apply_quantity * b.dividend_rate,2)/b.scrip_price)) else 0 end) end
    where a.event_id = i_event_id and (i_account_id  = '' or a.account_id = i_account_id);

    
    drop temporary table if EXISTS cal; 
    create temporary table cal
    (
        id bigint primary key,   
        QTY decimal(30,10),   
        LOT decimal(30,10), 
        CASH decimal(30,10), 
        RIGHTS_LOT decimal(30,10) DEFAULT 1,
        STREET_QTY decimal(30,10), 
        EXERCISE_QTY decimal(30,10),    
        EXCESS_EXERCISE_QTY decimal(30,10), 
        charge1 decimal(30,10) DEFAULT 0,
    	charge2 decimal(30,10) DEFAULT 0,
        charge3 decimal(30,10) DEFAULT 0,
    	charge4 decimal(30,10) DEFAULT 0,
    	charge5 decimal(30,10) DEFAULT 0,
        subscribe_charge1 decimal(30,10) DEFAULT 0,
        subscribe_charge2 decimal(30,10) DEFAULT 0,
        subscribe_charge3 decimal(30,10) DEFAULT 0,
        subscribe_charge4 decimal(30,10) DEFAULT 0
    );

    
    insert into cal 
    (
        id, 
        QTY,
        LOT, 
        CASH,
        STREET_QTY, 
        EXERCISE_QTY, 
        EXCESS_EXERCISE_QTY
    )
    select 
        a.id,
        a.apply_quantity, 
        v_lot_size, 
        a.dividend_amount, 
        a.non_nominee_quantity, 
        a.excercise_quantity, 
        a.excess_quantity
    from 
    corp_action_detail a
    where a.event_id = i_event_id and 
          (i_account_id = '' or account_id = i_account_id);

    
    select ifnull(charge_id1,''),
           ifnull(charge_id2,''),
           ifnull(charge_id3,''),
           ifnull(charge_id4,''),
           ifnull(charge_id5,''),
           ifnull(subscribe_charge_id1,''),
           ifnull(subscribe_charge_id2,''),
           ifnull(subscribe_charge_id3,''),
           ifnull(subscribe_charge_id4,'')
        into 
           v_charge1,
           v_charge2,
           v_charge3,
           v_charge4,
           v_charge5,
           v_sub_charge1,
           v_sub_charge2,
           v_sub_charge3,
           v_sub_charge4
        from corp_action 
        where event_id = i_event_id;

    select 
        ifnull(b.formula_value,0) into  v_formula1
    from market_charge_rule a
    inner join formula b  on 'CORP' = b.formula_type and a.formula_code = b.formula_code
    where a.market_id  = v_market_id and a.charge_code = v_charge1; 

    select 
        ifnull(b.formula_value,0) into  v_formula2
    from market_charge_rule a
    inner join formula b  on 'CORP' = b.formula_type and a.formula_code = b.formula_code
    where a.market_id  = v_market_id and a.charge_code = v_charge2; 

    select 
        ifnull(b.formula_value,0) into  v_formula3
    from market_charge_rule a
    inner join formula b  on 'CORP' = b.formula_type and a.formula_code = b.formula_code
    where a.market_id  = v_market_id and a.charge_code = v_charge3; 

    select 
        ifnull(b.formula_value,0) into  v_formula4
    from market_charge_rule a
    inner join formula b  on 'CORP' = b.formula_type and a.formula_code = b.formula_code
    where a.market_id  = v_market_id and a.charge_code = v_charge4;

    select 
        ifnull(b.formula_value,0) into  v_formula5
    from market_charge_rule a
    inner join formula b  on 'CORP' = b.formula_type and a.formula_code = b.formula_code
    where a.market_id  = v_market_id and a.charge_code = v_charge5; 

    select 
        ifnull(b.formula_value,0) into  v_sub_formula1
    from market_charge_rule a
    inner join formula b  on 'CORP' = b.formula_type and a.formula_code = b.formula_code
    where a.market_id  = v_market_id and a.charge_code = v_sub_charge1; 

    select 
        ifnull(b.formula_value,0) into  v_sub_formula2
    from market_charge_rule a
    inner join formula b  on 'CORP' = b.formula_type and a.formula_code = b.formula_code
    where a.market_id  = v_market_id and a.charge_code = v_sub_charge2; 

    select 
        ifnull(b.formula_value,0) into  v_sub_formula3
    from market_charge_rule a
    inner join formula b  on 'CORP' = b.formula_type and a.formula_code = b.formula_code
    where a.market_id  = v_market_id and a.charge_code = v_sub_charge3; 

    select 
        ifnull(b.formula_value,0) into  v_sub_formula4
    from market_charge_rule a
    inner join formula b  on 'CORP' = b.formula_type and a.formula_code = b.formula_code
    where a.market_id  = v_market_id and a.charge_code = v_sub_charge4; 


    
    SET @sql = CONCAT('update cal ',
                        'set charge1 = ', v_formula1, ' ',
                        ',charge2 = ', v_formula2, ' ',
                        ',charge3 = ', v_formula3, ' ',
                        ',charge4 = ', v_formula4, ' ',
                        ',charge5 = ', v_formula5, ' ',
                        ',subscribe_charge1 = ', v_sub_formula1, ' ',
                        ',subscribe_charge2 = ', v_sub_formula2, ' ',
                        ',subscribe_charge3 = ', v_sub_formula3, ' ',
                        ',subscribe_charge4 = ', v_sub_formula4, ' '
                        );
    PREPARE stmt FROM @sql;
    EXECUTE stmt;

    UPDATE
    corp_action_detail a
      LEFT JOIN cal b ON a.id = b.id
    SET
        a.charge1 = IFNULL(b.charge1,0),
        a.charge2 = IFNULL(b.charge2,0),
        a.charge3 = IFNULL(b.charge3,0),
        a.charge4 = IFNULL(b.charge4,0),
        a.charge5 = IFNULL(b.charge5,0),
        a.subscribe_charge1 = IFNULL(b.subscribe_charge1,0),
        a.subscribe_charge2 = IFNULL(b.subscribe_charge2,0),
        a.subscribe_charge3 = IFNULL(b.subscribe_charge3,0),
        a.subscribe_charge4 = IFNULL(b.subscribe_charge4,0)
    WHERE
        a.event_id = i_event_id and 
        (i_account_id = '' or a.account_id = i_account_id);

    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proRecordCashFlow
-- ----------------------------
DROP PROCEDURE IF EXISTS `proRecordCashFlow`;
delimiter ;;
CREATE PROCEDURE `proRecordCashFlow`(IN i_proces_date date,
  IN i_settle_date date,
  IN i_account_id char(16),
  IN i_account_type int,
  IN i_currency int,
  IN i_amount decimal(21,6),
  IN i_way int,
  IN i_purpose int,
  In i_remark char(128), 
  In i_remar2 varchar(128), 
  In i_pay_bank_id char(32), 
  In i_pay_check_no char(16),
  In i_pay_bank_account_name char(32), 
  In i_pay_bank_account_id char(32), 
  In i_rec_bank_id char(32), 
  In i_rec_check_no char(16), 
  In i_rec_bank_account_name char(32), 
  In i_rec_bank_account_id char(32), 
  In i_balance decimal(30,10),
  In i_dividend_market_id int, 
  In i_dividend_product_id varchar(32),
  In i_gl_mapping_item_id VARCHAR(64),
  In i_reference          VARCHAR(128),
  In i_custodian_code varchar(16), 
  In i_custodian_account varchar(16),
  In i_input_user char(32), 
  In i_input_time datetime)
label:begin
    declare v_balance decimal(21,6) default 0.0;

    insert into cash_flow(
        process_date,
        settle_date,
        account_id,
        account_type,
        currency,
        balance,
        amount,
        way,
        purpose,
        remark,
        remark2,
        pay_bank_id,
        pay_check_no,
        pay_bank_account_name,
        pay_bank_account_id,
        rec_bank_id,
        rec_check_no,
        rec_bank_account_name,
        rec_bank_account_id,
        dividend_market_id,
        dividend_product_id,
        gl_mapping_item_id,
        reference,
        custodian_code,
        custodian_account,
        update_user,
        update_time
    )
   select i_proces_date,
          i_settle_date,
          i_account_id,
          i_account_type,
          i_currency,
          i_balance,
          i_amount,
          i_way,
          i_purpose,
          i_remark,
          i_remar2,
          i_pay_bank_id,
          i_pay_check_no,
          i_pay_bank_account_name,
          i_pay_bank_account_id,
          i_rec_bank_id,
          i_rec_check_no,
          i_rec_bank_account_name,
          i_rec_bank_account_id,
          i_dividend_market_id,
          i_dividend_product_id,
          i_gl_mapping_item_id,
          i_reference,
          i_custodian_code,
          i_custodian_account,
          i_input_user,
          i_input_time; 
end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proRecordCashFlowCIT
-- ----------------------------
DROP PROCEDURE IF EXISTS `proRecordCashFlowCIT`;
delimiter ;;
CREATE PROCEDURE `proRecordCashFlowCIT`(IN i_proces_date date,
  IN i_account_id char(16),
  IN i_account_type int,
  IN i_currency int,
  IN i_amount decimal(21,6),
  IN i_way int,
  IN i_purpose int,
  In i_remark char(128), 
  In i_remar2 varchar(128), 
  In i_pay_bank_id char(32), 
  In i_pay_check_no char(16),
  In i_pay_bank_account_name char(32), 
  In i_pay_bank_account_id char(32), 
  In i_rec_bank_id char(32), 
  In i_rec_check_no char(16), 
  In i_rec_bank_account_name char(32), 
  In i_rec_bank_account_id char(32), 
  In i_balance decimal(30,10),
  In i_dividend_market_id int, 
  In i_dividend_product_id varchar(32),
  In i_gl_mapping_item_id VARCHAR(64),
  In i_reference          VARCHAR(128),
  In i_custodian_code varchar(16), 
  In i_custodian_account varchar(16),
  In i_input_user char(32), 
  In i_input_time datetime)
label:begin
    declare v_balance decimal(21,6) default 0.0;

    insert into cash_flow_cit(
        process_date,
        account_id,
        account_type,
        currency,
        balance,
        amount,
        way,
        purpose,
        remark,
        remark2,
        pay_bank_id,
        pay_check_no,
        pay_bank_account_name,
        pay_bank_account_id,
        rec_bank_id,
        rec_check_no,
        rec_bank_account_name,
        rec_bank_account_id,
        dividend_market_id,
        dividend_product_id,
        gl_mapping_item_id,
        reference,
        custodian_code,
        custodian_account,
        update_user,
        update_time
    )
   select i_proces_date,
          i_account_id,
          i_account_type,
          i_currency,
          i_balance,
          i_amount,
          i_way,
          i_purpose,
          i_remark,
          i_remar2,
          i_pay_bank_id,
          i_pay_check_no,
          i_pay_bank_account_name,
          i_pay_bank_account_id,
          i_rec_bank_id,
          i_rec_check_no,
          i_rec_bank_account_name,
          i_rec_bank_account_id,
          i_dividend_market_id,
          i_dividend_product_id,
          i_gl_mapping_item_id,
          i_reference,
          i_custodian_code,
          i_custodian_account,
          i_input_user,
          i_input_time; 
end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proRecordOperation
-- ----------------------------
DROP PROCEDURE IF EXISTS `proRecordOperation`;
delimiter ;;
CREATE PROCEDURE `proRecordOperation`(i_user varchar(32),
    i_ip   varchar(64), 
    i_action varchar(32), 
    i_detail text)
label:begin
    insert into operation_record 
        select NULL,i_user,i_ip,i_action,i_detail,now();
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proRecordProductFlow
-- ----------------------------
DROP PROCEDURE IF EXISTS `proRecordProductFlow`;
delimiter ;;
CREATE PROCEDURE `proRecordProductFlow`(IN  i_process_date date, 
    IN  i_settle_date date, 
    IN  i_account_id varchar(16), 
    IN  i_account_type int,
    IN  i_market_id int, 
    IN  i_product_id varchar(32), 
    IN  i_balance decimal(30,10),
    IN  i_quantity decimal(30,10),
    IN  i_custodian_code varchar(16), 
    IN  i_custodian_account varchar(16), 
    IN  i_nominee_quantity decimal(30,10), 
    IN  i_avg_price decimal(30,10), 
    IN  i_avg_price2 decimal(30,10), 
    IN  i_purpose int,
    In  i_remark varchar(128),
    In  i_update_user varchar(32), 
    In  i_update_time datetime)
label:begin
    insert into  product_flow
    (
        
        process_date, 
        settle_date,
        account_id, 
        account_type,
        market_id, 
        product_id, 
        balance, 
        quantity,
        custodian_code, 
        custodian_account, 
        nominee_quantity, 
        avg_price,
        avg_price2, 
        purpose, 
        remark,
        update_user, 
        update_time
    )
    select 
        i_process_date,
        i_settle_date,
        i_account_id, 
        i_account_type,
        i_market_id, 
        i_product_id, 
        i_balance,
        i_quantity, 
        i_custodian_code, 
        i_custodian_account, 
        i_nominee_quantity,
        i_avg_price, 
        i_avg_price2,
        i_purpose,
        i_remark, 
        i_update_user, 
        i_update_time; 
end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proRegistCorpAction
-- ----------------------------
DROP PROCEDURE IF EXISTS `proRegistCorpAction`;
delimiter ;;
CREATE PROCEDURE `proRegistCorpAction`(IN  i_event_id varchar(128),
  IN  i_account_id varchar(16),
  IN  i_custodian_code varchar(256),
  IN  i_update_user varchar(32), 
  IN  i_update_time datetime,
  OUT o_ret_code int, 
  OUT o_ret_msg varchar(64))
label:begin
    
    declare v_scrip_fee varchar(1) default ''; 
    declare v_register_date date default null; 
    declare v_book_closed varchar(1) default 'N'; 
    declare v_event_id varchar(128) default NULL; 
    declare v_product_id varchar(32) default ''; 
    declare v_to_product_id varchar(32) default ''; 
    declare v_currency int default 0;
    declare v_market_id int;   
    declare v_lot_size decimal(30,10);
    declare v_done int default 0; 
    declare v_event_type varchar(32) default'';
    declare v_dividend_ccy int(11) default 0;
    declare v_charge1 varchar(32) default '';
    declare v_charge2 varchar(32) default ''; 
    declare v_charge3 varchar(32) default ''; 
    declare v_charge4 varchar(32) default ''; 
    declare v_charge5 varchar(32) default ''; 
    declare v_sub_charge1 varchar(32) default '';
    declare v_sub_charge2 varchar(32) default '';
    declare v_sub_charge3 varchar(32) default '';
    declare v_sub_charge4 varchar(32) default '';

    declare v_wavie1 varchar(1); 
    declare v_wavie2 varchar(1); 
    declare v_wavie3 varchar(1); 
    declare v_wavie4 varchar(1); 
    declare v_wavie5 varchar(1); 
    declare v_sub_wavie1 varchar(1); 
    declare v_sub_wavie2 varchar(1); 

    declare v_formula1 varchar(255) default '0';  
    declare v_formula2 varchar(255) default '0'; 
    declare v_formula3 varchar(255) default '0'; 
    declare v_formula4 varchar(255) default '0'; 
    declare v_formula5 varchar(255) default '0'; 
    declare v_sub_formula1 varchar(255) default '0'; 
    declare v_sub_formula2 varchar(255) default '0';
    declare v_sub_formula3 varchar(255) default '0';
    declare v_sub_formula4 varchar(255) default '0'; 
    declare v_process_date date default NULL; 
    declare v_id bigint default 0; 
    DECLARE v_remove_original_quantity varchar(1) DEFAULT '';
    declare v_convert_bal varchar(1) default ''; 
    declare v_optional varchar(1) DEFAULT '';
    declare v_default varchar(1) DEFAULT '';
    DECLARE v_un_quantity decimal(30,10);
    DECLARE v_un_quantity_to decimal(30,10);
    DECLARE v_error int;

    DECLARE cur_charge CURSOR FOR
    SELECT
      a.id
    FROM
      corp_action_detail a
    where a.event_id = i_event_id and (ifnull(i_account_id,'') = '' or account_id = ifnull(i_account_id,''));

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = 1; 

    declare CONTINUE HANDLER FOR SQLEXCEPTION
    begin
        GET DIAGNOSTICS CONDITION 1
        o_ret_msg = MESSAGE_TEXT,
        o_ret_code = RETURNED_SQLSTATE; 
        set v_error = 1;
    end; 

    set o_ret_code = 0, o_ret_msg ="Success";
    set v_error = 0 ; 

    start transaction;      

    select buss_date into v_process_date from sys_info; 

    
    select a.event_id, 
           a.register_date, 
           a.book_closed,
           a.product_id, 
           a.to_product_id, 
           a.dividend_ccy, 
           a.market_id, 
           a.event_type, 
           a.optional,
           a.dividend_ccy,
           a.m_default,
           a.scrip_fee
    into v_event_id, 
         v_register_date, 
         v_book_closed,
         v_product_id,
         v_to_product_id, 
         v_currency, 
         v_market_id, 
         v_event_type, 
         v_optional, 
         v_dividend_ccy,
         v_default,
         v_scrip_fee
    from corp_action a
    where a.event_id = i_event_id;

    select 
        ifnull(remove_original_quantity,''),
        ifnull(convert_bal,'')
    into 
        v_remove_original_quantity,
        v_convert_bal
    from market_corp_action
    where
        market = v_market_id and 
        event_type = v_event_type;

    select ifnull(lot_size,1)  into v_lot_size from product where list_market_id = v_market_id and product_id = v_product_id; 

    
    if v_event_id is null then 
        rollback;
        set o_ret_code = 1; 
        set o_ret_msg = 'corp action not EXISTS'; 
        leave label; 
    end if; 
    
    
    

    
    select register_date into v_register_date from corp_action where event_id = i_event_id; 
    if v_register_date is null or date_format(v_register_date,'%Y%m%d') in ('00010101', '99991231', '00000000') then 
        rollback;
        set o_ret_code = 1; 
        set o_ret_msg = 'Register date is wrong'; 
        leave label; 
    end if; 

    

    if ifnull(i_account_id,'') = '' THEN
        delete from corp_action_detail where event_id = i_event_id;

        drop temporary table if exists tmp_register_position; 
        create temporary table tmp_register_position
        (
            market_id int, 
            product_id varchar(32), 
            account_id varchar(16), 
            quantity decimal(30,10),
            nominee_quantity decimal(30,10),
            currency   int(11),
            custodian_code varchar(16),
            custodian_account varchar(16),
            index idx1(market_id,product_id,account_id,custodian_code,custodian_account)
        ); 
        
        if v_register_date > v_process_date then 
            set v_register_date = v_process_date;
        end if;

        insert into tmp_register_position
        select market_id,
                product_id, 
                account_id,
                case when market_id in ('4','8') then net_quantity else quantity end, 
                (nominee_quantity),
                currency,
                custodian_code,
                custodian_account
        from account_position 
        where process_date = v_register_date and 
                market_id = v_market_id and 
                (
                ((case when market_id in ('4','8') then net_quantity else quantity end ) <> 0) or 
                    ( net_quantity <> 0  and v_remove_original_quantity=  'Y')                    
                )
                AND
                (
                    IFNULL(i_custodian_code,'') = '' OR
                    JSON_CONTAINS(  JSON_EXTRACT(i_custodian_code,'$'),  CONCAT('"',custodian_code,'"')  )
                );

        
        INSERT INTO corp_action_detail
        (
            event_id,
            account_id,
            product_id,
            to_product_id,
            bc_quantity,
            non_nominee_quantity,
            apply_quantity,
            dividend_currency,
            dividend_amount,
            dividend_quantity,
            charge1,
            charge2,
            charge3,
            charge4,
            charge5,
            subscribe_charge1,
            subscribe_charge2,
            subscribe_charge3,
            subscribe_charge4,
            excercise_quantity,        
            excess_quantity,           
            alloted_excercise_quanitty,  
            alloted_excess_quantity,     
            refund_amount,             
            refund_excess_amount,      
            custodian_code,
            custodian_account,
            update_user,
            update_time
        )
        SELECT
            i_event_id,
            a.account_id,
            v_product_id,
            v_to_product_id,
            a.quantity,
            if(a.quantity > a.nominee_quantity  , (a.quantity-a.nominee_quantity), 0 ),   
            a.quantity,        
            case when v_dividend_ccy != 0 then v_dividend_ccy else a.currency end,                  
            0,                           
            0,                           
            0,                           
            0,
            0,
            0,
            0,                           
            0,                           
            0,                           
            0,                           
            0,                           
            0,                           
            0,                           
            0,                           
            0,                           
            0,                           
            0,                           
            a.custodian_code,
            a.custodian_account,
            i_update_user,
            now()
        from tmp_register_position a
        where 
            a.market_id = v_market_id and 
            a.product_id = v_product_id and 
            (
                IFNULL(i_custodian_code,'') = '' OR
                JSON_CONTAINS(  JSON_EXTRACT(i_custodian_code,'$'),  CONCAT('"',a.custodian_code,'"')  )
            );
    end if; 
    
    drop temporary table if EXISTS tmp_settle_qty; 
    create temporary table tmp_settle_qty
    (
        account_id varchar(16),
        product_id varchar(32),
        settle_qty decimal(30,10),
        index `idx1` (`account_id`,`product_id`)
    );

    insert into tmp_settle_qty
    select account_id,
           product_id,
           sum(quantity) as settle_qty 
    from unsettled_position 
    where  product_id = v_product_id group by account_id,product_id;


    

    
    
    update corp_action_detail a 
    inner join corp_action b on i_event_id = b.event_id
    left join tmp_settle_qty c on c.account_id = a.account_id and c.product_id = a.product_id 
    inner join market_corp_action d on d.event_type = b.event_type and d.market = b.market_id
    set a.dividend_amount = case when b.scrip_price <> 0 then 0 else round(a.apply_quantity * b.dividend_rate,2) end, 
        a.dividend_quantity = 
        case when ifnull(d.remove_original_quantity,'') = 'Y' and ifnull(d.convert_bal,'') = 'Y' then
            (case when (v_to_product_id is null or v_to_product_id = '00000') then 0 
                else (
                    case when (b.ratio_to = 0 or b.ratio_from = 0) then 0 
                        when b.ratio_to = b.ratio_from then a.apply_quantity 
                        else if(floor_sign((a.apply_quantity + ifnull(c.settle_qty,0)) * b.ratio_to/b.ratio_from) <> 
                                (floor_sign(a.apply_quantity * b.ratio_to/b.ratio_from) +  (case when ifnull(c.settle_qty,0) > 0 then 1 when ifnull(c.settle_qty,0) < 0 then -1 else 0 end) * floor_sign(ifnull(abs(c.settle_qty),0) * b.ratio_to/b.ratio_from)),
                            (floor_sign((a.apply_quantity + ifnull(c.settle_qty,0)) * b.ratio_to/b.ratio_from) - (case when ifnull(c.settle_qty,0) > 0 then 1 when ifnull(c.settle_qty,0) < 0 then -1 else 0 end) * floor_sign(ifnull(abs(c.settle_qty),0) * b.ratio_to/b.ratio_from)),
                            floor_sign(a.apply_quantity * b.ratio_to/b.ratio_from))
                    end)
                + (case when b.scrip_price <> 0 then (floor_sign(round(a.apply_quantity * b.dividend_rate,2)/b.scrip_price)) else 0 end) 
            end)
        else
            (case when (v_to_product_id is null or v_to_product_id = '00000') then 0 
                else (case when (b.ratio_to = 0 or b.ratio_from = 0) then 0 else floor_sign(a.apply_quantity * b.ratio_to/b.ratio_from) end )
                + (case when b.scrip_price <> 0 then (floor_sign(round(a.apply_quantity * b.dividend_rate,2)/b.scrip_price)) else 0 end) end)
        end 
    where a.event_id = i_event_id and (ifnull(i_account_id,'')  = '' or a.account_id = ifnull(i_account_id,''));
    
    
    drop temporary table if EXISTS cal; 
    create temporary table cal
    (
        id bigint primary key,   
        QTY decimal(30,10),   
        LOT decimal(30,10), 
        CASH decimal(30,10), 
        RIGHTS_LOT decimal(30,10) DEFAULT 1,
        STREET_QTY decimal(30,10), 
        EXERCISE_QTY decimal(30,10),    
        EXCESS_EXERCISE_QTY decimal(30,10), 
        Country VARCHAR(8),
        charge1 decimal(30,10) DEFAULT 0,
    	charge2 decimal(30,10) DEFAULT 0,
        charge3 decimal(30,10) DEFAULT 0,
    	charge4 decimal(30,10) DEFAULT 0,
    	charge5 decimal(30,10) DEFAULT 0,
        subscribe_charge1 decimal(30,10) DEFAULT 0,
        subscribe_charge2 decimal(30,10) DEFAULT 0,
        subscribe_charge3 decimal(30,10) DEFAULT 0,
        subscribe_charge4 decimal(30,10) DEFAULT 0
    );

    
    insert into cal 
    (
        id, 
        QTY,
        LOT, 
        CASH,
        STREET_QTY, 
        EXERCISE_QTY, 
        EXCESS_EXERCISE_QTY,
        Country
    )
    select 
        a.id,
        a.apply_quantity, 
        v_lot_size, 
        a.dividend_amount, 
        a.non_nominee_quantity, 
        a.excercise_quantity, 
        a.excess_quantity,
        case when b.account_class = 3 then b.photo_country else b.party_country end
    from 
    corp_action_detail a
    inner join account_profile b on a.account_id = b.account_id
    where a.event_id = i_event_id and 
          (ifnull(i_account_id,'') = '' or a.account_id = ifnull(i_account_id,''));
    
    
    select ifnull(charge_id1,''),
           ifnull(charge_id2,''),
           ifnull(charge_id3,''),
           ifnull(charge_id4,''),
           ifnull(charge_id5,''),
           ifnull(subscribe_charge_id1,''),
           ifnull(subscribe_charge_id2,''),
           ifnull(subscribe_charge_id3,''),
           ifnull(subscribe_charge_id4,'')
        into 
           v_charge1,
           v_charge2,
           v_charge3,
           v_charge4,
           v_charge5,
           v_sub_charge1,
           v_sub_charge2,
           v_sub_charge3,
           v_sub_charge4
        from corp_action 
        where event_id = i_event_id;
  
    select 
        ifnull(b.formula_value,0) into  v_formula1
    from market_charge_rule a
    inner join formula b  on 'CORP' = b.formula_type and a.formula_code = b.formula_code
    where a.market_id  = v_market_id and a.charge_code = v_charge1; 
  
    select 
        ifnull(b.formula_value,0) into  v_formula2
    from market_charge_rule a
    inner join formula b  on 'CORP' = b.formula_type and a.formula_code = b.formula_code
    where a.market_id  = v_market_id and a.charge_code = v_charge2; 
  
    select 
        ifnull(b.formula_value,0) into  v_formula3
    from market_charge_rule a
    inner join formula b  on 'CORP' = b.formula_type and a.formula_code = b.formula_code
    where a.market_id  = v_market_id and a.charge_code = v_charge3; 
  
    select 
        ifnull(b.formula_value,0) into  v_formula4
    from market_charge_rule a
    inner join formula b  on 'CORP' = b.formula_type and a.formula_code = b.formula_code
    where a.market_id  = v_market_id and a.charge_code = v_charge4;
  
    select 
        ifnull(b.formula_value,0) into  v_formula5
    from market_charge_rule a
    inner join formula b  on 'CORP' = b.formula_type and a.formula_code = b.formula_code
    where a.market_id  = v_market_id and a.charge_code = v_charge5; 

    select 
        ifnull(b.formula_value,0) into  v_sub_formula1
    from market_charge_rule a
    inner join formula b  on 'CORP' = b.formula_type and a.formula_code = b.formula_code
    where a.market_id  = v_market_id and a.charge_code = v_sub_charge1; 

    select 
        ifnull(b.formula_value,0) into  v_sub_formula2
    from market_charge_rule a
    inner join formula b  on 'CORP' = b.formula_type and a.formula_code = b.formula_code
    where a.market_id  = v_market_id and a.charge_code = v_sub_charge2; 

    select 
        ifnull(b.formula_value,0) into  v_sub_formula3
    from market_charge_rule a
    inner join formula b  on 'CORP' = b.formula_type and a.formula_code = b.formula_code
    where a.market_id  = v_market_id and a.charge_code = v_sub_charge3; 

    select 
        ifnull(b.formula_value,0) into  v_sub_formula4
    from market_charge_rule a
    inner join formula b  on 'CORP' = b.formula_type and a.formula_code = b.formula_code
    where a.market_id  = v_market_id and a.charge_code = v_sub_charge4; 

    
    open cur_charge; 
    set v_done = 0; 
    fetch cur_charge into v_id; 
    while v_done <> 1 do 

        SET @sql = CONCAT('update cal ',
                          'set charge1 = ', v_formula1, ' ',
                          ',charge2 = ', v_formula2, ' ',
                          ',charge3 = ', v_formula3, ' ',
                          ',charge4 = ', v_formula4, ' ',
                          ',charge5 = ', v_formula5, ' ',
                          ',subscribe_charge1 = ', v_sub_formula1, ' ',
                          ',subscribe_charge2 = ', v_sub_formula2, ' ',
                          ',subscribe_charge3 = ', v_sub_formula3, ' ',
                          ',subscribe_charge4 = ', v_sub_formula4, ' ',
                          'where id =', v_id, ';');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;

        
        select CASH,charge1,charge2,charge3,charge4,charge5,subscribe_charge1,subscribe_charge2,subscribe_charge3,subscribe_charge4
        into @v_CASH,@v_real_charge1,@v_real_charge2,@v_real_charge3,@v_real_charge4,@v_real_charge5,
                @v_real_subscribe_charge1,@v_real_subscribe_charge2,@v_real_subscribe_charge3,@v_real_subscribe_charge4
        from cal where id = v_id;

        set @sum_charge = @v_real_charge1 + @v_real_charge2 + @v_real_charge3 + @v_real_charge4 + @v_real_charge5 + @v_real_subscribe_charge1 + @v_real_subscribe_charge2 + @v_real_subscribe_charge3 + @v_real_subscribe_charge4;
        
        if @v_CASH <> 0 and @v_CASH < @sum_charge then 
            set @sum_charge = @sum_charge - @v_real_charge1;
            set @v_real_charge1 = if( (@v_CASH - @sum_charge) < 0, 0, (@v_CASH - @sum_charge) );
            set @sum_charge = @sum_charge + @v_real_charge1;

            set @sum_charge = @sum_charge - @v_real_charge2;
            set @v_real_charge2 = if( (@v_CASH - @sum_charge) < 0, 0, (@v_CASH - @sum_charge) );
            set @sum_charge = @sum_charge + @v_real_charge2;

            set @sum_charge = @sum_charge - @v_real_charge3;
            set @v_real_charge3 = if( (@v_CASH - @sum_charge) < 0, 0, (@v_CASH - @sum_charge) );
            set @sum_charge = @sum_charge + @v_real_charge3;

            set @sum_charge = @sum_charge - @v_real_charge4;
            set @v_real_charge4 = if( (@v_CASH - @sum_charge) < 0, 0, (@v_CASH - @sum_charge) );
            set @sum_charge = @sum_charge + @v_real_charge4;

            set @sum_charge = @sum_charge - @v_real_charge5;
            set @v_real_charge5 = if( (@v_CASH - @sum_charge) < 0, 0, (@v_CASH - @sum_charge) );
            set @sum_charge = @sum_charge + @v_real_charge5;

            set @sum_charge = @sum_charge - @v_real_subscribe_charge1;
            set @v_real_subscribe_charge1 = if( (@v_CASH - @sum_charge) < 0, 0, (@v_CASH - @sum_charge) );
            set @sum_charge = @sum_charge + @v_real_subscribe_charge1;

            set @sum_charge = @sum_charge - @v_real_subscribe_charge2;
            set @v_real_subscribe_charge2 = if( (@v_CASH - @sum_charge) < 0, 0, (@v_CASH - @sum_charge) );
            set @sum_charge = @sum_charge + @v_real_subscribe_charge2;
            
            set @sum_charge = @sum_charge - @v_real_subscribe_charge3;
            set @v_real_subscribe_charge3 = if( (@v_CASH - @sum_charge) < 0, 0, (@v_CASH - @sum_charge) );
            set @sum_charge = @sum_charge + @v_real_subscribe_charge3;

            set @sum_charge = @sum_charge - @v_real_subscribe_charge4;
            set @v_real_subscribe_charge4 = if( (@v_CASH - @sum_charge) < 0, 0, (@v_CASH - @sum_charge) );
            set @sum_charge = @sum_charge + @v_real_subscribe_charge4;

            update cal 
            set charge1 = @v_real_charge1,
                charge2 = @v_real_charge2,
                charge3 = @v_real_charge3,
                charge4 = @v_real_charge4,
                charge5 = @v_real_charge5,
                subscribe_charge1 = @v_real_subscribe_charge1,
                subscribe_charge2 = @v_real_subscribe_charge2,
                subscribe_charge3 = @v_real_subscribe_charge3,
                subscribe_charge4 = @v_real_subscribe_charge4
            where id = v_id;
        end if;

        set v_done = 0; 
        fetch cur_charge into v_id; 
    end while; 
    close cur_charge; 

    UPDATE
    corp_action_detail a
      LEFT JOIN cal b ON a.id = b.id
    SET
        a.charge1 = abs(IFNULL(b.charge1,0)),
        a.charge2 = abs(IFNULL(b.charge2,0)),
        a.charge3 = abs(IFNULL(b.charge3,0)),
        a.charge4 = abs(IFNULL(b.charge4,0)),
        a.charge5 = abs(IFNULL(b.charge5,0)),
        a.subscribe_charge1 = abs(IFNULL(b.subscribe_charge1,0)),
        a.subscribe_charge2 = abs(IFNULL(b.subscribe_charge2,0)),
        a.subscribe_charge3 = abs(IFNULL(b.subscribe_charge3,0)),
        a.subscribe_charge4 = abs(IFNULL(b.subscribe_charge4,0))
    WHERE
        a.event_id = i_event_id and 
        (ifnull(i_account_id,'') = '' or a.account_id = ifnull(i_account_id,''));


    
    update corp_action set book_closed = "Y", book_closed_date = v_process_date where event_id = i_event_id;

    if v_error <> 0  then 
        rollback; 
    else 
        
        set o_ret_code = 0; 
        set o_ret_msg = "公司活动登记完成"; 
        commit;
    end if ;
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proSetMenuPrivilege
-- ----------------------------
DROP PROCEDURE IF EXISTS `proSetMenuPrivilege`;
delimiter ;;
CREATE PROCEDURE `proSetMenuPrivilege`(in  i_user varchar(32),
  in  i_visible varchar(1),
  OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin 

    set o_ret_code = 0; 
    set o_ret_msg = ""; 

    if not exists(
        select 1 
        from user 
        where user_id = i_user
    ) then 
        set o_ret_code = 1; 
        set o_ret_msg = "user not exists"; 
        leave label;
    end if; 

    if i_visible <>'Y' then 
        set i_visible = 'N'; 
    end if; 

    delete from user_privilege where user_id = i_user;
    
    
    insert into user_privilege(user_id, menu_id, name, visible)
    select i_user, id, name, i_visible
    from menus 
    where  final = 'Y';

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proSettle
-- ----------------------------
DROP PROCEDURE IF EXISTS `proSettle`;
delimiter ;;
CREATE PROCEDURE `proSettle`(IN  i_market_id int ,
  IN  i_product_type int ,
  in  i_settle_product_flow varchar(1), 
  OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin 
   
   declare v_process_date date; 
   declare v_process_date1 date; 
   
   set o_ret_code = 1;

   select buss_date into v_process_date from sys_info; 
   set v_process_date1 = date_add(v_process_date,interval 1 day );

    if i_settle_product_flow = 'Y' then 
      -- product_flow 交收处理
      call proSettleProductFlow(v_process_date,i_market_id,i_product_type,o_ret_code,o_ret_msg); 
      if o_ret_code then 
        leave label; 
      end if; 
    end if; 

    -- cash_flow 交收处理
--     call proSettleCashFlow(v_process_date,i_market_id,i_product_type,o_ret_code,o_ret_msg); 
--     if o_ret_code then 
--       leave label; 
--     end if; 

    -- 待交收 Begin
    -- 净成交表,用于生成持仓
    drop temporary table IF EXISTS tmp_trade_summary;
    create temporary table  tmp_trade_summary(
            process_date date,
            trade_date date,
            settle_date date,
            account_id char(16),
            account_type int default 0,
            list_market_id  int default 0,
            product_type int default 0,
            product_id varchar(32),
            currency   int default 0,
            quantity  decimal(30, 10)  default 0,
            trade_amount decimal(30, 10)  default 0,
            net_amount decimal(30,10) default 0,
            charges      decimal(30, 10)  default 0,
            processed          char(1)  default 'N', 
            buy_abs_quantity decimal(30,10), 
            buy_abs_amount decimal(30,10), 
            custodian_code varchar(16), 
            custodian_account varchar(16)
    ); 

    -- 按成交汇总生成净成交
    insert into tmp_trade_summary
    select 
            a.process_date,
            a.trade_date,
            a.settle_date,
            a.account_id,
            a.account_type,
            a.list_market_id,
            a.product_type,
            a.product_id,
            a.clearing_currency,
            sum(a.quantity * case a.buy_sell when 1 then 1 when 2 then -1 end),  -- quantity 
            sum( case a.buy_sell when 1 then -1*trade_amount when 2 then trade_amount end),  -- trade_amount
            sum( case a.buy_sell when 1 then -1*net_amount when 2 then net_amount end),  -- trade_amount
            0,  -- charges
            'N',
            sum(case a.buy_sell when 1 then a.trade_amount else 0 end), -- buy_abs_qty
            sum(case a.buy_sell when 1 then a.quantity else 0 end), -- buy_abs_qty
            a.custodian_code, 
            a.custodian_account
    from tmp_account_trade a
    group by 
            a.process_date,
            a.trade_date,
            a.settle_date,
            a.account_id,
            a.account_type,
            a.list_market_id,
            a.product_type,
            a.product_id,
            a.clearing_currency,
            'N',
            a.custodian_code, 
            a.custodian_account;

    -- 生成待交收持仓 
    insert into unsettled_position(
            process_date,
            trade_date,
            settle_date,
            account_id,
            account_type,
            market_id,
            product_type,
            product_id,
            currency,
            quantity,
            amount, 
            custodian_code, 
            custodian_account
            )
    select  process_date,
            trade_date,
            settle_date,
            account_id,
            account_type,
            list_market_id,
            product_type,
            product_id,
            currency,
            quantity, 
            ifnull(net_amount, 0), -- replaced from trade_amount - charge  to net_amount; 
            custodian_code, 
            custodian_account
    from tmp_trade_summary;
    drop temporary table if exists tmp_trade_summary; 
    /******************* 待交收 End  ***************************************************/

   -- 生成已交收记录
   insert into settled_position
      (
        process_date,
        trade_date,
        settle_date,
        account_id,
        account_type,
        market_id,
        product_type,
        product_id,
        currency,
        quantity,
        amount,
        custodian_code, 
        custodian_account
      )
    select v_process_date,
          a.trade_date,
          a.settle_date,
          a.account_id,
          a.account_type,
          a.market_id,
          a.product_type,
          a.product_id,
          a.currency,
          a.quantity,
          a.amount,
          custodian_code, 
          custodian_account
    from unsettled_position a
    where
          settle_date < v_process_date1 and
          a.market_id = i_market_id and
          a.product_type = i_product_type;

    

   -- 生成待交收持仓表
   drop temporary table if exists tmp_unsettled_position; 
   create temporary table tmp_unsettled_position
   (
       market_id int , 
       product_id varchar(32),
       account_id varchar(16), 
       account_type int, 
       quantity decimal(30,10), 
       amount  decimal(30,10),
       custodian_code varchar(16),
       custodian_account varchar(16),
       index idx(market_id,product_id,account_id,account_type,custodian_code,custodian_account)
   );
   insert into tmp_unsettled_position
   select market_id, 
          product_id,
          account_id,
          account_type,
          sum(quantity),
          sum(amount),
          custodian_code,
          custodian_account
    from unsettled_position
    where 
          settle_date > v_process_date and 
          market_id = i_market_id and 
          product_type = i_product_type
          group by market_id,product_id,account_id,account_type,custodian_code,custodian_account;


   -- 生成已交收持仓表 
   drop temporary table if exists tmp_settled_position; 
   create temporary table tmp_settled_position
   (
       market_id int , 
       product_id varchar(32),
       account_id varchar(16), 
       account_type int, 
       quantity decimal(30,10), 
       amount  decimal(30,10),
       custodian_code varchar(16),
       custodian_account varchar(16),
       index idx(market_id,product_id,account_id,account_type,custodian_code,custodian_account)
   );
   insert into tmp_settled_position
   select market_id, 
          product_id,
          account_id,
          account_type,
          sum(quantity),
          sum(amount),
          custodian_code,
          custodian_account
    from settled_position
    where process_date = v_process_date and 
          market_id = i_market_id and 
          product_type = i_product_type
          group by market_id,product_id,account_id,account_type,custodian_code,custodian_account;


   -- 本次成交产生的已交收
   drop temporary table if exists tmp_settled_position_current; 
   create temporary table tmp_settled_position_current
   (
       market_id int , 
       product_id varchar(32),
       account_id varchar(16), 
       account_type int, 
       quantity decimal(30,10), 
       amount  decimal(30,10),
       custodian_code varchar(16),
       custodian_account varchar(16),
       index idx(market_id,product_id,account_id,account_type,custodian_code,custodian_account)
   );
   insert into tmp_settled_position_current
   select market_id, 
          product_id,
          account_id,
          account_type,
          sum(quantity),
          sum(amount),
          custodian_code,
          custodian_account
    from unsettled_position
    where settle_date < v_process_date1 and 
          market_id = i_market_id and 
          product_type = i_product_type
          group by market_id,product_id,account_id,account_type,custodian_code,custodian_account;

    -- 更新持仓交收情况字段
    update account_position a 
       left join tmp_unsettled_position b on a.market_id = b.market_id and a.product_id = b.product_id and a.account_id  = b.account_id and a.account_type = b.account_type and a.custodian_code = b.custodian_code and a.custodian_account = b.custodian_account
       left join tmp_settled_position  c on  a.market_id = c.market_id and a.product_id = c.product_id and a.account_id  = c.account_id and a.account_type = c.account_type and a.custodian_code = c.custodian_code and a.custodian_account = c.custodian_account
       left join tmp_settled_position_current d on  a.market_id = d.market_id and a.product_id = d.product_id and a.account_id  = d.account_id and a.account_type = d.account_type and a.custodian_code = d.custodian_code and a.custodian_account = d.custodian_account
      set a.settled_quantity = ifnull((c.quantity),0),
          a.settled_amount =    round(ifnull((c.amount),0),2),
          a.unsettled_quantity  = ifnull((b.quantity),0), 
          a.unsettled_amount =round(ifnull((b.amount),0), 2), 
          a.quantity = a.quantity + ifnull((d.quantity),0)
          --  a.nominee_quantity = funMin(a.nominee_quantity, funMax(a.nominee_quantity + ifnull((c.quantity),0),0) )
          -- a.net_quantity = round(funMAX(a.quantity-a.frozen_quantity + a.unsettled_quantity,0),2)
       where a.process_date = v_process_date and
          a.market_id = i_market_id and
          a.product_type = i_product_type; 

      update account_position a 
      set a.nominee_quantity = funMin(a.quantity, a.nominee_quantity)
      where a.process_date = v_process_date and
          a.market_id = i_market_id and
          a.product_type = i_product_type; 


    -- 清除待交收持仓记录
    -- delete from unsettled_position  where settle_date < v_process_date1 and market_id = i_market_id and product_type = i_product_type; 

    set o_ret_code = 0;
    set o_ret_msg = '持仓处理完成';
    
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proSettleCashFlow
-- ----------------------------
DROP PROCEDURE IF EXISTS `proSettleCashFlow`;
delimiter ;;
CREATE PROCEDURE `proSettleCashFlow`(IN  i_process_date date, 
  OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin 
    
    set o_ret_code = 0;
    set o_ret_msg = 'Success';

    drop temporary table if exists tmp_settle_summary;
    create temporary table tmp_settle_summary
    (
        account_id varchar(16), 
        currency int,
        settle_balance decimal(30,10),
        index idx1(account_id,currency)
    );

    insert into tmp_settle_summary
    select 
        a.account_id,
        a.currency,
        sum(case when a.purpose = 1 then 1  else -1 end * a.amount)
    from cash_flow a 
    where a.settle_date = i_process_date and 
          a.settle_date > a.process_date and a.status = 'Confirmed'
    group by a.account_id,a.currency
    having(sum(a.amount))<>0;

    update account_balance a 
    inner join  tmp_settle_summary b on a.process_date = i_process_date and a.account_id = b.account_id and a.currency = b.currency
    set a.settle_balance = a.settle_balance + b.settle_balance;
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proSettleProductFlow
-- ----------------------------
DROP PROCEDURE IF EXISTS `proSettleProductFlow`;
delimiter ;;
CREATE PROCEDURE `proSettleProductFlow`(IN  i_process_date date, 
  IN  i_market_id int ,
  IN  i_product_type int,
  OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin 
    
    set o_ret_code = 0;
    set o_ret_msg = 'Success';

    drop temporary table if exists tmp_settle_summary;
    create temporary table tmp_settle_summary
    (
        market_id int, 
        product_id varchar(32), 
        account_id varchar(16), 
        quantity decimal(30,10),
        custodian_code varchar(16), 
        custodian_account varchar(16),
        index idx1(market_id,product_id,account_id)
    );

    insert into tmp_settle_summary
    select 
        a.market_id,
        a.product_id,
        a.account_id,
        sum(case when a.purpose  = 1 then 1  else -1 end *a.quantity),
        a.custodian_code,
        a.custodian_account
    from product_flow a  
    inner join product b on i_market_id = b.list_market_id and a.product_id = b.product_id and  i_product_type = b.product_type
    where a.settle_date = i_process_date and 
          a.market_id = i_market_id  and 
          a.settle_date > a.process_date
    group by a.market_id,a.product_id,a.account_id,a.custodian_code,a.custodian_account
    having(sum(a.quantity))<>0; 


    update account_position a 
    inner join  tmp_settle_summary b on a.process_date = i_process_date and a.market_id = b.market_id and a.product_id = b.product_id and a.account_id = b.account_id and a.custodian_code = b.custodian_code and a.custodian_account = b.custodian_account
    set a.quantity = a.quantity + b.quantity; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proSetVersion
-- ----------------------------
DROP PROCEDURE IF EXISTS `proSetVersion`;
delimiter ;;
CREATE PROCEDURE `proSetVersion`(in  i_pro_name		   varchar(64),
    in  i_ver_sion		   VARCHAR(32))
label_pro: BEGIN
  IF NOT EXISTS(select name from procedure_version	where name=i_pro_name) THEN
  	INSERT INTO	procedure_version VALUES(i_pro_name,i_ver_sion,now(),now());
  ELSE
  	UPDATE procedure_version	SET	update_time=now(),version=i_ver_sion	where name=i_pro_name;
  END IF;
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proSGXFutureMargin
-- ----------------------------
DROP PROCEDURE IF EXISTS `proSGXFutureMargin`;
delimiter ;;
CREATE PROCEDURE `proSGXFutureMargin`(In i_market_id int,
   OUT o_ret_code int,
   OUT o_ret_msg char(128))
label:begin
    declare v_process_date  date;

    select buss_date into v_process_date from sys_info;
    
    
    drop temporary table if EXISTS tmp_margin;
    CREATE temporary TABLE `tmp_margin` (
        id               bigint,
        account_id     char(16),
        account_type    int DEFAULT 0,
        market_id        int DEFAULT 0,
        `product_class` char(16) DEFAULT NULL,
        `product_id` char(32) DEFAULT NULL,
        lot              int DEFAULT 0,
        price_factor decimal(31, 10) DEFAULT 1,
        contract_size decimal(31, 10) DEFAULT 1,
        settle_price  decimal(31, 10) DEFAULT 0,
        floating_model    int DEFAULT 0,
        margin_amt      decimal(30, 10) DEFAULT 0,
        `exchange_initial_margin` decimal(30,10) DEFAULT NULL,
        `exchange_maint_margin` decimal(30,10) DEFAULT NULL,
        `exchange_initial_rate` decimal(30,10) DEFAULT '0.0000000000',
        `exchange_maint_rate` decimal(30,10) DEFAULT '0.0000000000',
        `company_initial_margin` decimal(30,10) DEFAULT NULL,
        `company_maint_margin` decimal(30,10) DEFAULT NULL,
        `company_initial_rate` decimal(30,10) DEFAULT '0.0000000000',
        `company_maint_rate` decimal(30,10) DEFAULT '0.0000000000',
        PRIMARY KEY (`id`)
    ) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;

    insert into tmp_margin
    (
        id,
        account_id,
        account_type,
        market_id,
        product_class,
        product_id,
        price_factor,
        contract_size,
        settle_price,
        lot
    )
    select 
        a.id,
        a.account_id,
        a.account_type,
        a.market_id,
        a.product_class,
        a.product_id,
        b.price_factor,
        b.contract_size,
        a.settle_price,
        a.unclosed_qty
    from  future_open_position a, product b
    where a.market_id = b.list_market_id and
          a.product_id = b.product_id and
          a.market_id = i_market_id and
          a.closed = 'N';

    
    
    update tmp_margin a, product_class_future_margin b
    set a.exchange_initial_margin =  b.exchange_initial_margin,
        a.exchange_maint_margin = b.exchange_maint_margin,
        a.exchange_initial_rate = b.exchange_initial_rate,
        a.exchange_maint_rate  = b.exchange_maint_rate,
        a.company_initial_margin = b.company_initial_margin,
        a.company_maint_margin = b.company_maint_margin,
        a.company_initial_rate = b.company_initial_rate,
        a.company_maint_rate = b.company_maint_rate,
        a.floating_model = b.floating_model
    where a.product_class = b.product_class;


    update tmp_margin a, product_future_margin b
    set a.exchange_initial_margin =  b.exchange_initial_margin,
        a.exchange_maint_margin = b.exchange_maint_margin,
        a.exchange_initial_rate = b.exchange_initial_rate,
        a.exchange_maint_rate  = b.exchange_maint_rate,
        a.company_initial_margin = b.company_initial_margin,
        a.company_maint_margin = b.company_maint_margin,
        a.company_initial_rate = b.company_initial_rate,
        a.company_maint_rate = b.company_maint_rate,
        a.floating_model = b.floating_model
    where a.market_id = b.market_id and
          a.product_id = b.product_id;


    update tmp_margin a
       set  a.company_initial_margin =a.company_initial_margin + a.exchange_initial_margin,
        a.company_maint_margin =a.company_maint_margin + a.exchange_maint_margin,
        a.company_initial_rate =a.company_initial_rate + a.exchange_initial_rate,
        a.company_maint_rate = a.company_maint_rate + a.exchange_maint_rate,
        a.margin_amt = (a.settle_price*a.price_factor*a.contract_size*a.company_initial_rate + a.company_initial_margin)*a.lot 
        where a.floating_model = 1; 

    
    update tmp_margin a
       set a.margin_amt = ((a.settle_price*a.price_factor*a.contract_size*a.exchange_initial_rate + a.exchange_initial_margin)*a.lot)*(1+a.company_initial_rate)+ a.company_initial_margin
        where a.floating_model = 2; 

    update  tmp_margin a
       set  a.margin_amt = (a.settle_price*a.price_factor*a.contract_size*a.company_initial_rate + a.company_initial_margin)*a.lot 
        where a.floating_model = 3;     

    
    update future_open_position a, tmp_margin b set a.margin_amt = b.margin_amt where a.id = b.id;  

    drop temporary table if EXISTS tmp_margin;

    set o_ret_code = 0; 
    set o_ret_msg = "更新新加坡期货保证金完成"; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proStressTesting
-- ----------------------------
DROP PROCEDURE IF EXISTS `proStressTesting`;
delimiter ;;
CREATE PROCEDURE `proStressTesting`(in i_process_date date)
label:begin

    start transaction; 

    drop temporary table if EXISTS report; 
    create temporary table report
    (
        account_id varchar(16), 
        account_type varchar(1), 
        debit_balance varchar(128), 
        product_id varchar(32),
        level1 varchar(128),
        level2 varchar(128),
        loan_ratio varchar(128),
        MV varchar(128),
        principal varchar(128),
        MV_15 varchar(128),
        principal_15 varchar(128),
        MV_25 varchar(128),
        principal_25 varchar(128),
        MV_30 varchar(128),
        principal_30 varchar(128),
        MV_50 varchar(128),
        principal_50 varchar(128)
    );

    drop temporary table if EXISTS result; 
    create temporary table result
    (
        account_id varchar(16), 
        account_type varchar(1), 
        debit_balance decimal(30,10), 
        product_id varchar(32),
        level1 varchar(128),
        level2 varchar(128),
        loan_ratio decimal(30,10),
        MV decimal(30,10),
        principal decimal(30,10),
        MV_15 decimal(30,10),
        principal_15 decimal(30,10),
        MV_25 decimal(30,10),
        principal_25 decimal(30,10),
        MV_30 decimal(30,10),
        principal_30 decimal(30,10),
        MV_50 decimal(30,10),
        principal_50 decimal(30,10),
        index idx1(product_id)
    );

    drop temporary table if EXISTS tmp_account_balance; 
    create temporary table tmp_account_balance
    (
        account_id varchar(16), 
        account_type varchar(1), 
        debit_balance decimal(30,10), 
        index idx1(account_id,account_type)
    );

    insert into tmp_account_balance
    select account_id,account_type,
		sum(round(settle_balance * (case currency when 1 then 1.1 when 2 then 1 when 4 then 7.75 end),2)) as debit_balance
	from account_balance 
	where process_date = i_process_date and account_type = 2 
    group by account_id,account_type
    having(debit_balance < 0 );

    insert into result
    select 
        a.account_id,
        a.account_type,
        b.debit_balance,
        a.product_id,
        '', -- leavel1
        '', -- leavel2
        ifnull(c.loan_ratio , 0 ) as loan_ratio,
        (round(a.market_value * (case a.currency when 1 then 1.1 when 2 then 1 when 4 then 7.75 end),2) ) as MV,
        (round(a.market_value * (case a.currency when 1 then 1.1 when 2 then 1 when 4 then 7.75 end) * (1 - ifnull(c.loan_ratio,0)/100) ,2) ) as principal,
        (round(a.market_value * (case a.currency when 1 then 1.1 when 2 then 1 when 4 then 7.75 end) * (0.15) ,2) ) as MV_15,
        (round(a.market_value * (case a.currency when 1 then 1.1 when 2 then 1 when 4 then 7.75 end) * (1 - ifnull(c.loan_ratio,0)/100 - 0.15) ,2) ) as principal_15,
        (round(a.market_value * (case a.currency when 1 then 1.1 when 2 then 1 when 4 then 7.75 end) * (0.25) ,2) ) as MV_25,
        (round(a.market_value * (case a.currency when 1 then 1.1 when 2 then 1 when 4 then 7.75 end) * (1 - ifnull(c.loan_ratio,0)/100 - 0.25) ,2) ) as principal_25,
        (round(a.market_value * (case a.currency when 1 then 1.1 when 2 then 1 when 4 then 7.75 end) * (0.3) ,2) ) as MV_30,
        (round(a.market_value * (case a.currency when 1 then 1.1 when 2 then 1 when 4 then 7.75 end) * (1 - ifnull(c.loan_ratio,0)/100 - 0.30) ,2) ) as principal_30,
        (round(a.market_value * (case a.currency when 1 then 1.1 when 2 then 1 when 4 then 7.75 end) * (0.5) ,2) ) as MV_50,
        (round(a.market_value * (case a.currency when 1 then 1.1 when 2 then 1 when 4 then 7.75 end) * (1 - ifnull(c.loan_ratio,0)/100 - 0.5) ,2) ) as principal_50
    from account_position a 
    inner join tmp_account_balance b on a.account_id = b.account_id and a.account_type = b.account_type
    inner join product c on c.product_id = a.product_id
    where a.process_date = i_process_date and a.account_type = 2 and a.net_quantity <> 0  order by a.account_id,a.product_id;

    update result
    set principal_15 = case when principal_15 < 0 then 0 else principal_15 end,
        principal_25 = case when principal_25 < 0 then 0 else principal_25 end,
        principal_30 = case when principal_30 < 0 then 0 else principal_30 end,
        principal_50 = case when principal_50 < 0 then 0 else principal_50 end;

    update result a
	inner join basicdata.index_component b on a.product_id = b.code and ifnull(b.index_name , '') in ( '恒生指数' , '标准普尔500指数') 
    set a.level1 = if( ifnull(b.index_name , '') <> '' , 'Y' , '' );
	
    update result a
	left join basicdata.index_component b on a.product_id = b.code and ifnull(b.index_name , '') in ( '恒生综合大型股指数' , 'MSCI')
    set a.level2 = if(ifnull(b.index_name , '') <> '', 'Y' , '' );

    insert into report select *from result;

    insert into report(
        account_id,level1,level2,MV,principal_15,principal_25,principal_30,principal_50
    )
    select 
        '加总',
        '属于级别1的总市值(C)(C/A)',
        '属于级别2的总市值(D)(D/A)',
        '加总总欠款客户市值(A)((C+D)/A)',
        '加总负数',
        '加总负数',
        '加总负数',
        '加总负数';

    insert into report(
        account_id,level1,level2,MV,principal_15,principal_25,principal_30,principal_50
    )
    select 
        '',
        round(sum(case ifnull(level1,'') when 'Y' then MV else 0 end) / sum(MV),4),
        round(sum(case ifnull(level2,'') when 'Y' then MV else 0 end) / sum(MV),4),
        round((sum(case ifnull(level1,'') when 'Y' then MV else 0 end) + sum(case ifnull(level2,'') when 'Y' then MV else 0 end)) / sum(MV) ,4),
        sum(case when principal_15 < 0 then principal_15 else 0 end),
        sum(case when principal_25 < 0 then principal_25 else 0 end),
        sum(case when principal_30 < 0 then principal_30 else 0 end),
        sum(case when principal_50 < 0 then principal_50 else 0 end)
    from result;

    select * from report;

    commit; 
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proSwitchBussiness
-- ----------------------------
DROP PROCEDURE IF EXISTS `proSwitchBussiness`;
delimiter ;;
CREATE PROCEDURE `proSwitchBussiness`(IN i_buss_date date, 
    OUT o_ret_code int , 
    OUT o_ret_msg varchar(128))
label: BEGIN

DECLARE v_time_zone int DEFAULT NULL;
DECLARE v_buss_date date default NULL ; 
DECLARE v_last_buss_date  date default NULL; 

set o_ret_code = 0, o_ret_msg = "Success";
start transaction ; 

SELECT time_zone INTO v_time_zone FROM sys_info;
IF v_time_zone IS NULL THEN
  SET v_time_zone = 8;
  UPDATE sys_info SET time_zone = v_time_zone;
END IF;

if i_buss_date is null then 
   set o_ret_code = 1; 
   set o_ret_msg = "Bussiness date is not defined";
   rollback; 
   leave label; 
end if; 

UPDATE sys_info SET last_buss_date = buss_date;
UPDATE sys_info SET buss_date = i_buss_date;

select last_buss_date,buss_date into v_last_buss_date,v_buss_date from sys_info; 


call proBackup(o_ret_code ,o_ret_msg);
if o_ret_code  then 
  rollback; 
  leave label; 
end if; 

call proInitBalance(v_buss_date,v_last_buss_date,o_ret_code ,o_ret_msg); 
if o_ret_code  then 
  rollback; 
  leave label; 
end if; 





call proInitFutureOpenPostion(v_buss_date,v_last_buss_date,o_ret_code,o_ret_msg); 
if o_ret_code   then 
  rollback; 
  leave label; 
end if; 

call proInitPosition(v_buss_date,v_last_buss_date,o_ret_code,o_ret_msg); 
if o_ret_code  then 
  rollback; 
  leave label; 
end if; 


update day_end_process set status = '';
update sys_info set day_end_performed = 'N';

commit; 
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proSwitchTradingDay
-- ----------------------------
DROP PROCEDURE IF EXISTS `proSwitchTradingDay`;
delimiter ;;
CREATE PROCEDURE `proSwitchTradingDay`(in  i_market_id int, 
    in  i_trading_date date,
    in  i_calendar_datetime datetime,
    OUT o_ret_code int , 
    OUT o_ret_msg varchar(128))
label: BEGIN
  -- update market trading day 
  DECLARE v_time_zone int DEFAULT NULL;
  DECLARE v_ret int default 0 ; 
  DECLARE v_msg varchar(64) default '';
  DECLARE v_trade_date date default NULL ; 
  DECLARE v_last_trade_date  date default NULL; 
  set o_ret_code = 0, o_ret_msg = "Success";
  start transaction ; 
  
  SELECT time_zone INTO v_time_zone FROM sys_info;
  
  -- check market 
  if not EXISTS(select 1 from market where market_id  = i_market_id) then 
     set o_ret_code = 1; 
     set o_ret_msg  = concat('market not exists[',i_market_id,']');
     rollback; 
     leave label; 
  end if; 

  -- 取系统时区
  IF v_time_zone IS NULL THEN
    SET v_time_zone = 8;
    UPDATE sys_info SET time_zone = v_time_zone;
  END IF;

  -- 如果没有指定交易日并且传入了当前的自然时间，以当前时间进行转换
  IF i_trading_date  IS NULL  and i_calendar_datetime is not null then 
     update market set t0 = DATE_SUB(i_calendar_datetime, INTERVAL v_time_zone - time_zone HOUR)
     where market_id = i_market_id; 
  elseif i_trading_date is not null then  -- 如果没有传入了trading_date 那么以指定日期更新
     update market set t0  = i_trading_date 
     where market_id = i_market_id; 
  else 
     set o_ret_code = 2; 
     set o_ret_msg  = concat('Trading day and calendar date not input correctly[',i_market_id,']');
     rollback; 
     leave label; 
  end if; 

  -- 根据交易日历重新更新t0
  UPDATE
    market a
  SET
    t0 = (SELECT MIN(calendar_day) FROM calendar WHERE market_id = i_market_id and  calendar_day >= t0 AND holiday in ('N','H','T'))
  where market_id = i_market_id; 

  -- 更新1t,t1,t2 
  UPDATE
    market a
  SET
    1t = (SELECT MAX(calendar_day) FROM calendar WHERE market_id = i_market_id and calendar_day < t0 AND holiday in ('N','H','T')),
    t1 = (SELECT MIN(calendar_day) FROM calendar WHERE market_id =i_market_id and calendar_day > t0 AND holiday in ('N','H','T')),
    t2 = (SELECT MIN(calendar_day) FROM calendar WHERE market_id = i_market_id and calendar_day > t1 AND holiday in ('N','H','T'))
  where market_id = i_market_id;  

  select 1t,t0 into v_last_trade_date,v_trade_date from market where market_id = i_market_id;

  -- call proInitProductMarketData(i_market_id,v_trade_date,v_last_trade_date,o_ret_code ,o_ret_msg); 
  if o_ret_code  then 
    rollback; 
    leave label; 
  end if; 

commit; 
END
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proTest
-- ----------------------------
DROP PROCEDURE IF EXISTS `proTest`;
delimiter ;;
CREATE PROCEDURE `proTest`(IN  i_process_date date, 
  OUT o_ret_code int,
  OUT o_ret_msg char(128))
label:begin
  
    declare v_done int; 
    declare v_day date; 
    declare v_interest_day date;   
    declare cur_day cursor for
        select process_date 
        from tmp_dates; 
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done=1;

    
    drop temporary table if exists tmp_dates; 
    create temporary table tmp_dates(process_date date, index idx(process_date)); 
    insert into tmp_dates
    select process_date 
    from account_balance a 
    where process_date>='20200601' and process_date<='20200625'
    group by process_date; 

    
    drop temporary table if exists tmp_interest_summary; 
    create temporary table tmp_interest_summary
    (
        process_date date ,
        account_id varchar(32), 
        currency int, 
        accrued_interest decimal(30,10) default 0 , 
        index(process_date, account_id,currency)
    );


    insert into tmp_interest_summary(process_date, account_id, currency)
    select 
       a.process_date, 
       b.account_id, 
       '4'
    from tmp_dates a 
    inner join tmp_accounts b ; 

    drop temporary table if exists tmp_cash_interst_summary; 
    create temporary table tmp_cash_interst_summary
    (
        account_id varchar(32), 
        currency int, 
        accrued_interest decimal(30,10),
        index(account_id, currency)
    ); 

    drop temporary table if exists tmp_stock_interst_summary; 
    create temporary table tmp_stock_interst_summary
    (
        account_id varchar(32), 
        currency int, 
        accrued_interest decimal(30,10),
        index(account_id, currency)
    ); 

    open cur_day; 
    set v_done = 0; 
    fetch cur_day into v_day; 
    while v_done <> 1 do 

        set v_interest_day = v_day;
        if date_format(v_interest_day,'%w')  = '5' then  
            set v_interest_day  = date_add(v_interest_day,interval 2 day); 
        end if;

        truncate table tmp_cash_interst_summary; 
        truncate table tmp_stock_interst_summary; 

        
        insert into tmp_cash_interst_summary
        select a.account_id, 
               currency, 
               sum(debit_interest)
        from account_interest a 
        inner join tmp_accounts b on a.account_id = b.account_id
        where a.process_date>='20200601' and a.process_date<=v_interest_day and currency = '4'
        group by a.account_id, currency; 


        insert into tmp_stock_interst_summary
        select a.account_id, 
               currency, 
               sum(borrow_fee)
        from borrow_fee_flow a 
        inner join tmp_accounts b on a.account_id = b.account_id
        where a.process_date>='20200601' and a.process_date<=v_interest_day and currency = '4'
        group by a.account_id, currency; 

        update tmp_interest_summary a 
        left join tmp_cash_interst_summary b on a.process_date = v_day and a.account_id = b.account_id and a.currency = b.currency 
        left join tmp_stock_interst_summary c on a.process_date = v_day and a.account_id = c.account_id and a.currency = c.currency 
        set a.accrued_interest = a.accrued_interest + ifnull(b.accrued_interest,0) + ifnull(c.accrued_interest,0)
        where a.process_date = v_day; 


        set v_done = 0; 
        fetch cur_day into v_day; 
    end while; 


    set o_ret_code = 0; 
    set o_ret_msg = "";

end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for proTradeProcess
-- ----------------------------
DROP PROCEDURE IF EXISTS `proTradeProcess`;
delimiter ;;
CREATE PROCEDURE `proTradeProcess`(In i_market_id int,
    In i_product_type int,
   OUT o_ret_code int,
   OUT o_ret_msg char(128))
label:begin 
    declare v_process_date  date;
    DECLARE v_error int;

    declare CONTINUE HANDLER FOR SQLEXCEPTION
        begin
            GET DIAGNOSTICS CONDITION 1
            o_ret_msg = MESSAGE_TEXT,
            o_ret_code = RETURNED_SQLSTATE; 
            set v_error = 1;
        end; 

    set v_error = 0 ; 

    select buss_date into v_process_date from sys_info;

    start transaction;
    -- 交易费用计算
    call proMarketCharge(o_ret_code,o_ret_msg); 
    if o_ret_code <> 0 then 
        rollback;
        leave label; 
    end if; 
   
    -- 开仓处理
    call proOpenPosition(i_market_id,i_product_type,o_ret_code,o_ret_msg); 
    if o_ret_code <> 0 then 
        rollback;
        leave label; 
    end if; 

    -- 交收处理
    call proSettle(i_market_id, i_product_type, 'Y', o_ret_code, o_ret_msg);
    if o_ret_code <> 0 then 
        rollback;
        leave label; 
    end if; 

    -- 持仓处理
    call proPosition(i_market_id, i_product_type, o_ret_code, o_ret_msg);
    if o_ret_code <> 0 then 
        rollback;
        leave label; 
    end if; 

    -- 余额处理
    call proBalance(i_market_id, i_product_type, o_ret_code,o_ret_msg); 
    if o_ret_code <> 0 then 
        rollback;
        leave label; 
    end if; 

    update import_account_trade_detail 
        set ConfirmStatus = "Confirmed"
    where ConfirmStatus = 'Pending' and (i_market_id = '' or i_market_id = market_id) and (i_product_type = '' or product_type = i_product_type);


    if i_market_id = 16 and i_product_type = 64 then 
        insert into daily_process_log(process_date,process,result,update_user,update_time) 
        select v_process_date, 'US_TRADE_CONFIRM','FINISH','Trade Process', now();
    end if;

    if v_error <> 0  then 
        rollback; 
    else 
        -- 如果不捕获v_error,test1里会插入a; 
        set o_ret_code = 0; 
        set o_ret_msg = "成交处理完成"; 
        commit;
    end if ;
end
;;
delimiter ;

-- ----------------------------
-- Procedure structure for pro_query_JUNIORB_gts_cacc_cash_bal_after_clearing_us
-- ----------------------------
DROP PROCEDURE IF EXISTS `pro_query_JUNIORB_gts_cacc_cash_bal_after_clearing_us`;
delimiter ;;
CREATE PROCEDURE `pro_query_JUNIORB_gts_cacc_cash_bal_after_clearing_us`()
label:begin

/*
在美股结算后生成资金信息
1. 港股，中华通昨收盘资金
2. 美股取昨收盘资金 + 今交易 + 今公司活动派息等
*/

declare v_process_date date; 
declare v_last_process_date date; 


select buss_date, last_buss_date into v_process_date, v_last_process_date from sys_info;

-- 最终数据
drop temporary table if exists tmp_bal; 
create temporary table tmp_bal
(
    id bigint primary key auto_increment, 
    client_acc_id varchar(32) default '', 
    ccy varchar(3) default '',
    amount decimal(30,10) default 0, -- trade balance     
    amount_on_hand decimal(30,10) default 0,  -- settle_balance + unsettled_t1
    uncleared_amt  decimal(30,10) default 0,  -- no use
    prev_amt_on_hand decimal(30,10) default 0, -- settle_balance 
    db_interest decimal(30,10) default 0, 
    cr_interest decimal(30,10) default 0
);


-- 取昨资产数据 
drop temporary table if exists tmp_account_balance; 
create temporary table tmp_account_balance as select * from account_balance where process_date = v_last_process_date;
create index idx1 on tmp_account_balance(account_id, currency);

-- 取今交易的美股数据金额
drop temporary table if exists tmp_trade_summary ; 
create temporary table tmp_trade_summary
select 
    account_id, 
    clearing_currency as currency, 
    sum(case when buy_sell = 1 then -1 else 1 end * net_amount) as amount
from account_trade 
where process_date = v_process_date and 
      market_id in ('2','16')
group by account_id,clearing_currency;

create index idx1 on tmp_trade_summary(account_id, currency);

-- 取所有的't1'待交收数据： 港股中华通取t0,因为本业务日还没有结束
-- 美股不取待交收，因为本日的数据已经交收掉了
drop temporary table if exists tmp_unsettle_position; 
create temporary table tmp_unsettle_position
select 
    account_id, 
    currency, 
    sum(amount) as amount
from unsettled_position a 
inner join market b on b.market_id = a.market_id and b.t0 = a.settle_date
where a.market_id in ('1','4','8')
group by account_id , currency;
create index idx1 on tmp_unsettle_position(account_id, currency);

-- 取今美股交收的数据 
drop temporary table if exists tmp_settled_us_position; 
create temporary table tmp_settled_us_position
select 
    account_id, 
    currency, 
    sum(amount) as amount
from settled_position a
where a.process_date = v_process_date and a.market_id in ('2','16') 
group by account_id , currency;
create index idx1 on tmp_settled_us_position(account_id, currency);

-- 取今美股相关的公司活动数据 
drop temporary table if exists tmp_cash_flow; 
create temporary table tmp_cash_flow
select 
    account_id, 
    currency, 
    sum(case when purpose = 1 then 1 else -1 end *amount) as amount
from cash_flow 
where process_date = v_process_date and dividend_market_id in('2','16')
group by account_id, currency;
create index idx1 on tmp_cash_flow(account_id, currency);

-- 生成所有的客户号
drop temporary table if exists tmp_accounts_currency; 
create temporary table tmp_accounts_currency
(
    account_id varchar(32), 
    currency int
);
create index idx1 on tmp_accounts_currency(account_id, currency);

insert into tmp_accounts_currency
(
    account_id, 
    currency
)
select 
    account_id, 
    currency 
from tmp_account_balance 
group by account_id, currency

union 

select 
    account_id, 
    currency 
from tmp_trade_summary 
group by account_id, currency

union 

select account_id, 
       currency
from tmp_unsettle_position
group by account_id, currency

union 

select account_id, 
       currency
from tmp_settled_us_position
group by account_id, currency

union 
select account_id, 
       currency
from tmp_cash_flow
group by account_id, currency;


insert into tmp_bal
(
    client_acc_id, 
    ccy,
    amount,
    amount_on_hand,  -- settle_balance + unsettled_t1(这里应该是t0)
    uncleared_amt,  -- no use
    prev_amt_on_hand, -- settle_balance 
    db_interest, 
    cr_interest 
)
select 
    a.account_id, 
    case a.currency when 1 then 'CNY' when '2' then 'HKD' when '4' then 'USD' else ''  end as ccy,
    ifnull(b.trade_balance,0) + ifnull(c.amount,0),
    ifnull(b.settle_balance,0) + ifnull(e.amount,0) + ifnull(d.amount,0),
    0, 
    ifnull(b.settle_balance,0) + ifnull(e.amount,0),
    case when b.accrued_interest_credit - b.accrued_interest <0 then b.accrued_interest_credit - b.accrued_interest else 0 end   AS db_interest, 
    case when b.accrued_interest_credit - b.accrued_interest >0 then b.accrued_interest_credit - b.accrued_interest else 0 end AS cr_interest
from tmp_accounts_currency a 
left join tmp_account_balance b on a.account_id = b.account_id and a.currency = b.currency
left join tmp_trade_summary c on a.account_id = c.account_id and a.currency = c.currency
left join tmp_unsettle_position d on a.account_id = d.account_id and a.currency = d.currency
left join tmp_settled_us_position e on a.account_id = e.account_id and a.currency = e.currency
left join tmp_cash_flow f on a.account_id = f.account_id and a.currency = f.currency;


delete from tmp_bal
where amount = 0 and  amount_on_hand = 0 and prev_amt_on_hand = 0 and db_interest +cr_interest = 0 ; 

end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for pro_query_JUNIORB_gts_cacc_product_bal_after_us_clearing
-- ----------------------------
DROP PROCEDURE IF EXISTS `pro_query_JUNIORB_gts_cacc_product_bal_after_us_clearing`;
delimiter ;;
CREATE PROCEDURE `pro_query_JUNIORB_gts_cacc_product_bal_after_us_clearing`()
label:begin

/*
在美股结算后生成持仓信息
1. 港股，中华通昨持仓
2. 美股取今持仓信息
*/

declare v_process_date date; 
declare v_last_process_date date; 


select buss_date, last_buss_date into v_process_date, v_last_process_date from sys_info;


-- 生成的最终结果
drop temporary table if exists tmp_position; 
create temporary table tmp_position
(
    id bigint primary key auto_increment, 
    client_acc_id varchar(32) default '',
    product_code varchar(32) default '',
    qty decimal(30,10) default 0 , -- net_quantity, 
    avg_cost decimal(30,10) default 0 , 
    buy_qty decimal(30,10) default 0 , -- net_quantity, 
    sell_qty decimal(30,10) default 0, 
    exchange_code varchar(32) default '', 
    contract_info varchar(32) default '',
    trade_date varchar(32) default '/  /', 
    covered_qty decimal(30,10) default 0, 
    qty_on_hand decimal(30,10) default 0, 
    uncleared_qty decimal(30,10) default 0, 
    routing_type varchar(32) default '0'
);


-- 昨日持仓港股+ 中华通的持仓
insert into tmp_position
(
    client_acc_id,
    product_code, 
    qty, 
    avg_cost,
    buy_qty, 
    exchange_code, 
    routing_type
)
SELECT 
    a.account_id AS client_acc_id, 
    a.product_id AS product_code,
    SUM(a.net_quantity) AS qty,
    SUM(a.avg_price1)/count(*) avg_cost,
    SUM(a.net_quantity)  AS buy_qty,
    CASE a.market_id  WHEN '1' THEN 'HKEX'  WHEN '2' THEN 'US'  WHEN '8' THEN  'SZA' WHEN '4' THEN 'SHA' WHEN '16' THEN 'USOTC' ELSE 'HKEX'  end AS exchange_code,
    ifnull(b.broker,'0') as routing_type
FROM account_position a
left join broker_market b on b.custodian_code = a.custodian_code and b.custodian_account = a.custodian_account AND a.market_id=b.market_id 
where process_date = v_last_process_date and a.market_id in ('1','4','8')
GROUP BY a.account_id,a.market_id,a.product_id,a.custodian_code,a.custodian_account
having sum(a.net_quantity) <> 0 
ORDER BY a.account_id,a.product_id,routing_type ;


-- 今日美股持仓
insert into tmp_position
(
    client_acc_id,
    product_code, 
    qty, 
    avg_cost,
    buy_qty, 
    exchange_code, 
    routing_type
)
SELECT 
    a.account_id AS client_acc_id, 
    a.product_id AS product_code,
    SUM(a.net_quantity) AS qty,
    SUM(a.avg_price1)/count(*) avg_cost,
    SUM(a.net_quantity)  AS buy_qty,
    CASE a.market_id  WHEN '1' THEN 'HKEX'  WHEN '2' THEN 'US'  WHEN '8' THEN  'SZA' WHEN '4' THEN 'SHA' WHEN '16' THEN 'USOTC' ELSE 'HKEX'  end AS exchange_code,
    ifnull(b.broker,'0') as routing_type
FROM account_position a
left join broker_market b on b.custodian_code = a.custodian_code and b.custodian_account = a.custodian_account AND a.market_id=b.market_id 
where process_date = v_process_date and a.market_id in ('2','16')
GROUP BY a.account_id,a.market_id,a.product_id,a.custodian_code,a.custodian_account
having sum(a.net_quantity) <> 0 
ORDER BY a.account_id,a.product_id,routing_type ;



end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for pro_query_JUNIORB_product_info_after_us_clearing
-- ----------------------------
DROP PROCEDURE IF EXISTS `pro_query_JUNIORB_product_info_after_us_clearing`;
delimiter ;;
CREATE PROCEDURE `pro_query_JUNIORB_product_info_after_us_clearing`()
label:begin

/*
在美股结算后生成收盘价信息
1. 港股，中华通昨盘资金
2. 美股取今收盘价
*/

declare v_process_date date; 
declare v_last_process_date date; 


select buss_date, last_buss_date into v_process_date, v_last_process_date from sys_info;


-- 生成的最终结果
drop temporary table if exists tmp_product_info; 
create temporary table tmp_product_info
(
    id bigint primary key auto_increment, 
    product_code varchar(32) default '', 
    loan_percent decimal(30,10) default 0,
    exchange_code varchar(32) default '',
    last_price decimal(30,10) default 0
);


-- 生成当前的Product信息和收盘价信息
insert into tmp_product_info
(
    product_code, 
    loan_percent, 
    exchange_code,
    last_price
)
select 
    a.product_id, 
    a.loan_ratio AS loan_percent, 
    CASE a.list_market_id WHEN '1' THEN 'HKEX' WHEN '2' THEN 'US' WHEN '4' THEN 'SHA' WHEN '8' THEN 'SZA' WHEN '16' THEN 'USOTC' ELSE NULL end as exchange_code,
    case when b.market_id in ('2','16') then ifnull(c.closing_price, 0) else ifnull(d.closing_price,0) end 
from product a
inner join market b on a.list_market_id = b.market_id
left join product_market_data c on c.trade_date = b.t0 and a.list_market_id = c.list_market_id and a.product_id = c.product_id 
left join product_market_data d on d.trade_date = b.1t and a.list_market_id = d.list_market_id and a.product_id = d.product_id ;




end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for pro_query_position_extend_after_clearing_us
-- ----------------------------
DROP PROCEDURE IF EXISTS `pro_query_position_extend_after_clearing_us`;
delimiter ;;
CREATE PROCEDURE `pro_query_position_extend_after_clearing_us`()
label:begin

/*
在美股结算后生成持仓收盘价信息
1. 港股，中华通昨持仓
2. 美股取今持仓信息
*/

declare v_process_date date; 
declare v_last_process_date date; 


select buss_date, last_buss_date into v_process_date, v_last_process_date from sys_info;


-- 生成的最终结果
drop temporary table if exists tmp_position; 
create temporary table tmp_position
(
    id bigint primary key auto_increment, 
    account_id varchar(32) default '',
    exchange_id varchar(32) default '', 
    instrument_id varchar(32) default '',
    pre_settlement_price decimal(30,10) default 0
);


-- 港股和中华通： 取昨天的数据 
insert into tmp_position
(
    account_id,
    exchange_id,
    instrument_id,
    pre_settlement_price
)
select 
    a.account_id, 
    CASE a.market_id WHEN '1' THEN 'HKEX' WHEN '2' THEN 'US' WHEN '4' THEN 'SHA' WHEN '8' THEN 'SZA' WHEN '16' THEN 'USOTC' ELSE 'HKEX' end as exchange_id, 
    a.product_id as instrument_id, 
    ifnull(c.closing_price,0) as pre_settlement_price
from account_position a 
inner join market b on a.market_id = b.market_id
inner join product_market_data c on b.1t =c.trade_date and a.market_id = c.list_market_id and a.product_id = c.product_id
where a.process_date = v_last_process_date and a.market_id in ('1','4','8') and a.net_quantity <> 0 
group by a.account_id,a.market_id,a.product_id,c.closing_price
order by account_id,exchange_id,instrument_id; 



--  美股取今天的数据 
insert into tmp_position
(
    account_id,
    exchange_id,
    instrument_id,
    pre_settlement_price
)
select 
    a.account_id, 
    CASE a.market_id WHEN '1' THEN 'HKEX' WHEN '2' THEN 'US' WHEN '4' THEN 'SHA' WHEN '8' THEN 'SZA' WHEN '16' THEN 'USOTC' ELSE 'HKEX' end as exchange_id, 
    a.product_id as instrument_id, 
    ifnull(c.closing_price,0) as pre_settlement_price
from account_position a 
inner join market b on a.market_id = b.market_id
inner join product_market_data c on b.t0 =c.trade_date and a.market_id = c.list_market_id and a.product_id = c.product_id
where a.process_date = v_last_process_date and a.market_id in ('2','16') and a.net_quantity <> 0 
group by a.account_id,a.market_id,a.product_id,c.closing_price
order by account_id,exchange_id,instrument_id; 

end label
;;
delimiter ;

-- ----------------------------
-- Procedure structure for query_position_extend_after_clearing_us
-- ----------------------------
DROP PROCEDURE IF EXISTS `query_position_extend_after_clearing_us`;
delimiter ;;
CREATE PROCEDURE `query_position_extend_after_clearing_us`()
label:begin

/*
在美股结算后生成持仓收盘价信息
1. 港股，中华通昨持仓
2. 美股取今持仓信息
*/

declare v_process_date date; 
declare v_last_process_date date; 


select buss_date, last_buss_date into v_process_date, v_last_process_date from sys_info;


-- 生成的最终结果
drop temporary table if exists tmp_position; 
create temporary table tmp_position
(
    id bigint primary key auto_increment, 
    account_id varchar(32) default '',
    exchange_id varchar(32) default '', 
    instrument_id varchar(32) default '',
    prev_settlement_price decimal(30,10) default 0
);


-- 港股和中华通： 取昨天的数据 
insert into tmp_position
(
    account_id,
    exchange_id,
    prev_settlement_price
)
select 
    a.account_id, 
    CASE a.market_id WHEN '1' THEN 'HKEX' WHEN '2' THEN 'US' WHEN '4' THEN 'SHA' WHEN '8' THEN 'SZA' WHEN '16' THEN 'USOTC' ELSE 'HKEX' end as exchange_id, 
    a.product_id as instrument_id, 
    ifnull(c.closing_price,0) as pre_settlement_price
from account_position a 
inner join market b on a.market_id = b.market_id
inner join product_market_data c on b.1t =c.trade_date and a.market_id = c.list_market_id and a.product_id = c.product_id
where a.process_date = v_last_process_date and a.market_id in ('1','4','8') and a.net_quantity <> 0 
group by a.account_id,a.market_id,a.product_id,c.closing_price
order by account_id,exchange_id,instrument_id; 



--  美股取今天的数据 
insert into tmp_position
(
    account_id,
    exchange_id,
    prev_settlement_price
)
select 
    a.account_id, 
    CASE a.market_id WHEN '1' THEN 'HKEX' WHEN '2' THEN 'US' WHEN '4' THEN 'SHA' WHEN '8' THEN 'SZA' WHEN '16' THEN 'USOTC' ELSE 'HKEX' end as exchange_id, 
    a.product_id as instrument_id, 
    ifnull(c.closing_price,0) as pre_settlement_price
from account_position a 
inner join market b on a.market_id = b.market_id
inner join product_market_data c on b.t0 =c.trade_date and a.market_id = c.list_market_id and a.product_id = c.product_id
where a.process_date = v_last_process_date and a.market_id in ('2','16') and a.net_quantity <> 0 
group by a.account_id,a.market_id,a.product_id,c.closing_price
order by account_id,exchange_id,instrument_id; 

end label
;;
delimiter ;

-- ----------------------------
-- Function structure for rjust
-- ----------------------------
DROP FUNCTION IF EXISTS `rjust`;
delimiter ;;
CREATE FUNCTION `rjust`(str varchar(64), 
    len  int, 
    filler varchar(64))
 RETURNS varchar(64) CHARSET utf8
label_pro: BEGIN
    return right(concat(repeat(filler,len - length(str)),str),len);
END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table account_charge_rule
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_account_charge_rule_after_insert_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_account_charge_rule_after_insert_4_audit_trail` AFTER INSERT ON `account_charge_rule` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'INSERT',NULL,new.account_id,'account_charge_rule',CONCAT(new.account_id,',',new.charge_code,',',new.formula_type,',',new.formula_code),'account_id',NULL,new.account_id,new.update_user,NULL,NULL);

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table account_charge_rule
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_account_charge_rule_after_update_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_account_charge_rule_after_update_4_audit_trail` AFTER UPDATE ON `account_charge_rule` FOR EACH ROW BEGIN
IF ((old.id IS NOT NULL)OR(new.id IS NOT NULL)) AND (old.id <> new.id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_charge_rule',CONCAT(new.account_id,',',new.charge_code,',',new.formula_type,',',new.formula_code),'id',old.id,new.id,new.update_user,NULL,NULL);
END IF;
IF ((old.account_id IS NOT NULL)OR(new.account_id IS NOT NULL)) AND (old.account_id <> new.account_id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_charge_rule',CONCAT(new.account_id,',',new.charge_code,',',new.formula_type,',',new.formula_code),'account_id',old.account_id,new.account_id,new.update_user,NULL,NULL);
END IF;
IF ((old.charge_code IS NOT NULL)OR(new.charge_code IS NOT NULL)) AND (old.charge_code <> new.charge_code) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_charge_rule',CONCAT(new.account_id,',',new.charge_code,',',new.formula_type,',',new.formula_code),'charge_code',old.charge_code,new.charge_code,new.update_user,NULL,NULL);
END IF;
IF ((old.formula_type IS NOT NULL)OR(new.formula_type IS NOT NULL)) AND (old.formula_type <> new.formula_type) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_charge_rule',CONCAT(new.account_id,',',new.charge_code,',',new.formula_type,',',new.formula_code),'formula_type',old.formula_type,new.formula_type,new.update_user,NULL,NULL);
END IF;
IF ((old.formula_code IS NOT NULL)OR(new.formula_code IS NOT NULL)) AND (old.formula_code <> new.formula_code) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_charge_rule',CONCAT(new.account_id,',',new.charge_code,',',new.formula_type,',',new.formula_code),'formula_code',old.formula_code,new.formula_code,new.update_user,NULL,NULL);
END IF;
IF ((old.waive IS NOT NULL)OR(new.waive IS NOT NULL)) AND (old.waive <> new.waive) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_charge_rule',CONCAT(new.account_id,',',new.charge_code,',',new.formula_type,',',new.formula_code),'waive',old.waive,new.waive,new.update_user,NULL,NULL);
END IF;

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table account_charge_rule
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_account_charge_rule_after_delete_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_account_charge_rule_after_delete_4_audit_trail` AFTER DELETE ON `account_charge_rule` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'DELETE',NULL,old.account_id,'account_charge_rule',CONCAT(old.account_id,',',old.charge_code,',',old.formula_type,',',old.formula_code),'account_id',NULL,old.account_id,old.update_user,NULL,NULL);

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table account_commission_rule
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_account_commission_rule_after_insert_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_account_commission_rule_after_insert_4_audit_trail` AFTER INSERT ON `account_commission_rule` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'INSERT',NULL,new.account_id,'account_commission_rule',CONCAT(new.account_id,',',new.market_id,',',new.currency,',',new.formula_type,',',new.formula_code),'account_id',NULL,new.account_id,new.update_user,NULL,NULL);

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table account_commission_rule
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_account_commission_rule_after_update_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_account_commission_rule_after_update_4_audit_trail` AFTER UPDATE ON `account_commission_rule` FOR EACH ROW BEGIN
IF ((old.id IS NOT NULL)OR(new.id IS NOT NULL)) AND (old.id <> new.id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_commission_rule',CONCAT(new.account_id,',',new.market_id,',',new.currency,',',new.formula_type,',',new.formula_code),'id',old.id,new.id,new.update_user,NULL,NULL);
END IF;
IF ((old.account_id IS NOT NULL)OR(new.account_id IS NOT NULL)) AND (old.account_id <> new.account_id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_commission_rule',CONCAT(new.account_id,',',new.market_id,',',new.currency,',',new.formula_type,',',new.formula_code),'account_id',old.account_id,new.account_id,new.update_user,NULL,NULL);
END IF;
IF ((old.market_id IS NOT NULL)OR(new.market_id IS NOT NULL)) AND (old.market_id <> new.market_id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_commission_rule',CONCAT(new.account_id,',',new.market_id,',',new.currency,',',new.formula_type,',',new.formula_code),'market_id',old.market_id,new.market_id,new.update_user,NULL,NULL);
END IF;
IF ((old.currency IS NOT NULL)OR(new.currency IS NOT NULL)) AND (old.currency <> new.currency) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_commission_rule',CONCAT(new.account_id,',',new.market_id,',',new.currency,',',new.formula_type,',',new.formula_code),'currency',old.currency,new.currency,new.update_user,NULL,NULL);
END IF;
IF ((old.formula_type IS NOT NULL)OR(new.formula_type IS NOT NULL)) AND (old.formula_type <> new.formula_type) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_commission_rule',CONCAT(new.account_id,',',new.market_id,',',new.currency,',',new.formula_type,',',new.formula_code),'formula_type',old.formula_type,new.formula_type,new.update_user,NULL,NULL);
END IF;
IF ((old.formula_code IS NOT NULL)OR(new.formula_code IS NOT NULL)) AND (old.formula_code <> new.formula_code) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_commission_rule',CONCAT(new.account_id,',',new.market_id,',',new.currency,',',new.formula_type,',',new.formula_code),'formula_code',old.formula_code,new.formula_code,new.update_user,NULL,NULL);
END IF;
IF ((old.waive IS NOT NULL)OR(new.waive IS NOT NULL)) AND (old.waive <> new.waive) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_commission_rule',CONCAT(new.account_id,',',new.market_id,',',new.currency,',',new.formula_type,',',new.formula_code),'waive',old.waive,new.waive,new.update_user,NULL,NULL);
END IF;

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table account_commission_rule
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_account_commission_rule_after_delete_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_account_commission_rule_after_delete_4_audit_trail` AFTER DELETE ON `account_commission_rule` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'DELETE',NULL,old.account_id,'account_commission_rule',CONCAT(old.account_id,',',old.market_id,',',old.currency,',',old.formula_type,',',old.formula_code),'account_id',NULL,old.account_id,old.update_user,NULL,NULL);

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table account_interest_adj
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_account_interest_adj_after_insert_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_account_interest_adj_after_insert_4_audit_trail` AFTER INSERT ON `account_interest_adj` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'INSERT',NULL,new.account_id,'account_interest_adj',CONCAT(new.account_id,',',new.process_date,',',new.account_type),'account_id',NULL,new.account_id,new.update_user,NULL,NULL);
END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table account_interest_adj
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_account_interest_adj_after_update_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_account_interest_adj_after_update_4_audit_trail` AFTER UPDATE ON `account_interest_adj` FOR EACH ROW BEGIN
IF old.process_date <> new.process_date THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_interest_adj',CONCAT(new.account_id,',',new.process_date,',',new.account_type),'process_date',old.process_date,new.process_date,new.update_user,NULL,NULL);
END IF;
IF old.account_id <> new.account_id THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_interest_adj',CONCAT(new.account_id,',',new.process_date,',',new.account_type),'account_id',old.account_id,new.account_id,new.update_user,NULL,NULL);
END IF;
IF old.account_type <> new.account_type THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_interest_adj',CONCAT(new.account_id,',',new.process_date,',',new.account_type),'account_type',old.account_type,new.account_type,new.update_user,NULL,NULL);
END IF;
IF old.currency <> new.currency THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_interest_adj',CONCAT(new.account_id,',',new.process_date,',',new.account_type),'currency',old.currency,new.currency,new.update_user,NULL,NULL);
END IF;
IF old.adj_interest <> new.adj_interest THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_interest_adj',CONCAT(new.account_id,',',new.process_date,',',new.account_type),'adj_interest',old.adj_interest,new.adj_interest,new.update_user,NULL,NULL);
END IF;
END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table account_interest_rule
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_account_interest_rule_after_insert_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_account_interest_rule_after_insert_4_audit_trail` AFTER INSERT ON `account_interest_rule` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'INSERT',NULL,new.account_id,'account_interest_rule',CONCAT(new.account_id,',',new.currency,',',new.debit_formula_code,',',new.credit_formula_code,',',new.margin_call_formula_code),'account_id',NULL,new.account_id,new.update_user,NULL,NULL);

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table account_interest_rule
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_account_interest_rule_after_update_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_account_interest_rule_after_update_4_audit_trail` AFTER UPDATE ON `account_interest_rule` FOR EACH ROW BEGIN
IF ((old.id IS NOT NULL)OR(new.id IS NOT NULL)) AND (old.id <> new.id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_interest_rule',CONCAT(new.account_id,',',new.currency,',',new.debit_formula_code,',',new.credit_formula_code,',',new.margin_call_formula_code),'id',old.id,new.id,new.update_user,NULL,NULL);
END IF;
IF ((old.account_id IS NOT NULL)OR(new.account_id IS NOT NULL)) AND (old.account_id <> new.account_id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_interest_rule',CONCAT(new.account_id,',',new.currency,',',new.debit_formula_code,',',new.credit_formula_code,',',new.margin_call_formula_code),'account_id',old.account_id,new.account_id,new.update_user,NULL,NULL);
END IF;
IF ((old.currency IS NOT NULL)OR(new.currency IS NOT NULL)) AND (old.currency <> new.currency) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_interest_rule',CONCAT(new.account_id,',',new.currency,',',new.debit_formula_code,',',new.credit_formula_code,',',new.margin_call_formula_code),'currency',old.currency,new.currency,new.update_user,NULL,NULL);
END IF;
IF ((old.debit_formula_code IS NOT NULL)OR(new.debit_formula_code IS NOT NULL)) AND (old.debit_formula_code <> new.debit_formula_code) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_interest_rule',CONCAT(new.account_id,',',new.currency,',',new.debit_formula_code,',',new.credit_formula_code,',',new.margin_call_formula_code),'debit_formula_code',old.debit_formula_code,new.debit_formula_code,new.update_user,NULL,NULL);
END IF;
IF ((old.credit_formula_code IS NOT NULL)OR(new.credit_formula_code IS NOT NULL)) AND (old.credit_formula_code <> new.credit_formula_code) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_interest_rule',CONCAT(new.account_id,',',new.currency,',',new.debit_formula_code,',',new.credit_formula_code,',',new.margin_call_formula_code),'credit_formula_code',old.credit_formula_code,new.credit_formula_code,new.update_user,NULL,NULL);
END IF;
IF ((old.margin_call_formula_code IS NOT NULL)OR(new.margin_call_formula_code IS NOT NULL)) AND (old.margin_call_formula_code <> new.margin_call_formula_code) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_interest_rule',CONCAT(new.account_id,',',new.currency,',',new.debit_formula_code,',',new.credit_formula_code,',',new.margin_call_formula_code),'margin_call_formula_code',old.margin_call_formula_code,new.margin_call_formula_code,new.update_user,NULL,NULL);
END IF;
IF ((old.waive IS NOT NULL)OR(new.waive IS NOT NULL)) AND (old.waive <> new.waive) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_interest_rule',CONCAT(new.account_id,',',new.currency,',',new.debit_formula_code,',',new.credit_formula_code,',',new.margin_call_formula_code),'waive',old.waive,new.waive,new.update_user,NULL,NULL);
END IF;

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table account_interest_rule
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_account_interest_rule_after_delete_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_account_interest_rule_after_delete_4_audit_trail` AFTER DELETE ON `account_interest_rule` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'DELETE',NULL,old.account_id,'account_interest_rule',CONCAT(old.account_id,',',old.currency,',',old.debit_formula_code,',',old.credit_formula_code,',',old.margin_call_formula_code),'account_id',NULL,old.account_id,old.update_user,NULL,NULL);

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table account_profile
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_account_profile_after_insert_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_account_profile_after_insert_4_audit_trail` AFTER INSERT ON `account_profile` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'INSERT',NULL,new.account_id,'account_profile',new.account_id,'account_id',NULL,new.account_id,new.update_user,NULL,NULL);

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table account_profile
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_account_profile_after_update_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_account_profile_after_update_4_audit_trail` AFTER UPDATE ON `account_profile` FOR EACH ROW BEGIN
IF ((old.id IS NOT NULL)OR(new.id IS NOT NULL)) AND (old.id <> new.id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'id',old.id,new.id,new.update_user,NULL,NULL);
END IF;
IF ((old.business_department IS NOT NULL)OR(new.business_department IS NOT NULL)) AND (old.business_department <> new.business_department) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'business_department',old.business_department,new.business_department,new.update_user,NULL,NULL);
END IF;
IF ((old.department_trading_group IS NOT NULL)OR(new.department_trading_group IS NOT NULL)) AND (old.department_trading_group <> new.department_trading_group) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'department_trading_group',old.department_trading_group,new.department_trading_group,new.update_user,NULL,NULL);
END IF;
IF ((old.account_id IS NOT NULL)OR(new.account_id IS NOT NULL)) AND (old.account_id <> new.account_id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'account_id',old.account_id,new.account_id,new.update_user,NULL,NULL);
END IF;
IF ((old.first_name IS NOT NULL)OR(new.first_name IS NOT NULL)) AND (old.first_name <> new.first_name) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'first_name',old.first_name,new.first_name,new.update_user,NULL,NULL);
END IF;
IF ((old.middle_name IS NOT NULL)OR(new.middle_name IS NOT NULL)) AND (old.middle_name <> new.middle_name) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'middle_name',old.middle_name,new.middle_name,new.update_user,NULL,NULL);
END IF;
IF ((old.last_name IS NOT NULL)OR(new.last_name IS NOT NULL)) AND (old.last_name <> new.last_name) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'last_name',old.last_name,new.last_name,new.update_user,NULL,NULL);
END IF;
IF ((old.short_name IS NOT NULL)OR(new.short_name IS NOT NULL)) AND (old.short_name <> new.short_name) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'short_name',old.short_name,new.short_name,new.update_user,NULL,NULL);
END IF;
IF ((old.birth_day IS NOT NULL)OR(new.birth_day IS NOT NULL)) AND (old.birth_day <> new.birth_day) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'birth_day',old.birth_day,new.birth_day,new.update_user,NULL,NULL);
END IF;
IF ((old.gender IS NOT NULL)OR(new.gender IS NOT NULL)) AND (old.gender <> new.gender) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'gender',old.gender,new.gender,new.update_user,NULL,NULL);
END IF;
IF ((old.primary_joint IS NOT NULL)OR(new.primary_joint IS NOT NULL)) AND (old.primary_joint <> new.primary_joint) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'primary_joint',old.primary_joint,new.primary_joint,new.update_user,NULL,NULL);
END IF;
IF ((old.phone1 IS NOT NULL)OR(new.phone1 IS NOT NULL)) AND (old.phone1 <> new.phone1) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'phone1',old.phone1,new.phone1,new.update_user,NULL,NULL);
END IF;
IF ((old.phone2 IS NOT NULL)OR(new.phone2 IS NOT NULL)) AND (old.phone2 <> new.phone2) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'phone2',old.phone2,new.phone2,new.update_user,NULL,NULL);
END IF;
IF ((old.phone3 IS NOT NULL)OR(new.phone3 IS NOT NULL)) AND (old.phone3 <> new.phone3) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'phone3',old.phone3,new.phone3,new.update_user,NULL,NULL);
END IF;
IF ((old.email_address IS NOT NULL)OR(new.email_address IS NOT NULL)) AND (old.email_address <> new.email_address) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'email_address',old.email_address,new.email_address,new.update_user,NULL,NULL);
END IF;
IF ((old.mailing_address IS NOT NULL)OR(new.mailing_address IS NOT NULL)) AND (old.mailing_address <> new.mailing_address) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'mailing_address',old.mailing_address,new.mailing_address,new.update_user,NULL,NULL);
END IF;
IF ((old.daily_statement_email_address IS NOT NULL)OR(new.daily_statement_email_address IS NOT NULL)) AND (old.daily_statement_email_address <> new.daily_statement_email_address) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'daily_statement_email_address',old.daily_statement_email_address,new.daily_statement_email_address,new.update_user,NULL,NULL);
END IF;
IF ((old.monthly_statement_email_address IS NOT NULL)OR(new.monthly_statement_email_address IS NOT NULL)) AND (old.monthly_statement_email_address <> new.monthly_statement_email_address) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'monthly_statement_email_address',old.monthly_statement_email_address,new.monthly_statement_email_address,new.update_user,NULL,NULL);
END IF;
IF ((old.address1 IS NOT NULL)OR(new.address1 IS NOT NULL)) AND (old.address1 <> new.address1) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'address1',old.address1,new.address1,new.update_user,NULL,NULL);
END IF;
IF ((old.address2 IS NOT NULL)OR(new.address2 IS NOT NULL)) AND (old.address2 <> new.address2) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'address2',old.address2,new.address2,new.update_user,NULL,NULL);
END IF;
IF ((old.address3 IS NOT NULL)OR(new.address3 IS NOT NULL)) AND (old.address3 <> new.address3) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'address3',old.address3,new.address3,new.update_user,NULL,NULL);
END IF;
IF ((old.address4 IS NOT NULL)OR(new.address4 IS NOT NULL)) AND (old.address4 <> new.address4) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'address4',old.address4,new.address4,new.update_user,NULL,NULL);
END IF;
IF ((old.city IS NOT NULL)OR(new.city IS NOT NULL)) AND (old.city <> new.city) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'city',old.city,new.city,new.update_user,NULL,NULL);
END IF;
IF ((old.state IS NOT NULL)OR(new.state IS NOT NULL)) AND (old.state <> new.state) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'state',old.state,new.state,new.update_user,NULL,NULL);
END IF;
IF ((old.zip IS NOT NULL)OR(new.zip IS NOT NULL)) AND (old.zip <> new.zip) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'zip',old.zip,new.zip,new.update_user,NULL,NULL);
END IF;
IF ((old.country IS NOT NULL)OR(new.country IS NOT NULL)) AND (old.country <> new.country) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'country',old.country,new.country,new.update_user,NULL,NULL);
END IF;
IF ((old.partyid_type IS NOT NULL)OR(new.partyid_type IS NOT NULL)) AND (old.partyid_type <> new.partyid_type) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'partyid_type',old.partyid_type,new.partyid_type,new.update_user,NULL,NULL);
END IF;
IF ((old.partyid IS NOT NULL)OR(new.partyid IS NOT NULL)) AND (old.partyid <> new.partyid) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'partyid',old.partyid,new.partyid,new.update_user,NULL,NULL);
END IF;
IF ((old.party_country IS NOT NULL)OR(new.party_country IS NOT NULL)) AND (old.party_country <> new.party_country) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'party_country',old.party_country,new.party_country,new.update_user,NULL,NULL);
END IF;
IF ((old.party_effective_date IS NOT NULL)OR(new.party_effective_date IS NOT NULL)) AND (old.party_effective_date <> new.party_effective_date) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'party_effective_date',old.party_effective_date,new.party_effective_date,new.update_user,NULL,NULL);
END IF;
IF ((old.party_expiration_date IS NOT NULL)OR(new.party_expiration_date IS NOT NULL)) AND (old.party_expiration_date <> new.party_expiration_date) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'party_expiration_date',old.party_expiration_date,new.party_expiration_date,new.update_user,NULL,NULL);
END IF;
IF ((old.photoid_type IS NOT NULL)OR(new.photoid_type IS NOT NULL)) AND (old.photoid_type <> new.photoid_type) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'photoid_type',old.photoid_type,new.photoid_type,new.update_user,NULL,NULL);
END IF;
IF ((old.photoid IS NOT NULL)OR(new.photoid IS NOT NULL)) AND (old.photoid <> new.photoid) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'photoid',old.photoid,new.photoid,new.update_user,NULL,NULL);
END IF;
IF ((old.photo_country IS NOT NULL)OR(new.photo_country IS NOT NULL)) AND (old.photo_country <> new.photo_country) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'photo_country',old.photo_country,new.photo_country,new.update_user,NULL,NULL);
END IF;
IF ((old.photo_effective_date IS NOT NULL)OR(new.photo_effective_date IS NOT NULL)) AND (old.photo_effective_date <> new.photo_effective_date) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'photo_effective_date',old.photo_effective_date,new.photo_effective_date,new.update_user,NULL,NULL);
END IF;
IF ((old.photo_expiration_date IS NOT NULL)OR(new.photo_expiration_date IS NOT NULL)) AND (old.photo_expiration_date <> new.photo_expiration_date) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'photo_expiration_date',old.photo_expiration_date,new.photo_expiration_date,new.update_user,NULL,NULL);
END IF;
IF ((old.bank IS NOT NULL)OR(new.bank IS NOT NULL)) AND (old.bank <> new.bank) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'bank',old.bank,new.bank,new.update_user,NULL,NULL);
END IF;
IF ((old.bank_account_id IS NOT NULL)OR(new.bank_account_id IS NOT NULL)) AND (old.bank_account_id <> new.bank_account_id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'bank_account_id',old.bank_account_id,new.bank_account_id,new.update_user,NULL,NULL);
END IF;
IF ((old.bank_account_name IS NOT NULL)OR(new.bank_account_name IS NOT NULL)) AND (old.bank_account_name <> new.bank_account_name) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'bank_account_name',old.bank_account_name,new.bank_account_name,new.update_user,NULL,NULL);
END IF;
IF ((old.employment IS NOT NULL)OR(new.employment IS NOT NULL)) AND (old.employment <> new.employment) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'employment',old.employment,new.employment,new.update_user,NULL,NULL);
END IF;
IF ((old.employer_name IS NOT NULL)OR(new.employer_name IS NOT NULL)) AND (old.employer_name <> new.employer_name) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'employer_name',old.employer_name,new.employer_name,new.update_user,NULL,NULL);
END IF;
IF ((old.employer_address1 IS NOT NULL)OR(new.employer_address1 IS NOT NULL)) AND (old.employer_address1 <> new.employer_address1) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'employer_address1',old.employer_address1,new.employer_address1,new.update_user,NULL,NULL);
END IF;
IF ((old.employer_address2 IS NOT NULL)OR(new.employer_address2 IS NOT NULL)) AND (old.employer_address2 <> new.employer_address2) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'employer_address2',old.employer_address2,new.employer_address2,new.update_user,NULL,NULL);
END IF;
IF ((old.employer_address3 IS NOT NULL)OR(new.employer_address3 IS NOT NULL)) AND (old.employer_address3 <> new.employer_address3) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'employer_address3',old.employer_address3,new.employer_address3,new.update_user,NULL,NULL);
END IF;
IF ((old.employer_address4 IS NOT NULL)OR(new.employer_address4 IS NOT NULL)) AND (old.employer_address4 <> new.employer_address4) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'employer_address4',old.employer_address4,new.employer_address4,new.update_user,NULL,NULL);
END IF;
IF ((old.employer_city IS NOT NULL)OR(new.employer_city IS NOT NULL)) AND (old.employer_city <> new.employer_city) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'employer_city',old.employer_city,new.employer_city,new.update_user,NULL,NULL);
END IF;
IF ((old.employer_state IS NOT NULL)OR(new.employer_state IS NOT NULL)) AND (old.employer_state <> new.employer_state) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'employer_state',old.employer_state,new.employer_state,new.update_user,NULL,NULL);
END IF;
IF ((old.employer_zip IS NOT NULL)OR(new.employer_zip IS NOT NULL)) AND (old.employer_zip <> new.employer_zip) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'employer_zip',old.employer_zip,new.employer_zip,new.update_user,NULL,NULL);
END IF;
IF ((old.employer_country IS NOT NULL)OR(new.employer_country IS NOT NULL)) AND (old.employer_country <> new.employer_country) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'employer_country',old.employer_country,new.employer_country,new.update_user,NULL,NULL);
END IF;
IF ((old.employer_phone1 IS NOT NULL)OR(new.employer_phone1 IS NOT NULL)) AND (old.employer_phone1 <> new.employer_phone1) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'employer_phone1',old.employer_phone1,new.employer_phone1,new.update_user,NULL,NULL);
END IF;
IF ((old.employer_phone2 IS NOT NULL)OR(new.employer_phone2 IS NOT NULL)) AND (old.employer_phone2 <> new.employer_phone2) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'employer_phone2',old.employer_phone2,new.employer_phone2,new.update_user,NULL,NULL);
END IF;
IF ((old.employer_phone3 IS NOT NULL)OR(new.employer_phone3 IS NOT NULL)) AND (old.employer_phone3 <> new.employer_phone3) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'employer_phone3',old.employer_phone3,new.employer_phone3,new.update_user,NULL,NULL);
END IF;
IF ((old.is_government_official IS NOT NULL)OR(new.is_government_official IS NOT NULL)) AND (old.is_government_official <> new.is_government_official) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'is_government_official',old.is_government_official,new.is_government_official,new.update_user,NULL,NULL);
END IF;
IF ((old.is_terrorist IS NOT NULL)OR(new.is_terrorist IS NOT NULL)) AND (old.is_terrorist <> new.is_terrorist) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'is_terrorist',old.is_terrorist,new.is_terrorist,new.update_user,NULL,NULL);
END IF;
IF ((old.famaliy_income IS NOT NULL)OR(new.famaliy_income IS NOT NULL)) AND (old.famaliy_income <> new.famaliy_income) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'famaliy_income',old.famaliy_income,new.famaliy_income,new.update_user,NULL,NULL);
END IF;
IF ((old.famaliy_equity IS NOT NULL)OR(new.famaliy_equity IS NOT NULL)) AND (old.famaliy_equity <> new.famaliy_equity) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'famaliy_equity',old.famaliy_equity,new.famaliy_equity,new.update_user,NULL,NULL);
END IF;
IF ((old.risk_tolerance IS NOT NULL)OR(new.risk_tolerance IS NOT NULL)) AND (old.risk_tolerance <> new.risk_tolerance) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'risk_tolerance',old.risk_tolerance,new.risk_tolerance,new.update_user,NULL,NULL);
END IF;
IF ((old.invest_target IS NOT NULL)OR(new.invest_target IS NOT NULL)) AND (old.invest_target <> new.invest_target) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'invest_target',old.invest_target,new.invest_target,new.update_user,NULL,NULL);
END IF;
IF ((old.security_experience IS NOT NULL)OR(new.security_experience IS NOT NULL)) AND (old.security_experience <> new.security_experience) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'security_experience',old.security_experience,new.security_experience,new.update_user,NULL,NULL);
END IF;
IF ((old.fund_experience IS NOT NULL)OR(new.fund_experience IS NOT NULL)) AND (old.fund_experience <> new.fund_experience) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'fund_experience',old.fund_experience,new.fund_experience,new.update_user,NULL,NULL);
END IF;
IF ((old.forien_exchange_experience IS NOT NULL)OR(new.forien_exchange_experience IS NOT NULL)) AND (old.forien_exchange_experience <> new.forien_exchange_experience) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'forien_exchange_experience',old.forien_exchange_experience,new.forien_exchange_experience,new.update_user,NULL,NULL);
END IF;
IF ((old.fixed_income_experience IS NOT NULL)OR(new.fixed_income_experience IS NOT NULL)) AND (old.fixed_income_experience <> new.fixed_income_experience) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'fixed_income_experience',old.fixed_income_experience,new.fixed_income_experience,new.update_user,NULL,NULL);
END IF;
IF ((old.others_incom_experience IS NOT NULL)OR(new.others_incom_experience IS NOT NULL)) AND (old.others_incom_experience <> new.others_incom_experience) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'others_incom_experience',old.others_incom_experience,new.others_incom_experience,new.update_user,NULL,NULL);
END IF;
IF ((old.bos_uuid IS NOT NULL)OR(new.bos_uuid IS NOT NULL)) AND (old.bos_uuid <> new.bos_uuid) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'bos_uuid',old.bos_uuid,new.bos_uuid,new.update_user,NULL,NULL);
END IF;
IF ((old.status IS NOT NULL)OR(new.status IS NOT NULL)) AND (old.status <> new.status) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'status',old.status,new.status,new.update_user,NULL,NULL);
END IF;
IF ((old.account_class IS NOT NULL)OR(new.account_class IS NOT NULL)) AND (old.account_class <> new.account_class) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'account_profile',new.account_id,'account_class',old.account_class,new.account_class,new.update_user,NULL,NULL);
END IF;

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table account_profile
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_account_profile_after_delete_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_account_profile_after_delete_4_audit_trail` AFTER DELETE ON `account_profile` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'DELETE',NULL,old.account_id,'account_profile',old.account_id,'account_id',NULL,old.account_id,old.update_user,NULL,NULL);

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table capital_account
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_capital_account_after_insert_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_capital_account_after_insert_4_audit_trail` AFTER INSERT ON `capital_account` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'INSERT',NULL,new.account_id,'capital_account',new.account_id,'account_id',NULL,new.account_id,new.update_user,NULL,NULL);

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table capital_account
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_capital_account_after_update`;
delimiter ;;
CREATE TRIGGER `trg_capital_account_after_update` AFTER UPDATE ON `capital_account` FOR EACH ROW BEGIN
    if old.account_type <> new.account_type then 
      call proAfterUpdateAccountType(new.account_id,new.account_type,@r1,@r2); 
    end if; 
    IF IFNULL(old.account_tag,'') <> IFNULL(new.account_tag,'') THEN 
    CALL proAccountTagSetting(new.account_id,new.account_tag,@r1,@r2);
    END IF;
END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table capital_account
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_capital_account_after_update_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_capital_account_after_update_4_audit_trail` AFTER UPDATE ON `capital_account` FOR EACH ROW BEGIN
IF ((old.id IS NOT NULL)OR(new.id IS NOT NULL)) AND (old.id <> new.id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'capital_account',new.account_id,'id',old.id,new.id,new.update_user,NULL,NULL);
END IF;
IF ((old.account_id IS NOT NULL)OR(new.account_id IS NOT NULL)) AND (old.account_id <> new.account_id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'capital_account',new.account_id,'account_id',old.account_id,new.account_id,new.update_user,NULL,NULL);
END IF;
IF ((old.password IS NOT NULL)OR(new.password IS NOT NULL)) AND (old.password <> new.password) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'capital_account',new.account_id,'password',old.password,new.password,new.update_user,NULL,NULL);
END IF;
IF ((old.account_type IS NOT NULL)OR(new.account_type IS NOT NULL)) AND (old.account_type <> new.account_type) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'capital_account',new.account_id,'account_type',old.account_type,new.account_type,new.update_user,NULL,NULL);
END IF;
IF ((old.auth_markets IS NOT NULL)OR(new.auth_markets IS NOT NULL)) AND (old.auth_markets <> new.auth_markets) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'capital_account',new.account_id,'auth_markets',old.auth_markets,new.auth_markets,new.update_user,NULL,NULL);
END IF;
IF ((old.auth_currencies IS NOT NULL)OR(new.auth_currencies IS NOT NULL)) AND (old.auth_currencies <> new.auth_currencies) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'capital_account',new.account_id,'auth_currencies',old.auth_currencies,new.auth_currencies,new.update_user,NULL,NULL);
END IF;
IF ((old.loan_limit IS NOT NULL)OR(new.loan_limit IS NOT NULL)) AND (old.loan_limit <> new.loan_limit) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'capital_account',new.account_id,'loan_limit',old.loan_limit,new.loan_limit,new.update_user,NULL,NULL);
END IF;
IF ((old.client_group_code IS NOT NULL)OR(new.client_group_code IS NOT NULL)) AND (old.client_group_code <> new.client_group_code) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'capital_account',new.account_id,'client_group_code',old.client_group_code,new.client_group_code,new.update_user,NULL,NULL);
END IF;
IF ((old.app_usable IS NOT NULL)OR(new.app_usable IS NOT NULL)) AND (old.app_usable <> new.app_usable) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'capital_account',new.account_id,'app_usable',old.app_usable,new.app_usable,new.update_user,NULL,NULL);
END IF;
IF ((old.ae_id IS NOT NULL)OR(new.ae_id IS NOT NULL)) AND (old.ae_id <> new.ae_id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'capital_account',new.account_id,'ae_id',old.ae_id,new.ae_id,new.update_user,NULL,NULL);
END IF;
IF ((old.account_tag IS NOT NULL)OR(new.account_tag IS NOT NULL)) AND (old.account_tag <> new.account_tag) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'capital_account',new.account_id,'account_tag',old.account_tag,new.account_tag,new.update_user,NULL,NULL);
END IF;

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table capital_account
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_account_after_delete`;
delimiter ;;
CREATE TRIGGER `trg_account_after_delete` AFTER DELETE ON `capital_account` FOR EACH ROW begin
		set @date = (select buss_date from sys_info);
    delete from account_balance where account_id = old.account_id and account_type = old.account_type and process_date = @date;
end
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table capital_account
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_capital_account_after_delete_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_capital_account_after_delete_4_audit_trail` AFTER DELETE ON `capital_account` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'DELETE',NULL,old.account_id,'capital_account',old.account_id,'account_id',NULL,old.account_id,old.update_user,NULL,NULL);

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table currency
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_currency_after_insert_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_currency_after_insert_4_audit_trail` AFTER INSERT ON `currency` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'INSERT',NULL,new.currency,'currency',new.currency,'currency',NULL,new.currency,new.update_user,NULL,NULL);
END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table currency
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_currency_after_update_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_currency_after_update_4_audit_trail` AFTER UPDATE ON `currency` FOR EACH ROW BEGIN
IF old.currency <> new.currency THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.currency,'currency',new.currency,'currency',old.currency,new.currency,new.update_user,NULL,NULL);
END IF;
IF old.currency_desc <> new.currency_desc THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.currency,'currency',new.currency,'currency_desc',old.currency_desc,new.currency_desc,new.update_user,NULL,NULL);
END IF;
IF old.prime_rate <> new.prime_rate THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.currency,'currency',new.currency,'prime_rate',old.prime_rate,new.prime_rate,new.update_user,NULL,NULL);
END IF;
IF old.saving_rate <> new.saving_rate THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.currency,'currency',new.currency,'saving_rate',old.saving_rate,new.saving_rate,new.update_user,NULL,NULL);
END IF;
IF old.debit_formula_type <> new.debit_formula_type THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.currency,'currency',new.currency,'debit_formula_type',old.debit_formula_type,new.debit_formula_type,new.update_user,NULL,NULL);
END IF;
IF old.debit_formula_code <> new.debit_formula_code THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.currency,'currency',new.currency,'debit_formula_code',old.debit_formula_code,new.debit_formula_code,new.update_user,NULL,NULL);
END IF;
IF old.credit_formula_type <> new.credit_formula_type THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.currency,'currency',new.currency,'credit_formula_type',old.credit_formula_type,new.credit_formula_type,new.update_user,NULL,NULL);
END IF;
IF old.credit_formula_code <> new.credit_formula_code THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.currency,'currency',new.currency,'credit_formula_code',old.credit_formula_code,new.credit_formula_code,new.update_user,NULL,NULL);
END IF;
IF old.base <> new.base THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.currency,'currency',new.currency,'base',old.base,new.base,new.update_user,NULL,NULL);
END IF;
IF old.exchange_rate <> new.exchange_rate THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.currency,'currency',new.currency,'exchange_rate',old.exchange_rate,new.exchange_rate,new.update_user,NULL,NULL);
END IF;
END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table formula
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_formula_after_insert_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_formula_after_insert_4_audit_trail` AFTER INSERT ON `formula` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'INSERT',NULL,new.formula_code,'formula',CONCAT(new.formula_code,',',new.formula_type),'formula_code',NULL,new.formula_code,new.update_user,NULL,NULL);

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table formula
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_formula_after_update_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_formula_after_update_4_audit_trail` AFTER UPDATE ON `formula` FOR EACH ROW BEGIN
IF ((old.id IS NOT NULL)OR(new.id IS NOT NULL)) AND (old.id <> new.id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.formula_code,'formula',CONCAT(new.formula_code,',',new.formula_type),'id',old.id,new.id,new.update_user,NULL,NULL);
END IF;
IF ((old.formula_code IS NOT NULL)OR(new.formula_code IS NOT NULL)) AND (old.formula_code <> new.formula_code) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.formula_code,'formula',CONCAT(new.formula_code,',',new.formula_type),'formula_code',old.formula_code,new.formula_code,new.update_user,NULL,NULL);
END IF;
IF ((old.formula_type IS NOT NULL)OR(new.formula_type IS NOT NULL)) AND (old.formula_type <> new.formula_type) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.formula_code,'formula',CONCAT(new.formula_code,',',new.formula_type),'formula_type',old.formula_type,new.formula_type,new.update_user,NULL,NULL);
END IF;
IF ((old.formula_value IS NOT NULL)OR(new.formula_value IS NOT NULL)) AND (old.formula_value <> new.formula_value) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.formula_code,'formula',CONCAT(new.formula_code,',',new.formula_type),'formula_value',old.formula_value,new.formula_value,new.update_user,NULL,NULL);
END IF;
IF ((old.description IS NOT NULL)OR(new.description IS NOT NULL)) AND (old.description <> new.description) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.formula_code,'formula',CONCAT(new.formula_code,',',new.formula_type),'description',old.description,new.description,new.update_user,NULL,NULL);
END IF;

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table formula
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_formula_after_delete_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_formula_after_delete_4_audit_trail` AFTER DELETE ON `formula` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'DELETE',NULL,old.formula_code,'formula',CONCAT(old.formula_code,',',old.formula_type),'formula_code',NULL,old.formula_code,old.update_user,NULL,NULL);

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table market_account_charge_rule
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_market_account_charge_rule_after_insert_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_market_account_charge_rule_after_insert_4_audit_trail` AFTER INSERT ON `market_account_charge_rule` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'INSERT',NULL,new.account_id,'market_account_charge_rule',CONCAT(new.account_id,',',new.account_type,',',new.market_id,',',new.currency,',',new.charge_code),'account_id',NULL,new.account_id,NULL,NULL,NULL);

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table market_account_charge_rule
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_market_account_charge_rule_after_update_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_market_account_charge_rule_after_update_4_audit_trail` AFTER UPDATE ON `market_account_charge_rule` FOR EACH ROW BEGIN
IF ((old.id IS NOT NULL)OR(new.id IS NOT NULL)) AND (old.id <> new.id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'market_account_charge_rule',CONCAT(new.account_id,',',new.account_type,',',new.market_id,',',new.currency,',',new.charge_code),'id',old.id,new.id,NULL,NULL,NULL);
END IF;
IF ((old.account_id IS NOT NULL)OR(new.account_id IS NOT NULL)) AND (old.account_id <> new.account_id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'market_account_charge_rule',CONCAT(new.account_id,',',new.account_type,',',new.market_id,',',new.currency,',',new.charge_code),'account_id',old.account_id,new.account_id,NULL,NULL,NULL);
END IF;
IF ((old.account_type IS NOT NULL)OR(new.account_type IS NOT NULL)) AND (old.account_type <> new.account_type) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'market_account_charge_rule',CONCAT(new.account_id,',',new.account_type,',',new.market_id,',',new.currency,',',new.charge_code),'account_type',old.account_type,new.account_type,NULL,NULL,NULL);
END IF;
IF ((old.market_id IS NOT NULL)OR(new.market_id IS NOT NULL)) AND (old.market_id <> new.market_id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'market_account_charge_rule',CONCAT(new.account_id,',',new.account_type,',',new.market_id,',',new.currency,',',new.charge_code),'market_id',old.market_id,new.market_id,NULL,NULL,NULL);
END IF;
IF ((old.currency IS NOT NULL)OR(new.currency IS NOT NULL)) AND (old.currency <> new.currency) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'market_account_charge_rule',CONCAT(new.account_id,',',new.account_type,',',new.market_id,',',new.currency,',',new.charge_code),'currency',old.currency,new.currency,NULL,NULL,NULL);
END IF;
IF ((old.charge_code IS NOT NULL)OR(new.charge_code IS NOT NULL)) AND (old.charge_code <> new.charge_code) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'market_account_charge_rule',CONCAT(new.account_id,',',new.account_type,',',new.market_id,',',new.currency,',',new.charge_code),'charge_code',old.charge_code,new.charge_code,NULL,NULL,NULL);
END IF;
IF ((old.waive IS NOT NULL)OR(new.waive IS NOT NULL)) AND (old.waive <> new.waive) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'market_account_charge_rule',CONCAT(new.account_id,',',new.account_type,',',new.market_id,',',new.currency,',',new.charge_code),'waive',old.waive,new.waive,NULL,NULL,NULL);
END IF;
IF ((old.formula_code IS NOT NULL)OR(new.formula_code IS NOT NULL)) AND (old.formula_code <> new.formula_code) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'market_account_charge_rule',CONCAT(new.account_id,',',new.account_type,',',new.market_id,',',new.currency,',',new.charge_code),'formula_code',old.formula_code,new.formula_code,NULL,NULL,NULL);
END IF;
IF ((old.formula_type IS NOT NULL)OR(new.formula_type IS NOT NULL)) AND (old.formula_type <> new.formula_type) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'market_account_charge_rule',CONCAT(new.account_id,',',new.account_type,',',new.market_id,',',new.currency,',',new.charge_code),'formula_type',old.formula_type,new.formula_type,NULL,NULL,NULL);
END IF;
IF ((old.description IS NOT NULL)OR(new.description IS NOT NULL)) AND (old.description <> new.description) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'market_account_charge_rule',CONCAT(new.account_id,',',new.account_type,',',new.market_id,',',new.currency,',',new.charge_code),'description',old.description,new.description,NULL,NULL,NULL);
END IF;
IF ((old.sum_flag IS NOT NULL)OR(new.sum_flag IS NOT NULL)) AND (old.sum_flag <> new.sum_flag) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.account_id,'market_account_charge_rule',CONCAT(new.account_id,',',new.account_type,',',new.market_id,',',new.currency,',',new.charge_code),'sum_flag',old.sum_flag,new.sum_flag,NULL,NULL,NULL);
END IF;

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table market_account_charge_rule
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_market_account_charge_rule_after_delete_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_market_account_charge_rule_after_delete_4_audit_trail` AFTER DELETE ON `market_account_charge_rule` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'DELETE',NULL,old.account_id,'market_account_charge_rule',CONCAT(old.account_id,',',old.account_type,',',old.market_id,',',old.currency,',',old.charge_code),'account_id',NULL,old.account_id,NULL,NULL,NULL);

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table market_charge_rule
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_market_charge_rule_after_insert_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_market_charge_rule_after_insert_4_audit_trail` AFTER INSERT ON `market_charge_rule` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'INSERT',NULL,new.charge_code,'market_charge_rule',CONCAT(new.market_id,',',new.currency,',',new.charge_code),'charge_code',NULL,new.charge_code,new.update_user,NULL,NULL);

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table market_charge_rule
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_market_charge_rule_after_update_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_market_charge_rule_after_update_4_audit_trail` AFTER UPDATE ON `market_charge_rule` FOR EACH ROW BEGIN
IF ((old.id IS NOT NULL)OR(new.id IS NOT NULL)) AND (old.id <> new.id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.charge_code,'market_charge_rule',CONCAT(new.market_id,',',new.currency,',',new.charge_code),'id',old.id,new.id,new.update_user,NULL,NULL);
END IF;
IF ((old.market_id IS NOT NULL)OR(new.market_id IS NOT NULL)) AND (old.market_id <> new.market_id) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.charge_code,'market_charge_rule',CONCAT(new.market_id,',',new.currency,',',new.charge_code),'market_id',old.market_id,new.market_id,new.update_user,NULL,NULL);
END IF;
IF ((old.currency IS NOT NULL)OR(new.currency IS NOT NULL)) AND (old.currency <> new.currency) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.charge_code,'market_charge_rule',CONCAT(new.market_id,',',new.currency,',',new.charge_code),'currency',old.currency,new.currency,new.update_user,NULL,NULL);
END IF;
IF ((old.charge_code IS NOT NULL)OR(new.charge_code IS NOT NULL)) AND (old.charge_code <> new.charge_code) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.charge_code,'market_charge_rule',CONCAT(new.market_id,',',new.currency,',',new.charge_code),'charge_code',old.charge_code,new.charge_code,new.update_user,NULL,NULL);
END IF;
IF ((old.waive IS NOT NULL)OR(new.waive IS NOT NULL)) AND (old.waive <> new.waive) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.charge_code,'market_charge_rule',CONCAT(new.market_id,',',new.currency,',',new.charge_code),'waive',old.waive,new.waive,new.update_user,NULL,NULL);
END IF;
IF ((old.formula_code IS NOT NULL)OR(new.formula_code IS NOT NULL)) AND (old.formula_code <> new.formula_code) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.charge_code,'market_charge_rule',CONCAT(new.market_id,',',new.currency,',',new.charge_code),'formula_code',old.formula_code,new.formula_code,new.update_user,NULL,NULL);
END IF;
IF ((old.formula_type IS NOT NULL)OR(new.formula_type IS NOT NULL)) AND (old.formula_type <> new.formula_type) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.charge_code,'market_charge_rule',CONCAT(new.market_id,',',new.currency,',',new.charge_code),'formula_type',old.formula_type,new.formula_type,new.update_user,NULL,NULL);
END IF;
IF ((old.description IS NOT NULL)OR(new.description IS NOT NULL)) AND (old.description <> new.description) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.charge_code,'market_charge_rule',CONCAT(new.market_id,',',new.currency,',',new.charge_code),'description',old.description,new.description,new.update_user,NULL,NULL);
END IF;
IF ((old.sum_flag IS NOT NULL)OR(new.sum_flag IS NOT NULL)) AND (old.sum_flag <> new.sum_flag) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.charge_code,'market_charge_rule',CONCAT(new.market_id,',',new.currency,',',new.charge_code),'sum_flag',old.sum_flag,new.sum_flag,new.update_user,NULL,NULL);
END IF;
IF ((old.posted_method IS NOT NULL)OR(new.posted_method IS NOT NULL)) AND (old.posted_method <> new.posted_method) THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.charge_code,'market_charge_rule',CONCAT(new.market_id,',',new.currency,',',new.charge_code),'posted_method',old.posted_method,new.posted_method,new.update_user,NULL,NULL);
END IF;

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table market_charge_rule
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_market_charge_rule_after_delete_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_market_charge_rule_after_delete_4_audit_trail` AFTER DELETE ON `market_charge_rule` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'DELETE',NULL,old.charge_code,'market_charge_rule',CONCAT(old.market_id,',',old.currency,',',old.charge_code),'charge_code',NULL,old.charge_code,old.update_user,NULL,NULL);

END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table sys_info
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_sys_info_after_insert_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_sys_info_after_insert_4_audit_trail` AFTER INSERT ON `sys_info` FOR EACH ROW BEGIN
CALL proInsertAuditTrail(NULL,'INSERT',NULL,new.id,'sys_info',new.id,'id',NULL,new.id,new.update_user,NULL,NULL);
END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table sys_info
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_sys_info_after_update_4_audit_trail`;
delimiter ;;
CREATE TRIGGER `trg_sys_info_after_update_4_audit_trail` AFTER UPDATE ON `sys_info` FOR EACH ROW BEGIN
IF old.id <> new.id THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.id,'sys_info',new.id,'id',old.id,new.id,new.update_user,NULL,NULL);
END IF;
IF old.last_buss_date <> new.last_buss_date THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.id,'sys_info',new.id,'last_buss_date',old.last_buss_date,new.last_buss_date,new.update_user,NULL,NULL);
END IF;
IF old.buss_date <> new.buss_date THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.id,'sys_info',new.id,'buss_date',old.buss_date,new.buss_date,new.update_user,NULL,NULL);
END IF;
IF old.sys_status <> new.sys_status THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.id,'sys_info',new.id,'sys_status',old.sys_status,new.sys_status,new.update_user,NULL,NULL);
END IF;
IF old.time_zone <> new.time_zone THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.id,'sys_info',new.id,'time_zone',old.time_zone,new.time_zone,new.update_user,NULL,NULL);
END IF;
IF old.backup_path <> new.backup_path THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.id,'sys_info',new.id,'backup_path',old.backup_path,new.backup_path,new.update_user,NULL,NULL);
END IF;
IF old.day_end_performed <> new.day_end_performed THEN
    CALL proInsertAuditTrail(NULL,'UPDATE',NULL,new.id,'sys_info',new.id,'day_end_performed',old.day_end_performed,new.day_end_performed,new.update_user,NULL,NULL);
END IF;
END
;;
delimiter ;

-- ----------------------------
-- Triggers structure for table sys_info
-- ----------------------------
DROP TRIGGER IF EXISTS `trg_sys_info_after_update_4_jcio`;
delimiter ;;
CREATE TRIGGER `trg_sys_info_after_update_4_jcio` AFTER UPDATE ON `sys_info` FOR EACH ROW BEGIN
    INSERT INTO `jcio`.`sys_info`(  id,                sys_status)
                           VALUES(   1,            new.sys_status)
          ON DUPLICATE KEY UPDATE id=1, sys_status=new.sys_status;
END
;;
delimiter ;

SET FOREIGN_KEY_CHECKS = 1;
